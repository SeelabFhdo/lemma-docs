{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Welcome to the documentation of LEMMA---the L anguage E cosystem for M odeling M icroservice A rchitecture. LEMMA is an MDE ( Model-driven Engineering ) solution that aims to facilitate the design, development, and deployment of microservice architectures through the use of modeling languages dedicated to the concise definition of microservices including their domain information and deployment specification , model transformations allowing automatic generation of domain-specific code, microservice code, and deployment configuration for heterogeneous generation targets, and model analysis to support in detecting design smells microservice architectures prior to their development and/or deployment. Take the Tour If you have not yet heard of LEMMA, you may first want to have a look at its Context and Motivation as well as the Feature Overview . In addition, you can read the Getting Started guide and then take the Tour to get a first impression of LEMMA's practical usage. User Guide We provide a User Guide as LEMMA's reference documentation. It draws on the information provided by the Getting Started guide and the Tour . In case you encounter issues with the documentation, have further questions, or any sort of feedback, please do not hesitate to contact us by creating an issue in LEMMA's GitHub repository or dropping us an e-mail . Developer Guide Interested in extending the various capabilities of LEMMA? Take a look at our Developer Guide .","title":"Welcome"},{"location":"#welcome","text":"Welcome to the documentation of LEMMA---the L anguage E cosystem for M odeling M icroservice A rchitecture. LEMMA is an MDE ( Model-driven Engineering ) solution that aims to facilitate the design, development, and deployment of microservice architectures through the use of modeling languages dedicated to the concise definition of microservices including their domain information and deployment specification , model transformations allowing automatic generation of domain-specific code, microservice code, and deployment configuration for heterogeneous generation targets, and model analysis to support in detecting design smells microservice architectures prior to their development and/or deployment.","title":"Welcome"},{"location":"#take-the-tour","text":"If you have not yet heard of LEMMA, you may first want to have a look at its Context and Motivation as well as the Feature Overview . In addition, you can read the Getting Started guide and then take the Tour to get a first impression of LEMMA's practical usage.","title":"Take the Tour"},{"location":"#user-guide","text":"We provide a User Guide as LEMMA's reference documentation. It draws on the information provided by the Getting Started guide and the Tour . In case you encounter issues with the documentation, have further questions, or any sort of feedback, please do not hesitate to contact us by creating an issue in LEMMA's GitHub repository or dropping us an e-mail .","title":"User Guide"},{"location":"#developer-guide","text":"Interested in extending the various capabilities of LEMMA? Take a look at our Developer Guide .","title":"Developer Guide"},{"location":"contact/","text":"Contact Do you have any further questions or feedback? Come visit us over at LEMMA's GitHub repository or drop us an e-mail if you like :-)","title":"Contact"},{"location":"contact/#contact","text":"Do you have any further questions or feedback? Come visit us over at LEMMA's GitHub repository or drop us an e-mail if you like :-)","title":"Contact"},{"location":"context-motivation/","text":"Context and Motivation Context LEMMA is rooted in the domain of Microservice Architecture (MSA), which is an architectural style targeting distributed, service-oriented software systems . MSA promotes to decompose a software system into microservices , which are components that provide a single, distinct functional or infrastructure capability to other architecture components by means of well-defined interfaces, are as independent as possible from other components w.r.t. implementation, data management, testing, deployment, and operation, are fully accountable for all aspects related to their interaction with other components, are owned by exactly one team , which takes full responsibility for design, implementation, and operation issues related to their microservices. Given the above characteristics of a microservice, MSA aims to particularly increase the scalability and maintainability of software systems. Motivation While the adoption of MSA is expected to yield several benefits, it also comes with an increased degree of complexity compared to monolithic applications and their usual multitier architecture : Design Complexity: Typical challenges in MSA design comprise the identification of microservices , the determination of their granularity , and the design of their APIs . Implementation Complexity: The increased independence of microservices enables teams to employ the most suitable technologies to realize their services. These technologies may concern, e.g., programming languages, database systems, communication protocols, and data formats. However, the resulting technology heterogeneity bears a greater risk for technical debt, additional maintainability costs, and steeper learning curves. Consequently, it calls for dedicated management activities. Operation Complexity: MSA emphasizes loose coupling of architecture components, which increases scalability but also requires dedicated components that provide microservices with capabilities such as service discovery, API provisioning, load balancing, and monitoring. These components require regular maintenance and management, which may be aggravated again by an increased technology heterogeneity. Organizational Complexity: MSA is most effective when the structure of the organization is also aligned towards the architectural style. That is, the organization or parts thereof are also decomposed along the communication structures of the eventual software architecture. In particular, MSA fosters DevOps practices so that teams should be composed of members with heterogeneous professional backgrounds. However, the introduction of a DevOps culture also requires the automation of manual tasks and sharing of knowledge across team boundaries 1 . With LEMMA, we study the support of Model-driven Engineering , and especially the abstraction power of models and modeling languages, to mitigate the impact of the aforementioned degrees of MSA complexity. https://www.martinfowler.com/bliki/DevOpsCulture.html \u21a9","title":"Context and Motivation"},{"location":"context-motivation/#context-and-motivation","text":"","title":"Context and Motivation"},{"location":"context-motivation/#context","text":"LEMMA is rooted in the domain of Microservice Architecture (MSA), which is an architectural style targeting distributed, service-oriented software systems . MSA promotes to decompose a software system into microservices , which are components that provide a single, distinct functional or infrastructure capability to other architecture components by means of well-defined interfaces, are as independent as possible from other components w.r.t. implementation, data management, testing, deployment, and operation, are fully accountable for all aspects related to their interaction with other components, are owned by exactly one team , which takes full responsibility for design, implementation, and operation issues related to their microservices. Given the above characteristics of a microservice, MSA aims to particularly increase the scalability and maintainability of software systems.","title":"Context"},{"location":"context-motivation/#motivation","text":"While the adoption of MSA is expected to yield several benefits, it also comes with an increased degree of complexity compared to monolithic applications and their usual multitier architecture : Design Complexity: Typical challenges in MSA design comprise the identification of microservices , the determination of their granularity , and the design of their APIs . Implementation Complexity: The increased independence of microservices enables teams to employ the most suitable technologies to realize their services. These technologies may concern, e.g., programming languages, database systems, communication protocols, and data formats. However, the resulting technology heterogeneity bears a greater risk for technical debt, additional maintainability costs, and steeper learning curves. Consequently, it calls for dedicated management activities. Operation Complexity: MSA emphasizes loose coupling of architecture components, which increases scalability but also requires dedicated components that provide microservices with capabilities such as service discovery, API provisioning, load balancing, and monitoring. These components require regular maintenance and management, which may be aggravated again by an increased technology heterogeneity. Organizational Complexity: MSA is most effective when the structure of the organization is also aligned towards the architectural style. That is, the organization or parts thereof are also decomposed along the communication structures of the eventual software architecture. In particular, MSA fosters DevOps practices so that teams should be composed of members with heterogeneous professional backgrounds. However, the introduction of a DevOps culture also requires the automation of manual tasks and sharing of knowledge across team boundaries 1 . With LEMMA, we study the support of Model-driven Engineering , and especially the abstraction power of models and modeling languages, to mitigate the impact of the aforementioned degrees of MSA complexity. https://www.martinfowler.com/bliki/DevOpsCulture.html \u21a9","title":"Motivation"},{"location":"developer-guide/","text":"Developer Guide The developer guide provides information for everybody interested in the technical details of LEMMA's implementation. Here, you will learn about the design of LEMMA's modeling languages and other technical artifacts of the ecosystem, e.g., the Model Processing Framework or the Java Base Generator. Please note that LEMMA's documentation is currently work in progress. Therefore, the developer guide is not complete yet and we will refer to sections in the dissertation that conceived LEMMA 1 whenever there exists no dedicated writing for a certain article in the developer guide yet. However, the following articles of the developer guide already comprise content condensed and prepared for a broader audience: Coding Style Intermediate Model Specifications Integrating New Modules With LEMMA's Continuous Integration Pipeline Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Introduction"},{"location":"developer-guide/#developer-guide","text":"The developer guide provides information for everybody interested in the technical details of LEMMA's implementation. Here, you will learn about the design of LEMMA's modeling languages and other technical artifacts of the ecosystem, e.g., the Model Processing Framework or the Java Base Generator. Please note that LEMMA's documentation is currently work in progress. Therefore, the developer guide is not complete yet and we will refer to sections in the dissertation that conceived LEMMA 1 whenever there exists no dedicated writing for a certain article in the developer guide yet. However, the following articles of the developer guide already comprise content condensed and prepared for a broader audience: Coding Style Intermediate Model Specifications Integrating New Modules With LEMMA's Continuous Integration Pipeline Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Developer Guide"},{"location":"developer-guide/coding-style/","text":"Coding Style This page describes the preferred coding style for LEMMA. To quote Linus Torvalds in the Linux Kernel Documentation : Quote Coding style is very personal, and I won't force my views on anybody, but this is what goes for anything that I have to be able to maintain, and I'd prefer it for most other things too. Please at least consider the points made here. To rephrase: We greatly welcome all kinds of contributions to LEMMA and its various modules, and hereby encourage all contributors to employ the coding style outlined as follows, even if it contradicts your personal style of programming. That is, because we perceive consistency in source code appearance crucial to ensure a codebase's readability and comprehensibility. Thank you! Scope This style guide concerns all programming languages used in LEMMA modules besides Python, for which we adhere to PEP 8 ; and Bash scripts (at least partially and as described below). Indentation Except for ATL modules (files with the .atl extension), we use spaces instead of tabs to indent LEMMA's source code. An indentation level is introduced by 4 spaces . In ATL modules, we use tabs (instead of spaces) with column width 4 for indentation, which is mainly due to historical reasons. Except for package/module definitions and import statements, a line of code should not exceed 100 columns . Moreover, the maximum count of indentation levels should be 3 . If you require more indentation levels, please refactor your code by introducing, e.g., additional data structures or helper methods. For instance, Xtend code like 1 2 3 4 5 6 7 8 9 10 11 12 class Example { def myMethod ( String param1 , int param2 ) { if ( param1 == \"someString\" ) if ( param2 > 0 ) { ... } else if ( param2 == 0 ) { ... } else { ... } } } should be refactored into something like 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Example { def myMethod ( String param1 , int param2 ) { if ( param1 == \"someString\" ) handleSomeString ( param2 ) } private def handleSomeString ( int param ) { if ( param > 0 ) { ... } else if ( param == 0 ) { ... } else { ... } } } switch statements are an exception to the rule of the maximum indentation level 3. For switch statements we accept a maximum indentation level of 4. Thus, it is perfectly fine to refactor the first Xtend listing above into something like 1 2 3 4 5 6 7 8 9 10 11 12 class Example { def myMethod ( String param1 , int param2 ) { switch ( param1 ) { case \"someString\" : handleSomeString ( param2 ) case \"someOtherString\" : ... default : ... } } } Each line of code should contain exactly one statement , e.g., 1 2 3 4 5 6 7 8 9 10 class Example { def myMethod ( String param1 , int param2 ) { // Wrong myOtherMethod () myOtherOtherMethod () // Right myOtherMethod () myOtherOtherMethod () } } Braces As in K&R style , opening curly braces should be put last on the same line as the statement to which they belong. Divide the statement and the opening curly brace by a single space . Conversely, closing curly braces should be put on their own line : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Example { // Wrong def myFirstMethod () { ... } // Right (curly bracing on class/method level also follows K&R style for // statements) def myMethod ( String param1 , int param2 ) { // Wrong if ( param1 ) { doSomething1 doSomething2 } // Also wrong (no space before opening curly brace) if ( param1 ){ doSomething1 doSomething2 } // Right if ( param1 ) { doSomething1 doSomething2 } } } Spaces and Newlines Spaces There should be one space after keywords like if , case , do , for , and while ; on each side of binary and ternary operators like = , + , - , < , > , * , / , % , | , & , ^ , <= , >= , == , != , ?: ; after statements that are followed by a block (cf. the Braces example listing). There should be no space after keywords like catch and switch ; before parameter lists of methods/functions; after unary operators like ! ; before postfix increment and decrement unary operators, i.e., ++ and -- ; after prefix increment and decrement unary operators, i.e., ++ and -- ; around operators that access members of classes/data structures, e.g., . or -> . Remove spaces that do not comply with the above rules whenever possible, e.g., in empty lines, at the end of a line, at the end of a file. We never require horizontal alignment as the resulting maintainability effort does not justify the possible (and usually small) gain in readability: 1 2 3 4 5 6 7 8 9 class Example { // Wrong static val MY_FIRST_CONSTANT = 1 // Integer static val MY_SECOND_CONSTANT_IS_A_STRING = \"foo\" // String, of course // Right static val MY_FIRST_CONSTANT = 1 // Integer static val MY_SECOND_CONSTANT_IS_A_STRING = \"foo\" // String, of course } Newlines Add one empty line between the definition of semantically or syntactically coherent code blocks so that they are recognizable as such. For example, there should be one empty line between a block of constants and the following block of attributes in a class (semantic cohesion). Similarly, there should be one empty line between the end of a method body and the start of the next method's signature (syntactic cohesion). We do not place a newline at the end of a file . Optional Syntax Constructs Omit optional constructs as permitted by the respective programming language as much as possible to decrease the amount of characters one has to read to understand your code. For example, leave out round braces for functions in Xtend's standard library and semicolons when they are not necessary: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def myMethod ( String param1 , int param2 ) { // Wrong (well-known built-in function, omit round braces) val myMap1 = newHashMap () // Right val myMap2 = newHashMap // Wrong (well-known built-in function, omit round braces; also omit // optional semicolon) val myMap3 = newHashMap (); // Also wrong (omit optional semicolon) val myMap4 = newHashMap ; // Right val myMap5 = newHashMap // Wrong if ( param1 == \"someString\" ) { // Wrong doSomething1 } else { doSomething2 () andSomethingElse () } // Right (omit braces for first if-branch) if ( param1 == \"someString\" ) // Right (custom method, don't omit braces to make clear that this is // a custom method) doSomething1 () else { doSomething2 () andSomethingElse () } } An exception to the rule of omitting unnecessary constructs are code blocks that are empty by intent, e.g., empty catch -blocks or constructor bodies. To communicate the intent of leaving such blocks empty, you should add (i) an explicit comment describing why the respective code block is empty (for catch -blocks and non-trivial constructors); or (ii) an explicit \"NOOP\" line comment (for trivial constructors): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Example2 extends Example { // Right private new () { // NOOP } // Also right new ( String param ) { // Empty constructor body because we don't care about \"param\" // whatsoever } private def myMethod ( String s ) { ... try { return scanner . nextDouble () } catch ( InputMismatchException ex ) { // Wrong: No explanation why this exception is not handled // NOOP } catch ( NoSuchElementException ex ) { // Right // We don't handle this exception due to the following sensible // reasoning: // ... } } } Breaking Long Lines Basic Formatting Lines wider than 100 columns should be broken into sensible chunks , unless exceeding 100 columns significantly increases readability and does not hide information. Descendants should follow LEMMA's coding style w.r.t. indentation : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Example { def myMethod ( String param1 , int param2 ) { // Wrong: No indentation of descendant param2 val myVariableWithAVeryLongName = myFunctionWithAVeryLongName ( param1 , param2 ) // Wrong: Indentation exceeds 4 spaces for descendant param2 val myVariableWithAVeryLongName = myFunctionWithAVeryLongName ( param1 , param2 ) // Right val myVariableWithAVeryLongName = myFunctionWithAVeryLongName ( param1 , param2 ) } } Functions With Long Parameter Lists Functions/methods, whose parameter lists exceed 100 columns , and that have more than two parameters; and breaking parameters into descendant lines result in at least one descendant line comprising only one parameter, which is not the last one should be formatted so that each parameter definition is in its own line . In addition, the closing round brace of the parameter list and the opening curly brace of the function/method body should go on their own line on the same indentation level as the start of the function/method definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Example { // Right (single parameter is the last one) def myMethod2 ( String param1 , int param2 , MyClassWithAVeryLongName param3 , MyClassWithAnEvenLongerName param4 ) { ... } // Wrong (param4 stands on its own line and is not the last parameter) def myMethod3 ( String param1 , int param2 , MyClassWithAVeryLongName param3 , MyClassWithAnEvenLongerNameThatMakesParam4StandAloneInBetween param4 , int param5 , boolean param6 ) { ... } // Right (all parameters on their own line) def myMethod3 ( String param1 , int param2 , MyClassWithAVeryLongName param3 , MyClassWithAnEvenLongerNameThatMakesParam4StandAloneInBetween param4 , int param5 , boolean param6 ) { ... } // Wrong (there are only two parameters and both would fit on their own // line) def myMethod4 ( MyClassWithAVeryLongName myParamWithAVeryLongName , MyClassWithAnEvenLongerName myParamWithAnEvenLongerName ) { ... } // Right def myMethod4 ( MyClassWithAVeryLongName myParamWithAVeryLongName , MyClassWithAnEvenLongerName myParamWithAnEvenLongerName ) { ... } } Binary Operators When breaking long statements, binary operators should remain on the previous line : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Example { def myMethod ( String param1 , int param2 ) { // Wrong println ( \"This statement will print a very long string that \" + \"exceeds the maximum recommended width of a column\" ) // Right println ( \"This statement will print a very long string that \" + \"exceeds the maximum recommended width of a column\" ) // Wrong if ( param1 != \"strThatUnfortunatelyExceedsTheMaximumColumnWidth\" && param2 > 0 ) ... // Right if ( param1 != \"strThatUnfortunatelyExceedsTheMaximumColumnWidth\" && param2 > 0 ) ... } } In case there are more than two binary operators in an expression that exceeds 100 columns, each operand should go in its own line , possibly followed by the binding operator: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Example { def myMethod4 ( String param1 , int param2 , boolean param3 ) { // Wrong if ( param1 != \"strThatUnfortunatelyExceedsTheMaximumColumnWidth\" && param2 > 0 || ! param3 ) ... // Right if ( param1 != \"strThatUnfortunatelyExceedsTheMaximumColumnWidth\" && param2 > 0 || ! param3 ) ... } } Assignments and Member Accesses For assignments and members accesses, the respective operators should go into the same line as the assigned value or the accessed member , respectively: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Example { def myMethod4 ( String param1 , int param2 , boolean param3 ) { // Wrong val myVar = \"strThatUnfortunatelyExceedsTheMaximumColumnWidth\" // Right val myVar = \"strThatUnfortunatelyExceedsTheMaximumColumnWidth\" // Wrong myObject . longMethodNameThatUnfortunatelyExceedsTheMaximumColumnWidth () . doSomeMoreStuff () // Right myObject . longMethodNameThatUnfortunatelyExceedsTheMaximumColumnWidth () . doSomeMoreStuff () } } Naming Except for Python scripts, where we adhere to the style suggested by PEP 8 , and Bash scripts, where we follow the Linux Kernel style of Naming , the following naming rules shall be applied to all LEMMA module implementations. Basic Formatting Names should be kept readable but also as short as possible. Suppose a method that allows the concatentation of an arbitrary number of strings into a single file path string. A proper name for this method would be joinPathSegments rather than join (too generic), jps (incomprehensible), or joinPathSegmentsFromAnArbitraryNumberOfStrings (too long without a reason, i.e., the FromAnArbitraryNumberOfStrings suffix does not add any significant information to the joinPathSegments name prefix). Modules/Packages Names of modules/packages shall follow the all_lowercase_with_underscore style. For example, a valid package name is de.fhdo.lemma.model_processing.code_generation.container_base , and not de.fhdo.lemma.model_processing.code_generation.containerBase or (even worse) de.fhdo.lemma.model_processing.code_generation.ContainerBase . Classes Names of classes shall follow the UpperCamelCase style. For the conversion of English phrases into upper camel-case, we follow the conversion scheme defined in Google's Java Style Guide : Convert the phrase to plain ASCII and remove any apostrophes. For example, \"M\u00fcller's algorithm\" becomes \"Muellers algorithm\". Divide this result into words, splitting on spaces and any remaining punctuation (typically hyphens). If any word already has a conventional camel-case appearance in common usage, split this into its constituent parts (e.g., \"AdWords\" becomes \"ad words\"). Note that a word such as \"iOS\" is not really in camel-case per se. Now lowercase everything (including acronyms), then uppercase only the first character of each word, to yield UpperCamelCase . Finally, join all the words into a single identifier. Examples: Prose form Right Wrong \"XML HTTP request\" XmlHttpRequest XMLHTTPRequest \"YouTube importer\" YouTubeImporter YoutubeImporter Variables and Functions/Methods Names of variables and functions/methods shall follow the lowerCamelCase style. For the conversion of English phrases into lower camel-case, we follow the conversion scheme defined in Google's Java Style Guide : Convert the phrase to plain ASCII and remove any apostrophes. For example, \"M\u00fcller's algorithm\" becomes \"Muellers algorithm\". Divide this result into words, splitting on spaces and any remaining punctuation (typically hyphens). If any word already has a conventional camel-case appearance in common usage, split this into its constituent parts (e.g., \"AdWords\" becomes \"ad words\"). Note that a word such as \"iOS\" is not really in camel-case per se. Now lowercase everything (including acronyms), then uppercase only the first character of each word except the first, to yield lowerCamelCase . Finally, join all the words into a single identifier. Examples: Prose form Right Wrong \"new customer ID\" newCustomerId newCustomerID \"inner stopwatch\" innerStopwatch innerStopWatch \"supports IPv6 on iOS?\" supportsIpv6OnIos supportsIPv6OnIOS As opposed to hungarian notation, we do not encode the type of a variable in its name : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Example { // Wrong int nAge // Worse MySecondExampleClass objSecondExample // Evil MySecondExampleClass mySecondExampleClassInstance // Right int age // Right MySecondExampleClass secondExample } Constants Constants are an exception to the lowerCamelCase rule for variables. Their names shall follow the ALL_UPPERCASE_WITH_UNDERSCORE style: 1 2 3 4 5 6 7 class Example { // Wrong static val myConstant = \"foo\" // Right static val MY_CONSTANT = \"foo\" } Avoidance of Offensive Terms Avoid introducing the terms master and slave as well as blacklist and whitelist . We consider them offensive. Instead, you can use these alternatives: for master / slave : primary , main / secondary , replica , subordinate initiator , requester / target , responder controller , host / device , worker , proxy leader / follower director / performer for blacklist / whitelist : denylist / allowlist blocklist / passlist Source File Language, Encoding, and Ordering Language The language for all source file contents is American English . An exception to this rule might be localized status messages or texts in user dialogs. However, American English is also the first language to consider for messages or dialog texts. Encoding Source file encoding is UTF-8 . Ordering The ordering of source file contents should be logical (and, in particular, not chronological or based on visibility). For instance, variables should be defined closely to their first usage and the order of methods should reflect their call chains. Consider the following example of a badly ordered Xtend class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Example { def myPublicMethod ( String param1 , int param2 ) { myPrivateMethod ( param1 , param2 ) } def myOtherPublicMethod ( boolean param2 ) { myOtherPrivateMethod () } private def myPrivateMethod ( String param1 , int param2 ) { val exactlyOneParamIsEmpty = param1 . nullOrEmpty && param2 > 0 || ! param1 . nullOrEmpty && param2 <= 0 // Lots of statements before first usage of exactlyOneParamIsEmpty ... if ( exactlyOneParamIsEmpty ) ... } private def myOtherPrivateMethod () { ... } } The contents of this class should instead be ordered as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Example { def myPublicMethod ( String param1 , int param2 ) { myPrivateMethod ( param1 , param2 ) } // Method definition now follows immediately after the method that // invokes it first private def myPrivateMethod ( String param1 , int param2 ) { // Lots of statements before first usage of exactlyOneParamIsEmpty ... // exactlyOneParamIsEmpty is now defined immediately before its first // usage val exactlyOneParamIsEmpty = param1 . nullOrEmpty && param2 > 0 || ! param1 . nullOrEmpty && param2 <= 0 if ( exactlyOneParamIsEmpty ) ... } def myOtherPublicMethod ( boolean param2 ) { myOtherPrivateMethod () } // Method definition now follows immediately after the method that // invokes it first private def myOtherPrivateMethod () { ... } } Imports are ordered as follows: All non-static imports in a single block. All static imports in a single block. Comments Basics Try not to over-comment your code and aim to write your code in a way that it is understandable without comments. In any case, do not use comments to explain HOW your code works but WHAT it does : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Example { def myMethod ( String param1 , int param2 ) { // Wrong // Initialize the max looping index val maxIndex = list . size () // Loop from zero to max looping index for ( i : 0 .. < maxIndex ) { // Do something on the list using index i ... } // Better /* Loop over the list to... */ val maxIndex = list . size () for ( i : 0 .. < maxIndex ) { ... } // Even more better (no comments, because it is obvious what happens // to the looped list) val maxIndex = list . size () for ( i : 0 .. < maxIndex ) { ... } } } Proper names in comments, e.g., \"Eclipse\", \"IFile\", \"LEMMA\", and \"Spring Boot\", are capitalized as intended by the inventors/providers of the mentioned frameworks/products/technologies/entities. In addition, we never (ever) hyphenate within comments . JVM Specifics Try also to avoid comments in method or function bodies to the maximum extent possible. However, we almost always place comments before the signature of a function/method and its defining class . Exceptions to this rule are trivial functions/methods like getters or setters, and trivial classes like POJOs. For functions/methods and classes in JVM languages use the following comment style: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Class that exemplifies LEMMA's style of source code comments. This * sentence of the comment even exceeds the first line of the comment for the * sake of illustrating LEMMA's comment style. */ class Example { /** * Public method of the example class. It does some very interesting * stuff with its two parameters. */ def myMethod ( String param1 , int param2 ) { ... } /** * In case the comment consists of only one sentence, you may omit the * trailing period */ private def myMethod2 ( String param1 , int param2 , MyClassWithAVeryLongName param3 , MyClassWithAnEvenLongerName param4 ) { ... } def getAnAttribute () { return anAttribute } } In case you developed a JVM function/method that consists of several logical steps, whose decomposition into other methods does not make sense, you may use multi-line comments to separate coherent steps and single-line comments within a compound of coherent steps. However, this form of commenting (and organizing functions/methods) should be avoided at all sane costs. Python Specifics For Python scripts, we use the comment style suggested by PEP 8 . ATL Specifics For ATL modules, use --- to comment global variables, rules, or helpers, and -- to comment everything else. Programming Practices Always Use @Override While languages like Kotlin and Xtend require you to use the override keyword when overriding inherited methods, Java does not enforce the usage of the @Override annotation. However, you should add @Override to Java methods whenever they override an inherited method . Access Static Members By Their Defining Classes When accessing static members in a qualified manner, use the defining class's name and not an instance of the defining class: 1 2 3 4 5 6 7 8 9 10 Example example = ... // Wrong example . myStaticMethod () // Also wrong getExampleInstance (). myStaticMethod () // Right Example . myStaticMethod () Do Not Reinvent Utility Functions LEMMA comes with an extensive set of utility functions, e.g., in the LemmaUtils class or Xcore metamodel specifications. Please use such functions rather than explicitly coding some variant of them yourself. Lowest Applicable Visibility In languages that support a notion of visibility for module members, we always employ the lowest level of visibility applicable to a member concerning its intended usage. For Java, for example, apply visibility in the following order (i.e., make classes package-private whenever possible and make their members private whenever possible): private (class members only) no modifier, i.e., package-private visibility protected (class members only) public Commits Commit Cohesion Your commits should always reflect coherent changes to LEMMA's codebase. For example, you should not add two different major functionalities in the same commit. However, a commit must always result in a functioning (compileable and buildable) main branch and not break any tests. In you own feature branches, your commits might introduce compile and/or build failures, which is totally fine as long as the commits are isolated from main . However, before you open a pull request for main , you must ensure that your commits will result in a functioning main branch. Merges of commits into main are expected to be fast-forward (in fact, they are done using git's --ff-only option for the merge sub-command ). Consequently, you should rebase your feature branch onto main before creating a pull request on GitHub. In case your commit results in generated code (as is the case, e.g., with Xtend), only commit generated code that actually results from the changes within source code files relevant to the commit . For instance, in case Eclipse performs a workspace re-build and generates Java code from Xtend files all over the place, your commit should only comprise those generated Java files that immediately result from changes to Xtend files in the LEMMA module that is actually affected by your commit. In addition, a commit should be revertable without breaking existing code whenever possible. Sometimes this approach might, however, not be achievable in a sane manner. We accept such cases then. Still, you should try to create revertable commits as much as possible. Commit Messages Commit messages in LEMMA consist of three parts : The name of the LEMMA module that is affected by the commit in American English. A colon that separates the module name from the commit description. The commit description in American English. LEMMA Module Names Currently, we do not have a standardized collection of LEMMA module names. However, you might execute the following Bash command on LEMMA's main branch in a cloned copy of LEMMA's repository to get a glimpse of common module names: 1 git log --oneline | cut -d \" \" -f2- | cut -d: -f1 | sort -u This command will result in a list comprising entries like 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... Data DSL DDD Genlet Documentation ... Eclipse UI Examples ... Intermediate metamodels Intermediate Service Model ... Model Processing Framework ... OCL plugin Operation DSL ... Spring Cloud Genlet Static Analyzer Static Analyzer Library ... which are all good candidates for module names. Please capitalize nouns in module names, e.g., \"Intermediate Metamodels\" is preferred over \"Intermediate metamodels\". In case your commit concerns more than one LEMMA module , you might separate the module names with commas and an \"and\", e.g., 1 2 3 4 ... Service DSL and Technology DSL Service DSL, Mapping DSL, and Operation DSL ... If your commit does not concern a LEMMA module or all LEMMA modules , omit module names entirely, e.g., 1 2 3 4 5 6 Lift version identifiers to release 0.8.5 ... Update .gitignore Update license Update README ... Colon Separator In case your commit affects one or more LEMMA modules , place a colon immediately after the module names. A space after the colon shall then separate the colon from the commit description: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Wrong (space after module name) Xtext Editor Plugin : Set module encoding to UTF-8 # Wrong (missing module name) Set module encoding to UTF-8 # Wrong (missing space after colon) Xtext Editor Plugin:Set module encoding to UTF-8 # Wrong (space after module name and missing space after colon) Xtext Editor Plugin :Set module encoding to UTF-8 # Right Xtext Editor Plugin: Set module encoding to UTF-8 Commit Description Commit descriptions shall start with a verb in active form for the first person (I/we). Moreover, the description shall consist of at least one sentence in American English. The verb at the beginning of a commit message starts with an uppercase letter. All other words of the commit message follow regular capitalization in American English. In particular, proper names are capitalized the same way as within comments : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Wrong (verb at description beginning is not in first person; should be # \"Set\" instead of \"Sets\") Xtext Editor Plugin: Sets module encoding to UTF-8 # Wrong (verb at description beginning is not capitalized) Xtext Editor Plugin: set module encoding to UTF-8 # Wrong (\"eclipse\" and \"eclipse equinox\" are proper names and should be # capitalized as \"Eclipse\" and \"Eclipse Equinox\") Update eclipse equinox version to 3 .14.100 # Wrong (Java is a proper name) Java Base Generator: Streamline java-based Genlet implementation # Wrong (uncommon American English: first word of second sentence is # not capitalized and sentence does not end with a period) Some LEMMA Module: Add the foo to the bar. fixes baz due to use of ding # Right Xtext Editor Plugin: Set module encoding to UTF-8 Update Eclipse Equinox version to 3 .14.100 Java Base Generator: Streamline Java-based Genlet implementation # Right but not preferred Some LEMMA Module: Add the foo to the bar. Fixes baz due to use of ding. While the latter message is basically correct, we nowadays prefer \"long git commit messages\" for commit descriptions that consist of more than one sentence . The template for a \"long git commit message\" is as follows: 1 2 3 [LEMMA_MODULE_NAMES]: [COMMIT_SUMMARY_WITHOUT_TRAILING_PERIOD] [LONG_MESSAGE] The [LONG_MESSAGE] template variable is a block of text with a maximum width of 100 columns, in which each line is indented by 4 spaces . Consequently, the latter example commit message above should be reformatted as follows: 1 2 3 Some LEMMA Module: Add the foo to the bar This fixes baz due to use of ding. A real-world example of a \"long git commit message\" can be found in LEMMA commit 9237b941 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Live Validation Framework: Refactor towards loosely coupled Java implementation We split the current implementation of the Live Validation Framework into the following modules: - util: Shared utilities. - model: Shared classes for Live Validation issue representation. - protocol: LSP extensions specific to LEMMA Live Validation. - client: Framework components for Live Validation client implementation. - server: Standalone executable implementation of Live Validation server. The refactoring of the framework towards a Java implemention facilitates the usage of the Live Validation Framework by both the Eclipse editor plugin (Xtend-based) and LEMMA's Model Processing Framework (Kotlin-based). In particular, we split the server-related from the client-related parts and do no longer require the installation of Kotlin-specific artifacts via a dedicated Eclipse updatesite. To gain further insights on short LEMMA commit descriptions, you may execute the following Bash command on LEMMA's main branch in a cloned copy of LEMMA's repository: 1 2 git log --oneline | cut -d \" \" -f2- | cut -d: -f2- | \\ sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sort -u","title":"Coding Style"},{"location":"developer-guide/coding-style/#coding-style","text":"This page describes the preferred coding style for LEMMA. To quote Linus Torvalds in the Linux Kernel Documentation : Quote Coding style is very personal, and I won't force my views on anybody, but this is what goes for anything that I have to be able to maintain, and I'd prefer it for most other things too. Please at least consider the points made here. To rephrase: We greatly welcome all kinds of contributions to LEMMA and its various modules, and hereby encourage all contributors to employ the coding style outlined as follows, even if it contradicts your personal style of programming. That is, because we perceive consistency in source code appearance crucial to ensure a codebase's readability and comprehensibility. Thank you!","title":"Coding Style"},{"location":"developer-guide/coding-style/#scope","text":"This style guide concerns all programming languages used in LEMMA modules besides Python, for which we adhere to PEP 8 ; and Bash scripts (at least partially and as described below).","title":"Scope"},{"location":"developer-guide/coding-style/#indentation","text":"Except for ATL modules (files with the .atl extension), we use spaces instead of tabs to indent LEMMA's source code. An indentation level is introduced by 4 spaces . In ATL modules, we use tabs (instead of spaces) with column width 4 for indentation, which is mainly due to historical reasons. Except for package/module definitions and import statements, a line of code should not exceed 100 columns . Moreover, the maximum count of indentation levels should be 3 . If you require more indentation levels, please refactor your code by introducing, e.g., additional data structures or helper methods. For instance, Xtend code like 1 2 3 4 5 6 7 8 9 10 11 12 class Example { def myMethod ( String param1 , int param2 ) { if ( param1 == \"someString\" ) if ( param2 > 0 ) { ... } else if ( param2 == 0 ) { ... } else { ... } } } should be refactored into something like 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Example { def myMethod ( String param1 , int param2 ) { if ( param1 == \"someString\" ) handleSomeString ( param2 ) } private def handleSomeString ( int param ) { if ( param > 0 ) { ... } else if ( param == 0 ) { ... } else { ... } } } switch statements are an exception to the rule of the maximum indentation level 3. For switch statements we accept a maximum indentation level of 4. Thus, it is perfectly fine to refactor the first Xtend listing above into something like 1 2 3 4 5 6 7 8 9 10 11 12 class Example { def myMethod ( String param1 , int param2 ) { switch ( param1 ) { case \"someString\" : handleSomeString ( param2 ) case \"someOtherString\" : ... default : ... } } } Each line of code should contain exactly one statement , e.g., 1 2 3 4 5 6 7 8 9 10 class Example { def myMethod ( String param1 , int param2 ) { // Wrong myOtherMethod () myOtherOtherMethod () // Right myOtherMethod () myOtherOtherMethod () } }","title":"Indentation"},{"location":"developer-guide/coding-style/#braces","text":"As in K&R style , opening curly braces should be put last on the same line as the statement to which they belong. Divide the statement and the opening curly brace by a single space . Conversely, closing curly braces should be put on their own line : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Example { // Wrong def myFirstMethod () { ... } // Right (curly bracing on class/method level also follows K&R style for // statements) def myMethod ( String param1 , int param2 ) { // Wrong if ( param1 ) { doSomething1 doSomething2 } // Also wrong (no space before opening curly brace) if ( param1 ){ doSomething1 doSomething2 } // Right if ( param1 ) { doSomething1 doSomething2 } } }","title":"Braces"},{"location":"developer-guide/coding-style/#spaces-and-newlines","text":"","title":"Spaces and Newlines"},{"location":"developer-guide/coding-style/#spaces","text":"There should be one space after keywords like if , case , do , for , and while ; on each side of binary and ternary operators like = , + , - , < , > , * , / , % , | , & , ^ , <= , >= , == , != , ?: ; after statements that are followed by a block (cf. the Braces example listing). There should be no space after keywords like catch and switch ; before parameter lists of methods/functions; after unary operators like ! ; before postfix increment and decrement unary operators, i.e., ++ and -- ; after prefix increment and decrement unary operators, i.e., ++ and -- ; around operators that access members of classes/data structures, e.g., . or -> . Remove spaces that do not comply with the above rules whenever possible, e.g., in empty lines, at the end of a line, at the end of a file. We never require horizontal alignment as the resulting maintainability effort does not justify the possible (and usually small) gain in readability: 1 2 3 4 5 6 7 8 9 class Example { // Wrong static val MY_FIRST_CONSTANT = 1 // Integer static val MY_SECOND_CONSTANT_IS_A_STRING = \"foo\" // String, of course // Right static val MY_FIRST_CONSTANT = 1 // Integer static val MY_SECOND_CONSTANT_IS_A_STRING = \"foo\" // String, of course }","title":"Spaces"},{"location":"developer-guide/coding-style/#newlines","text":"Add one empty line between the definition of semantically or syntactically coherent code blocks so that they are recognizable as such. For example, there should be one empty line between a block of constants and the following block of attributes in a class (semantic cohesion). Similarly, there should be one empty line between the end of a method body and the start of the next method's signature (syntactic cohesion). We do not place a newline at the end of a file .","title":"Newlines"},{"location":"developer-guide/coding-style/#optional-syntax-constructs","text":"Omit optional constructs as permitted by the respective programming language as much as possible to decrease the amount of characters one has to read to understand your code. For example, leave out round braces for functions in Xtend's standard library and semicolons when they are not necessary: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def myMethod ( String param1 , int param2 ) { // Wrong (well-known built-in function, omit round braces) val myMap1 = newHashMap () // Right val myMap2 = newHashMap // Wrong (well-known built-in function, omit round braces; also omit // optional semicolon) val myMap3 = newHashMap (); // Also wrong (omit optional semicolon) val myMap4 = newHashMap ; // Right val myMap5 = newHashMap // Wrong if ( param1 == \"someString\" ) { // Wrong doSomething1 } else { doSomething2 () andSomethingElse () } // Right (omit braces for first if-branch) if ( param1 == \"someString\" ) // Right (custom method, don't omit braces to make clear that this is // a custom method) doSomething1 () else { doSomething2 () andSomethingElse () } } An exception to the rule of omitting unnecessary constructs are code blocks that are empty by intent, e.g., empty catch -blocks or constructor bodies. To communicate the intent of leaving such blocks empty, you should add (i) an explicit comment describing why the respective code block is empty (for catch -blocks and non-trivial constructors); or (ii) an explicit \"NOOP\" line comment (for trivial constructors): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Example2 extends Example { // Right private new () { // NOOP } // Also right new ( String param ) { // Empty constructor body because we don't care about \"param\" // whatsoever } private def myMethod ( String s ) { ... try { return scanner . nextDouble () } catch ( InputMismatchException ex ) { // Wrong: No explanation why this exception is not handled // NOOP } catch ( NoSuchElementException ex ) { // Right // We don't handle this exception due to the following sensible // reasoning: // ... } } }","title":"Optional Syntax Constructs"},{"location":"developer-guide/coding-style/#breaking-long-lines","text":"","title":"Breaking Long Lines"},{"location":"developer-guide/coding-style/#basic-formatting","text":"Lines wider than 100 columns should be broken into sensible chunks , unless exceeding 100 columns significantly increases readability and does not hide information. Descendants should follow LEMMA's coding style w.r.t. indentation : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Example { def myMethod ( String param1 , int param2 ) { // Wrong: No indentation of descendant param2 val myVariableWithAVeryLongName = myFunctionWithAVeryLongName ( param1 , param2 ) // Wrong: Indentation exceeds 4 spaces for descendant param2 val myVariableWithAVeryLongName = myFunctionWithAVeryLongName ( param1 , param2 ) // Right val myVariableWithAVeryLongName = myFunctionWithAVeryLongName ( param1 , param2 ) } }","title":"Basic Formatting"},{"location":"developer-guide/coding-style/#functions-with-long-parameter-lists","text":"Functions/methods, whose parameter lists exceed 100 columns , and that have more than two parameters; and breaking parameters into descendant lines result in at least one descendant line comprising only one parameter, which is not the last one should be formatted so that each parameter definition is in its own line . In addition, the closing round brace of the parameter list and the opening curly brace of the function/method body should go on their own line on the same indentation level as the start of the function/method definition: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Example { // Right (single parameter is the last one) def myMethod2 ( String param1 , int param2 , MyClassWithAVeryLongName param3 , MyClassWithAnEvenLongerName param4 ) { ... } // Wrong (param4 stands on its own line and is not the last parameter) def myMethod3 ( String param1 , int param2 , MyClassWithAVeryLongName param3 , MyClassWithAnEvenLongerNameThatMakesParam4StandAloneInBetween param4 , int param5 , boolean param6 ) { ... } // Right (all parameters on their own line) def myMethod3 ( String param1 , int param2 , MyClassWithAVeryLongName param3 , MyClassWithAnEvenLongerNameThatMakesParam4StandAloneInBetween param4 , int param5 , boolean param6 ) { ... } // Wrong (there are only two parameters and both would fit on their own // line) def myMethod4 ( MyClassWithAVeryLongName myParamWithAVeryLongName , MyClassWithAnEvenLongerName myParamWithAnEvenLongerName ) { ... } // Right def myMethod4 ( MyClassWithAVeryLongName myParamWithAVeryLongName , MyClassWithAnEvenLongerName myParamWithAnEvenLongerName ) { ... } }","title":"Functions With Long Parameter Lists"},{"location":"developer-guide/coding-style/#binary-operators","text":"When breaking long statements, binary operators should remain on the previous line : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Example { def myMethod ( String param1 , int param2 ) { // Wrong println ( \"This statement will print a very long string that \" + \"exceeds the maximum recommended width of a column\" ) // Right println ( \"This statement will print a very long string that \" + \"exceeds the maximum recommended width of a column\" ) // Wrong if ( param1 != \"strThatUnfortunatelyExceedsTheMaximumColumnWidth\" && param2 > 0 ) ... // Right if ( param1 != \"strThatUnfortunatelyExceedsTheMaximumColumnWidth\" && param2 > 0 ) ... } } In case there are more than two binary operators in an expression that exceeds 100 columns, each operand should go in its own line , possibly followed by the binding operator: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Example { def myMethod4 ( String param1 , int param2 , boolean param3 ) { // Wrong if ( param1 != \"strThatUnfortunatelyExceedsTheMaximumColumnWidth\" && param2 > 0 || ! param3 ) ... // Right if ( param1 != \"strThatUnfortunatelyExceedsTheMaximumColumnWidth\" && param2 > 0 || ! param3 ) ... } }","title":"Binary Operators"},{"location":"developer-guide/coding-style/#assignments-and-member-accesses","text":"For assignments and members accesses, the respective operators should go into the same line as the assigned value or the accessed member , respectively: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Example { def myMethod4 ( String param1 , int param2 , boolean param3 ) { // Wrong val myVar = \"strThatUnfortunatelyExceedsTheMaximumColumnWidth\" // Right val myVar = \"strThatUnfortunatelyExceedsTheMaximumColumnWidth\" // Wrong myObject . longMethodNameThatUnfortunatelyExceedsTheMaximumColumnWidth () . doSomeMoreStuff () // Right myObject . longMethodNameThatUnfortunatelyExceedsTheMaximumColumnWidth () . doSomeMoreStuff () } }","title":"Assignments and Member Accesses"},{"location":"developer-guide/coding-style/#naming","text":"Except for Python scripts, where we adhere to the style suggested by PEP 8 , and Bash scripts, where we follow the Linux Kernel style of Naming , the following naming rules shall be applied to all LEMMA module implementations.","title":"Naming"},{"location":"developer-guide/coding-style/#basic-formatting_1","text":"Names should be kept readable but also as short as possible. Suppose a method that allows the concatentation of an arbitrary number of strings into a single file path string. A proper name for this method would be joinPathSegments rather than join (too generic), jps (incomprehensible), or joinPathSegmentsFromAnArbitraryNumberOfStrings (too long without a reason, i.e., the FromAnArbitraryNumberOfStrings suffix does not add any significant information to the joinPathSegments name prefix).","title":"Basic Formatting"},{"location":"developer-guide/coding-style/#modulespackages","text":"Names of modules/packages shall follow the all_lowercase_with_underscore style. For example, a valid package name is de.fhdo.lemma.model_processing.code_generation.container_base , and not de.fhdo.lemma.model_processing.code_generation.containerBase or (even worse) de.fhdo.lemma.model_processing.code_generation.ContainerBase .","title":"Modules/Packages"},{"location":"developer-guide/coding-style/#classes","text":"Names of classes shall follow the UpperCamelCase style. For the conversion of English phrases into upper camel-case, we follow the conversion scheme defined in Google's Java Style Guide : Convert the phrase to plain ASCII and remove any apostrophes. For example, \"M\u00fcller's algorithm\" becomes \"Muellers algorithm\". Divide this result into words, splitting on spaces and any remaining punctuation (typically hyphens). If any word already has a conventional camel-case appearance in common usage, split this into its constituent parts (e.g., \"AdWords\" becomes \"ad words\"). Note that a word such as \"iOS\" is not really in camel-case per se. Now lowercase everything (including acronyms), then uppercase only the first character of each word, to yield UpperCamelCase . Finally, join all the words into a single identifier. Examples: Prose form Right Wrong \"XML HTTP request\" XmlHttpRequest XMLHTTPRequest \"YouTube importer\" YouTubeImporter YoutubeImporter","title":"Classes"},{"location":"developer-guide/coding-style/#variables-and-functionsmethods","text":"Names of variables and functions/methods shall follow the lowerCamelCase style. For the conversion of English phrases into lower camel-case, we follow the conversion scheme defined in Google's Java Style Guide : Convert the phrase to plain ASCII and remove any apostrophes. For example, \"M\u00fcller's algorithm\" becomes \"Muellers algorithm\". Divide this result into words, splitting on spaces and any remaining punctuation (typically hyphens). If any word already has a conventional camel-case appearance in common usage, split this into its constituent parts (e.g., \"AdWords\" becomes \"ad words\"). Note that a word such as \"iOS\" is not really in camel-case per se. Now lowercase everything (including acronyms), then uppercase only the first character of each word except the first, to yield lowerCamelCase . Finally, join all the words into a single identifier. Examples: Prose form Right Wrong \"new customer ID\" newCustomerId newCustomerID \"inner stopwatch\" innerStopwatch innerStopWatch \"supports IPv6 on iOS?\" supportsIpv6OnIos supportsIPv6OnIOS As opposed to hungarian notation, we do not encode the type of a variable in its name : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Example { // Wrong int nAge // Worse MySecondExampleClass objSecondExample // Evil MySecondExampleClass mySecondExampleClassInstance // Right int age // Right MySecondExampleClass secondExample }","title":"Variables and Functions/Methods"},{"location":"developer-guide/coding-style/#constants","text":"Constants are an exception to the lowerCamelCase rule for variables. Their names shall follow the ALL_UPPERCASE_WITH_UNDERSCORE style: 1 2 3 4 5 6 7 class Example { // Wrong static val myConstant = \"foo\" // Right static val MY_CONSTANT = \"foo\" }","title":"Constants"},{"location":"developer-guide/coding-style/#avoidance-of-offensive-terms","text":"Avoid introducing the terms master and slave as well as blacklist and whitelist . We consider them offensive. Instead, you can use these alternatives: for master / slave : primary , main / secondary , replica , subordinate initiator , requester / target , responder controller , host / device , worker , proxy leader / follower director / performer for blacklist / whitelist : denylist / allowlist blocklist / passlist","title":"Avoidance of Offensive Terms"},{"location":"developer-guide/coding-style/#source-file-language-encoding-and-ordering","text":"","title":"Source File Language, Encoding, and Ordering"},{"location":"developer-guide/coding-style/#language","text":"The language for all source file contents is American English . An exception to this rule might be localized status messages or texts in user dialogs. However, American English is also the first language to consider for messages or dialog texts.","title":"Language"},{"location":"developer-guide/coding-style/#encoding","text":"Source file encoding is UTF-8 .","title":"Encoding"},{"location":"developer-guide/coding-style/#ordering","text":"The ordering of source file contents should be logical (and, in particular, not chronological or based on visibility). For instance, variables should be defined closely to their first usage and the order of methods should reflect their call chains. Consider the following example of a badly ordered Xtend class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Example { def myPublicMethod ( String param1 , int param2 ) { myPrivateMethod ( param1 , param2 ) } def myOtherPublicMethod ( boolean param2 ) { myOtherPrivateMethod () } private def myPrivateMethod ( String param1 , int param2 ) { val exactlyOneParamIsEmpty = param1 . nullOrEmpty && param2 > 0 || ! param1 . nullOrEmpty && param2 <= 0 // Lots of statements before first usage of exactlyOneParamIsEmpty ... if ( exactlyOneParamIsEmpty ) ... } private def myOtherPrivateMethod () { ... } } The contents of this class should instead be ordered as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Example { def myPublicMethod ( String param1 , int param2 ) { myPrivateMethod ( param1 , param2 ) } // Method definition now follows immediately after the method that // invokes it first private def myPrivateMethod ( String param1 , int param2 ) { // Lots of statements before first usage of exactlyOneParamIsEmpty ... // exactlyOneParamIsEmpty is now defined immediately before its first // usage val exactlyOneParamIsEmpty = param1 . nullOrEmpty && param2 > 0 || ! param1 . nullOrEmpty && param2 <= 0 if ( exactlyOneParamIsEmpty ) ... } def myOtherPublicMethod ( boolean param2 ) { myOtherPrivateMethod () } // Method definition now follows immediately after the method that // invokes it first private def myOtherPrivateMethod () { ... } } Imports are ordered as follows: All non-static imports in a single block. All static imports in a single block.","title":"Ordering"},{"location":"developer-guide/coding-style/#comments","text":"","title":"Comments"},{"location":"developer-guide/coding-style/#basics","text":"Try not to over-comment your code and aim to write your code in a way that it is understandable without comments. In any case, do not use comments to explain HOW your code works but WHAT it does : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Example { def myMethod ( String param1 , int param2 ) { // Wrong // Initialize the max looping index val maxIndex = list . size () // Loop from zero to max looping index for ( i : 0 .. < maxIndex ) { // Do something on the list using index i ... } // Better /* Loop over the list to... */ val maxIndex = list . size () for ( i : 0 .. < maxIndex ) { ... } // Even more better (no comments, because it is obvious what happens // to the looped list) val maxIndex = list . size () for ( i : 0 .. < maxIndex ) { ... } } } Proper names in comments, e.g., \"Eclipse\", \"IFile\", \"LEMMA\", and \"Spring Boot\", are capitalized as intended by the inventors/providers of the mentioned frameworks/products/technologies/entities. In addition, we never (ever) hyphenate within comments .","title":"Basics"},{"location":"developer-guide/coding-style/#jvm-specifics","text":"Try also to avoid comments in method or function bodies to the maximum extent possible. However, we almost always place comments before the signature of a function/method and its defining class . Exceptions to this rule are trivial functions/methods like getters or setters, and trivial classes like POJOs. For functions/methods and classes in JVM languages use the following comment style: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Class that exemplifies LEMMA's style of source code comments. This * sentence of the comment even exceeds the first line of the comment for the * sake of illustrating LEMMA's comment style. */ class Example { /** * Public method of the example class. It does some very interesting * stuff with its two parameters. */ def myMethod ( String param1 , int param2 ) { ... } /** * In case the comment consists of only one sentence, you may omit the * trailing period */ private def myMethod2 ( String param1 , int param2 , MyClassWithAVeryLongName param3 , MyClassWithAnEvenLongerName param4 ) { ... } def getAnAttribute () { return anAttribute } } In case you developed a JVM function/method that consists of several logical steps, whose decomposition into other methods does not make sense, you may use multi-line comments to separate coherent steps and single-line comments within a compound of coherent steps. However, this form of commenting (and organizing functions/methods) should be avoided at all sane costs.","title":"JVM Specifics"},{"location":"developer-guide/coding-style/#python-specifics","text":"For Python scripts, we use the comment style suggested by PEP 8 .","title":"Python Specifics"},{"location":"developer-guide/coding-style/#atl-specifics","text":"For ATL modules, use --- to comment global variables, rules, or helpers, and -- to comment everything else.","title":"ATL Specifics"},{"location":"developer-guide/coding-style/#programming-practices","text":"","title":"Programming Practices"},{"location":"developer-guide/coding-style/#always-use-override","text":"While languages like Kotlin and Xtend require you to use the override keyword when overriding inherited methods, Java does not enforce the usage of the @Override annotation. However, you should add @Override to Java methods whenever they override an inherited method .","title":"Always Use @Override"},{"location":"developer-guide/coding-style/#access-static-members-by-their-defining-classes","text":"When accessing static members in a qualified manner, use the defining class's name and not an instance of the defining class: 1 2 3 4 5 6 7 8 9 10 Example example = ... // Wrong example . myStaticMethod () // Also wrong getExampleInstance (). myStaticMethod () // Right Example . myStaticMethod ()","title":"Access Static Members By Their Defining Classes"},{"location":"developer-guide/coding-style/#do-not-reinvent-utility-functions","text":"LEMMA comes with an extensive set of utility functions, e.g., in the LemmaUtils class or Xcore metamodel specifications. Please use such functions rather than explicitly coding some variant of them yourself.","title":"Do Not Reinvent Utility Functions"},{"location":"developer-guide/coding-style/#lowest-applicable-visibility","text":"In languages that support a notion of visibility for module members, we always employ the lowest level of visibility applicable to a member concerning its intended usage. For Java, for example, apply visibility in the following order (i.e., make classes package-private whenever possible and make their members private whenever possible): private (class members only) no modifier, i.e., package-private visibility protected (class members only) public","title":"Lowest Applicable Visibility"},{"location":"developer-guide/coding-style/#commits","text":"","title":"Commits"},{"location":"developer-guide/coding-style/#commit-cohesion","text":"Your commits should always reflect coherent changes to LEMMA's codebase. For example, you should not add two different major functionalities in the same commit. However, a commit must always result in a functioning (compileable and buildable) main branch and not break any tests. In you own feature branches, your commits might introduce compile and/or build failures, which is totally fine as long as the commits are isolated from main . However, before you open a pull request for main , you must ensure that your commits will result in a functioning main branch. Merges of commits into main are expected to be fast-forward (in fact, they are done using git's --ff-only option for the merge sub-command ). Consequently, you should rebase your feature branch onto main before creating a pull request on GitHub. In case your commit results in generated code (as is the case, e.g., with Xtend), only commit generated code that actually results from the changes within source code files relevant to the commit . For instance, in case Eclipse performs a workspace re-build and generates Java code from Xtend files all over the place, your commit should only comprise those generated Java files that immediately result from changes to Xtend files in the LEMMA module that is actually affected by your commit. In addition, a commit should be revertable without breaking existing code whenever possible. Sometimes this approach might, however, not be achievable in a sane manner. We accept such cases then. Still, you should try to create revertable commits as much as possible.","title":"Commit Cohesion"},{"location":"developer-guide/coding-style/#commit-messages","text":"Commit messages in LEMMA consist of three parts : The name of the LEMMA module that is affected by the commit in American English. A colon that separates the module name from the commit description. The commit description in American English.","title":"Commit Messages"},{"location":"developer-guide/coding-style/#lemma-module-names","text":"Currently, we do not have a standardized collection of LEMMA module names. However, you might execute the following Bash command on LEMMA's main branch in a cloned copy of LEMMA's repository to get a glimpse of common module names: 1 git log --oneline | cut -d \" \" -f2- | cut -d: -f1 | sort -u This command will result in a list comprising entries like 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... Data DSL DDD Genlet Documentation ... Eclipse UI Examples ... Intermediate metamodels Intermediate Service Model ... Model Processing Framework ... OCL plugin Operation DSL ... Spring Cloud Genlet Static Analyzer Static Analyzer Library ... which are all good candidates for module names. Please capitalize nouns in module names, e.g., \"Intermediate Metamodels\" is preferred over \"Intermediate metamodels\". In case your commit concerns more than one LEMMA module , you might separate the module names with commas and an \"and\", e.g., 1 2 3 4 ... Service DSL and Technology DSL Service DSL, Mapping DSL, and Operation DSL ... If your commit does not concern a LEMMA module or all LEMMA modules , omit module names entirely, e.g., 1 2 3 4 5 6 Lift version identifiers to release 0.8.5 ... Update .gitignore Update license Update README ...","title":"LEMMA Module Names"},{"location":"developer-guide/coding-style/#colon-separator","text":"In case your commit affects one or more LEMMA modules , place a colon immediately after the module names. A space after the colon shall then separate the colon from the commit description: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Wrong (space after module name) Xtext Editor Plugin : Set module encoding to UTF-8 # Wrong (missing module name) Set module encoding to UTF-8 # Wrong (missing space after colon) Xtext Editor Plugin:Set module encoding to UTF-8 # Wrong (space after module name and missing space after colon) Xtext Editor Plugin :Set module encoding to UTF-8 # Right Xtext Editor Plugin: Set module encoding to UTF-8","title":"Colon Separator"},{"location":"developer-guide/coding-style/#commit-description","text":"Commit descriptions shall start with a verb in active form for the first person (I/we). Moreover, the description shall consist of at least one sentence in American English. The verb at the beginning of a commit message starts with an uppercase letter. All other words of the commit message follow regular capitalization in American English. In particular, proper names are capitalized the same way as within comments : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Wrong (verb at description beginning is not in first person; should be # \"Set\" instead of \"Sets\") Xtext Editor Plugin: Sets module encoding to UTF-8 # Wrong (verb at description beginning is not capitalized) Xtext Editor Plugin: set module encoding to UTF-8 # Wrong (\"eclipse\" and \"eclipse equinox\" are proper names and should be # capitalized as \"Eclipse\" and \"Eclipse Equinox\") Update eclipse equinox version to 3 .14.100 # Wrong (Java is a proper name) Java Base Generator: Streamline java-based Genlet implementation # Wrong (uncommon American English: first word of second sentence is # not capitalized and sentence does not end with a period) Some LEMMA Module: Add the foo to the bar. fixes baz due to use of ding # Right Xtext Editor Plugin: Set module encoding to UTF-8 Update Eclipse Equinox version to 3 .14.100 Java Base Generator: Streamline Java-based Genlet implementation # Right but not preferred Some LEMMA Module: Add the foo to the bar. Fixes baz due to use of ding. While the latter message is basically correct, we nowadays prefer \"long git commit messages\" for commit descriptions that consist of more than one sentence . The template for a \"long git commit message\" is as follows: 1 2 3 [LEMMA_MODULE_NAMES]: [COMMIT_SUMMARY_WITHOUT_TRAILING_PERIOD] [LONG_MESSAGE] The [LONG_MESSAGE] template variable is a block of text with a maximum width of 100 columns, in which each line is indented by 4 spaces . Consequently, the latter example commit message above should be reformatted as follows: 1 2 3 Some LEMMA Module: Add the foo to the bar This fixes baz due to use of ding. A real-world example of a \"long git commit message\" can be found in LEMMA commit 9237b941 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Live Validation Framework: Refactor towards loosely coupled Java implementation We split the current implementation of the Live Validation Framework into the following modules: - util: Shared utilities. - model: Shared classes for Live Validation issue representation. - protocol: LSP extensions specific to LEMMA Live Validation. - client: Framework components for Live Validation client implementation. - server: Standalone executable implementation of Live Validation server. The refactoring of the framework towards a Java implemention facilitates the usage of the Live Validation Framework by both the Eclipse editor plugin (Xtend-based) and LEMMA's Model Processing Framework (Kotlin-based). In particular, we split the server-related from the client-related parts and do no longer require the installation of Kotlin-specific artifacts via a dedicated Eclipse updatesite. To gain further insights on short LEMMA commit descriptions, you may execute the following Bash command on LEMMA's main branch in a cloned copy of LEMMA's repository: 1 2 git log --oneline | cut -d \" \" -f2- | cut -d: -f2- | \\ sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sort -u","title":"Commit Description"},{"location":"developer-guide/continuous-integration/","text":"Integrating New Modules With LEMMA's Continuous Integration Pipeline LEMMA provides a sophisticated Continuous Integration (CI) pipeline, whose configuration is visible from the Jenkinsfile in LEMMA's main branch . This pipeline supports: LEMMA builds under Windows Dockerized LEMMA builds under Linux Deployments of LEMMA artifacts in public Maven repositories (only from main branch) Deployment of LEMMA's Eclipse Updatesite (only from main branch) Deployment of Docker images specific to LEMMA modules (only from main branch) The various results of successful pipeline executions are obtainable from the following online resources: LEMMA builds: https://build.seelab.fh-dortmund.de/job/SeelabFhdo/job/lemma Deployed artifacts: https://repository.seelab.fh-dortmund.de/#browse/search/maven Deployed Eclipse Updatesite: https://microservices.fh-dortmund.de/lemma/ Deployed Docker images: https://repository.seelab.fh-dortmund.de/#browse/search/docker New modules for the LEMMA ecosystem can participate in the CI pipeline, and thus provide their own artifacts, Eclipse plugins, and Docker images for publication via LEMMA's CI pipeline. This page describes how to teach LEMMA's CI pipeline the consideration of new modules and their contributions to the ecosystem. Module Build Relevant Program Versions LEMMA builds rely on the following versions of programs or have been tested with them: Gradle : 5.2.1, 6.1.1, 6.3, 6.8, 7.1.1 (mentioned for completeness as Gradle downloads its required release for a given module when a build is triggered) Eclipse: 2021-03 Java: 11 Linux: Ubuntu 18.04 LTS (Bionic Beaver) Linux (in dockerized builds): Debian GNU/Linux 10 (buster) Maven : 3.6.3 Windows: 10 Build Scripts LEMMA's codebase comprises two specialized build scripts for Unix-like operating systems (including macOS) and Windows. Both scripts are located in the build folder of LEMMA's codebase: lemma.sh : Build script for Unix-like operating systems. lemma.bat : Build script for Windows. These scripts are executed by LEMMA's CI pipeline but it is also possible to invoke them on local hardware to build and install all necessary LEMMA dependencies in a local development file system. By contrast to the lemma.bat script, lemma.sh runs within a Docker container during builds with LEMMA's CI pipeline. The corresponding image's Dockerfile and related files are available from the build/docker folder in LEMMA's GitHub repository . Integrating New Modules With the Build Scripts The lemma.sh script invokes builds consecutively for the LEMMA modules listed in the lemma-build-modules.txt file located in the build folder of LEMMA's codebase. Each module name in the file corresponds to the name of a top-level folder in LEMMA's codebase. Hint To participate in LEMMA builds, the folder names of new modules may be added to the lemma-build-modules.txt file. However, their addition is only necessary if they are not already considered by parent modules. For example, the file comprises only the entry de.fhdo.lemma.data.datadsl.parent for LEMMA's Domain Data Modeling Language because the pom.xml in this folder is the parent Maven POM for all of the language's modules. Consequently, a new module for the Domain Data Modeling Language does not belong in the lemma-build-modules.txt file. Conversely to lemma.sh , the lemma.bat script requires direct modification for new LEMMA modules that are not covered by parent modules. More specifically, the name of a new module's top-level folder in LEMMA's codebase must be added to the modules array: 1 2 3 4 5 6 7 8 ... REM Analyzer set modules = %modules% ;de.fhdo.lemma.analyzer.lib set modules = %modules% ;de.fhdo.lemma.analyzer REM New (Group of) Module(s) set modules = %modules% ;{NEW_MODULE_PATH} ... Tip If you want do debug local LEMMA builds on a selected set of modules, you may temporarily adapt the lemma-build-modules.txt file (for lemma.sh ) and/or the modules array (in lemma.bat ), and remove modules from the local build process you do not care about. However, be aware that module removals in should not be become part of pull requests when their only purpose is build debugging. Customizing Module Builds Maven is LEMMA's default build system and both build scripts by default invoke the mvn clean install command to perform module builds (and installations to the local file system). However, this behavior is adaptable by putting a build.sh and/or build.bat script into the folder of a module. In case a build.sh file is present, the lemma.sh script will invoke it instead of mvn clean install for the module's builds on Unix-like operating systems. A build.bat script will then be employed for Windows builds of the respective module. We use this mechanism of build customization, for instance, to perform builds with other build systems than Maven, e.g., Gradle. The lemma.sh and lemma.bat scripts do not pass any information from the build process to build.sh or build.bat scripts. However, they check the return codes of custom builds and immediately abort the build process if a custom build script finishes with a return code greater 0 . You can find many examples of customized builds in LEMMA's codebase. Good (and generic) starters are the custom build scripts of LEMMA's static analysis library , whose code you can find under the following links and that trigger the Gradle build of the static analysis library: de.fhdo.lemma.analyzer.lib/build.sh de.fhdo.lemma.analyzer.lib/build.bat Eclipse Updatesite Build LEMMA's CI pipeline performs an extra build for LEMMA's Eclipse Updatesite in case all module builds ran successfully. Updatesite Build Script By contrast to the scripts that control LEMMA module builds, there exists only one script that is responsible for build artifact deployment, i.e., lemma-updatesite.sh in the build/updatesite folder of LEMMA's codebase . Similarly to the lemma.sh build script, the execution of lemma-updatesite.sh during CI pipeline runs happens from a Docker container, whose Dockerfile and related files are available from the build/updatesite/docker folder in LEMMA's GitHub repository . Integrating New Modules With the Updatesite Build Script The lemma-updatesite.sh script invokes builds consecutively for the LEMMA modules listed in the lemma-build-updatesite-modules.txt file located in the build/updatesite folder of LEMMA's codebase. Each module name in the file corresponds to the name of a top-level folder in LEMMA's codebase. Hint To participate in Eclipse Updatesite builds, the folder names of new modules may be added to the lemma-build-updatesite-modules.txt file. However, their addition is only necessary if they are not already considered by parent modules. For example, the file comprises only the entry de.fhdo.lemma.data.datadsl.parent for LEMMA's Domain Data Modeling Language because the pom.xml in this folder is the parent Maven POM for all of the language's modules. Consequently, a new module for the Domain Data Modeling Language does not belong in the lemma-build-updatesite-modules.txt file. In addition, it is necessary to add new LEMMA modules to the feature.xml file in LEMMA's de.fhdo.lemma.eclipse.updatesite.feature module. Otherwise, the built Updatesite will not comprise them. Customizing Eclipse Updatesite Builds Internally, the lemma-updatesite.sh script invokes the lemma.sh script for module builds on the lemma-build-updatesite-modules.txt file. Consequently, the same customization options apply to Eclipse Updatesite builds. In addition, the lemma-updatesite.sh script exports the LEMMA_UPDATESITE_BUILD environment variable with the value \"true\" to make Eclipse Updatesite builds distinguishable from previous module builds. Using the variable, Maven POM files may, for instance, behave differently by applying specialized Maven build profiles , during Eclipse Updatesite builds. See for example the pom.xml file of the parent project of LEMMA's Domain Data Modeling Language . It skips tests in its eclipse-updatesite profile, which gets activated when the LEMMA_UPDATESITE_BUILD environment variable has the value \"true\" , to shorten the build time by omitting redundant tests that already ran during previous module builds. Artifact and Eclipse Updatesite Deployment LEMMA's CI pipeline performs the deployment of build artifacts in case all module builds and Eclipse Updatesite builds ran successfully. Hint The CI pipeline performs the deployment only for changes in LEMMA's main branch. Concerning the deployment of the Eclipse Updatesite to its server , it is also necessary that the commit, which triggered a CI pipeline run, has a release tag of the form v$MAJOR.$MINOR(.$PATCH)? with $MAJOR , $MINOR , and $PATCH being numerical 1 . For example, v0.8 and v0.8.5 are valid release tags. Deployment Script By contrast to the scripts that control LEMMA module builds, there exists only one script that is responsible for build artifact deployment, i.e., lemma-deploy.sh in the build/deploy folder of LEMMA's codebase . The script is meant to be executed by LEMMA's CI pipeline only. Specifically, its intended use does not involve deployments from local hardware. Similarly to the lemma.sh build script, the execution of lemma-deploy.sh during CI pipeline runs happens from a Docker container, whose Dockerfile and related files are available from the build/deploy/docker folder in LEMMA's GitHub repository . Integrating New Modules With the Deployment Script The lemma-deploy.sh script invokes builds consecutively for the LEMMA modules listed in the lemma-deployment-modules.txt file located in the build/deploy folder of LEMMA's codebase. Each module name in the file corresponds to the name of a top-level folder in LEMMA's codebase. Hint To deploy the artifacts of new modules after their successful build from LEMMA's CI pipeline, the modules' folder names may be added to the lemma-deployment-modules.txt file. However, their addition is only necessary if they are not already considered by parent modules. For example, the file comprises only the entry de.fhdo.lemma.data.datadsl.parent for LEMMA's Domain Data Modeling Language because the pom.xml in this folder is the parent Maven POM for all of the language's modules. Consequently, a new module for the Domain Data Modeling Language does not belong in the lemma-deployment-modules.txt file. Customizing Module Deployments As with module builds , LEMMA by default relies on Maven for module deployments. More specifically, the default command invoked by lemma-deploy.sh for this purpose is mvn deploy . Again, this behavior is however customizable, i.e., modules may provide a script called deploy.sh in their top-level folders. The lemma-deploy.sh script will then delegate all deployment steps for the module to the custom deploy.sh script. We use this mechanism of artifact deployment customization, for instance, to deploy artifacts that were built with other systems than Maven, e.g., Gradle. The lemma-deploy.sh script provides four environment variables that are accessible by custom deployment scripts: DEPLOY_MAVEN_USER : The user to access the remote artifact repository for storage of build artifacts. DEPLOY_MAVEN_PASSWORD : The password to access the remote artifact repository in combination with the user. DEPLOY_MAVEN_URL_SNAPSHOTS : The URL of the remote artifact repository for snapshot artifacts that are, e.g., not ready for production. DEPLOY_MAVEN_URL_RELEASES : The URL of the remote artifact repository for release artifacts. The lemma-deploy.sh script checks the return codes of custom deployments and immediately abort the deployment process (and thus the current CI pipeline run) if a custom deployment script finishes with a return code greater 0 . You can find many examples of customized deployments in LEMMA's codebase. A good starter is the custom deployment script of LEMMA's static analysis library , whose code you can find under the de.fhdo.lemma.analyzer.lib/deploy.sh file in LEMMA's codebase . The script uses Gradle to deploy LEMMA's static analysis library as per the configuration in the de.fhdo.lemma.analyzer.lib/deploy.gradle.kts file . Furthermore, the lemma-deploy.sh scripts exports the environment variable LEMMA_DEPLOYMENT with the value \"true\" . As for Eclipse Updatesite builds , the variable allows an additional means to recognize module deployments. We use this variable, e.g., to skips tests from previous module builds. See for example the pom.xml file of the parent project of LEMMA's Domain Data Modeling Language , which activates its deployment build profile for this purpose based on the value of the LEMMA_DEPLOYMENT environment variable. Build and Deployment of Module-Specific Docker Images LEMMA's CI pipeline integrates a step to deploy module-specific Docker images, which may enable to, e.g., provide model processors as standalone applications including the required runtime environment. Hint The CI pipeline performs the deployment only for changes in LEMMA's main branch. Deployment Script The build and deployment of module-specific Docker images is controlled by the docker-images-push.sh script in the build/docker-images-push folder of LEMMA's codebase . The script is meant to be executed by LEMMA's CI pipeline only. Specifically, its intended use does not involve deployments from local hardware. Integrating New Modules With the Deployment Script The docker-images-push.sh script operates on the same file of module entries as the lemma.sh script, i.e., lemma-build-modules.txt . In case the script encounters a file called build.sh in the docker folder of a LEMMA module, it will delegate the build of a Docker image to this script. The build.sh script receives as its first (and only) argument the version of its module, e.g., \"0.8.5-SNAPSHOT\" , from the docker-images-push.sh script. The version string corresponds to the version configured with the module's build system. For example, Maven usually determines versions by the <version> tag in a pom.xml file, whereas Gradle assigns the version string to the version variable in a gradle.properties file. The build.sh script must export an environment variable called LEMMA_DOCKER_IMAGE_TAG with the name of the Docker image that it builds, e.g., \"lemma/static_analyzer:latest\" . The content of this variable will then be used by the docker-images-push.sh script to deploy the image, if its build succeeded, i.e., the build.sh script exited with a return code of 0 . You can find many examples for the provisioning of module-specific Docker images in LEMMA's codebase. A good starter is the build.sh script for the image of LEMMA's static analyzer , whose code you can find under the de.fhdo.lemma.analyzer/docker/build.sh file in LEMMA's codebase . Checklist The following checklist provides a quick overview for developers to integrate their new modules with LEMMA's CI pipeline. It only applies to modules that are standalone , e.g., Maven parent projects or executable model processors, which are not sub-projects of other model processors: Optional : In case the module uses another build system than Maven : Customize module build for chosen build system via build.sh and build.bat scripts ( details ). Depending on the operating system, LEMMA's CI pipeline will delegate the module's build to these scripts. Customize module deployment for chosen build system via deploy.sh script ( details ). LEMMA's CI pipeline will delegate the module's deployment to this script. Add module folder to lemma-build-modules.txt file and the modules array in the lemma.bat script ( details ). LEMMA's CI pipeline will consider the module during the build stage. Add module folder to the lemma-deployment-modules.txt file ( details ). LEMMA's CI pipeline will consider the module during the deployment stage. Optional : In case the module is an Eclipse plugin : Add module folder to lemma-build-updatesite-modules.txt file as well as the feature.xml file in LEMMA's de.fhdo.lemma.eclipse.updatesite.feature module ( details ). LEMMA's CI pipeline will consider the module during the build and deployment of the Eclipse Updatesite. Optional : Module shall provide its own Docker image : Add a build.sh script to a folder called docker in the module's root folder ( details ). LEMMA's CI pipeline will consider the module during the build and deployment of module-specific Docker images. Technically speaking, the Bash-specific regular expression for release tags is ^v[0-9]+\\.[0-9]+(\\.[0-9]+)? . \u21a9","title":"Integrating New Modules With LEMMA's Continuous Integration Pipeline"},{"location":"developer-guide/continuous-integration/#integrating-new-modules-with-lemmas-continuous-integration-pipeline","text":"LEMMA provides a sophisticated Continuous Integration (CI) pipeline, whose configuration is visible from the Jenkinsfile in LEMMA's main branch . This pipeline supports: LEMMA builds under Windows Dockerized LEMMA builds under Linux Deployments of LEMMA artifacts in public Maven repositories (only from main branch) Deployment of LEMMA's Eclipse Updatesite (only from main branch) Deployment of Docker images specific to LEMMA modules (only from main branch) The various results of successful pipeline executions are obtainable from the following online resources: LEMMA builds: https://build.seelab.fh-dortmund.de/job/SeelabFhdo/job/lemma Deployed artifacts: https://repository.seelab.fh-dortmund.de/#browse/search/maven Deployed Eclipse Updatesite: https://microservices.fh-dortmund.de/lemma/ Deployed Docker images: https://repository.seelab.fh-dortmund.de/#browse/search/docker New modules for the LEMMA ecosystem can participate in the CI pipeline, and thus provide their own artifacts, Eclipse plugins, and Docker images for publication via LEMMA's CI pipeline. This page describes how to teach LEMMA's CI pipeline the consideration of new modules and their contributions to the ecosystem.","title":"Integrating New Modules With LEMMA's Continuous Integration Pipeline"},{"location":"developer-guide/continuous-integration/#module-build","text":"","title":"Module Build"},{"location":"developer-guide/continuous-integration/#relevant-program-versions","text":"LEMMA builds rely on the following versions of programs or have been tested with them: Gradle : 5.2.1, 6.1.1, 6.3, 6.8, 7.1.1 (mentioned for completeness as Gradle downloads its required release for a given module when a build is triggered) Eclipse: 2021-03 Java: 11 Linux: Ubuntu 18.04 LTS (Bionic Beaver) Linux (in dockerized builds): Debian GNU/Linux 10 (buster) Maven : 3.6.3 Windows: 10","title":"Relevant Program Versions"},{"location":"developer-guide/continuous-integration/#build-scripts","text":"LEMMA's codebase comprises two specialized build scripts for Unix-like operating systems (including macOS) and Windows. Both scripts are located in the build folder of LEMMA's codebase: lemma.sh : Build script for Unix-like operating systems. lemma.bat : Build script for Windows. These scripts are executed by LEMMA's CI pipeline but it is also possible to invoke them on local hardware to build and install all necessary LEMMA dependencies in a local development file system. By contrast to the lemma.bat script, lemma.sh runs within a Docker container during builds with LEMMA's CI pipeline. The corresponding image's Dockerfile and related files are available from the build/docker folder in LEMMA's GitHub repository .","title":"Build Scripts"},{"location":"developer-guide/continuous-integration/#integrating-new-modules-with-the-build-scripts","text":"The lemma.sh script invokes builds consecutively for the LEMMA modules listed in the lemma-build-modules.txt file located in the build folder of LEMMA's codebase. Each module name in the file corresponds to the name of a top-level folder in LEMMA's codebase. Hint To participate in LEMMA builds, the folder names of new modules may be added to the lemma-build-modules.txt file. However, their addition is only necessary if they are not already considered by parent modules. For example, the file comprises only the entry de.fhdo.lemma.data.datadsl.parent for LEMMA's Domain Data Modeling Language because the pom.xml in this folder is the parent Maven POM for all of the language's modules. Consequently, a new module for the Domain Data Modeling Language does not belong in the lemma-build-modules.txt file. Conversely to lemma.sh , the lemma.bat script requires direct modification for new LEMMA modules that are not covered by parent modules. More specifically, the name of a new module's top-level folder in LEMMA's codebase must be added to the modules array: 1 2 3 4 5 6 7 8 ... REM Analyzer set modules = %modules% ;de.fhdo.lemma.analyzer.lib set modules = %modules% ;de.fhdo.lemma.analyzer REM New (Group of) Module(s) set modules = %modules% ;{NEW_MODULE_PATH} ... Tip If you want do debug local LEMMA builds on a selected set of modules, you may temporarily adapt the lemma-build-modules.txt file (for lemma.sh ) and/or the modules array (in lemma.bat ), and remove modules from the local build process you do not care about. However, be aware that module removals in should not be become part of pull requests when their only purpose is build debugging.","title":"Integrating New Modules With the Build Scripts"},{"location":"developer-guide/continuous-integration/#customizing-module-builds","text":"Maven is LEMMA's default build system and both build scripts by default invoke the mvn clean install command to perform module builds (and installations to the local file system). However, this behavior is adaptable by putting a build.sh and/or build.bat script into the folder of a module. In case a build.sh file is present, the lemma.sh script will invoke it instead of mvn clean install for the module's builds on Unix-like operating systems. A build.bat script will then be employed for Windows builds of the respective module. We use this mechanism of build customization, for instance, to perform builds with other build systems than Maven, e.g., Gradle. The lemma.sh and lemma.bat scripts do not pass any information from the build process to build.sh or build.bat scripts. However, they check the return codes of custom builds and immediately abort the build process if a custom build script finishes with a return code greater 0 . You can find many examples of customized builds in LEMMA's codebase. Good (and generic) starters are the custom build scripts of LEMMA's static analysis library , whose code you can find under the following links and that trigger the Gradle build of the static analysis library: de.fhdo.lemma.analyzer.lib/build.sh de.fhdo.lemma.analyzer.lib/build.bat","title":"Customizing Module Builds"},{"location":"developer-guide/continuous-integration/#eclipse-updatesite-build","text":"LEMMA's CI pipeline performs an extra build for LEMMA's Eclipse Updatesite in case all module builds ran successfully.","title":"Eclipse Updatesite Build"},{"location":"developer-guide/continuous-integration/#updatesite-build-script","text":"By contrast to the scripts that control LEMMA module builds, there exists only one script that is responsible for build artifact deployment, i.e., lemma-updatesite.sh in the build/updatesite folder of LEMMA's codebase . Similarly to the lemma.sh build script, the execution of lemma-updatesite.sh during CI pipeline runs happens from a Docker container, whose Dockerfile and related files are available from the build/updatesite/docker folder in LEMMA's GitHub repository .","title":"Updatesite Build Script"},{"location":"developer-guide/continuous-integration/#integrating-new-modules-with-the-updatesite-build-script","text":"The lemma-updatesite.sh script invokes builds consecutively for the LEMMA modules listed in the lemma-build-updatesite-modules.txt file located in the build/updatesite folder of LEMMA's codebase. Each module name in the file corresponds to the name of a top-level folder in LEMMA's codebase. Hint To participate in Eclipse Updatesite builds, the folder names of new modules may be added to the lemma-build-updatesite-modules.txt file. However, their addition is only necessary if they are not already considered by parent modules. For example, the file comprises only the entry de.fhdo.lemma.data.datadsl.parent for LEMMA's Domain Data Modeling Language because the pom.xml in this folder is the parent Maven POM for all of the language's modules. Consequently, a new module for the Domain Data Modeling Language does not belong in the lemma-build-updatesite-modules.txt file. In addition, it is necessary to add new LEMMA modules to the feature.xml file in LEMMA's de.fhdo.lemma.eclipse.updatesite.feature module. Otherwise, the built Updatesite will not comprise them.","title":"Integrating New Modules With the Updatesite Build Script"},{"location":"developer-guide/continuous-integration/#customizing-eclipse-updatesite-builds","text":"Internally, the lemma-updatesite.sh script invokes the lemma.sh script for module builds on the lemma-build-updatesite-modules.txt file. Consequently, the same customization options apply to Eclipse Updatesite builds. In addition, the lemma-updatesite.sh script exports the LEMMA_UPDATESITE_BUILD environment variable with the value \"true\" to make Eclipse Updatesite builds distinguishable from previous module builds. Using the variable, Maven POM files may, for instance, behave differently by applying specialized Maven build profiles , during Eclipse Updatesite builds. See for example the pom.xml file of the parent project of LEMMA's Domain Data Modeling Language . It skips tests in its eclipse-updatesite profile, which gets activated when the LEMMA_UPDATESITE_BUILD environment variable has the value \"true\" , to shorten the build time by omitting redundant tests that already ran during previous module builds.","title":"Customizing Eclipse Updatesite Builds"},{"location":"developer-guide/continuous-integration/#artifact-and-eclipse-updatesite-deployment","text":"LEMMA's CI pipeline performs the deployment of build artifacts in case all module builds and Eclipse Updatesite builds ran successfully. Hint The CI pipeline performs the deployment only for changes in LEMMA's main branch. Concerning the deployment of the Eclipse Updatesite to its server , it is also necessary that the commit, which triggered a CI pipeline run, has a release tag of the form v$MAJOR.$MINOR(.$PATCH)? with $MAJOR , $MINOR , and $PATCH being numerical 1 . For example, v0.8 and v0.8.5 are valid release tags.","title":"Artifact and Eclipse Updatesite Deployment"},{"location":"developer-guide/continuous-integration/#deployment-script","text":"By contrast to the scripts that control LEMMA module builds, there exists only one script that is responsible for build artifact deployment, i.e., lemma-deploy.sh in the build/deploy folder of LEMMA's codebase . The script is meant to be executed by LEMMA's CI pipeline only. Specifically, its intended use does not involve deployments from local hardware. Similarly to the lemma.sh build script, the execution of lemma-deploy.sh during CI pipeline runs happens from a Docker container, whose Dockerfile and related files are available from the build/deploy/docker folder in LEMMA's GitHub repository .","title":"Deployment Script"},{"location":"developer-guide/continuous-integration/#integrating-new-modules-with-the-deployment-script","text":"The lemma-deploy.sh script invokes builds consecutively for the LEMMA modules listed in the lemma-deployment-modules.txt file located in the build/deploy folder of LEMMA's codebase. Each module name in the file corresponds to the name of a top-level folder in LEMMA's codebase. Hint To deploy the artifacts of new modules after their successful build from LEMMA's CI pipeline, the modules' folder names may be added to the lemma-deployment-modules.txt file. However, their addition is only necessary if they are not already considered by parent modules. For example, the file comprises only the entry de.fhdo.lemma.data.datadsl.parent for LEMMA's Domain Data Modeling Language because the pom.xml in this folder is the parent Maven POM for all of the language's modules. Consequently, a new module for the Domain Data Modeling Language does not belong in the lemma-deployment-modules.txt file.","title":"Integrating New Modules With the Deployment Script"},{"location":"developer-guide/continuous-integration/#customizing-module-deployments","text":"As with module builds , LEMMA by default relies on Maven for module deployments. More specifically, the default command invoked by lemma-deploy.sh for this purpose is mvn deploy . Again, this behavior is however customizable, i.e., modules may provide a script called deploy.sh in their top-level folders. The lemma-deploy.sh script will then delegate all deployment steps for the module to the custom deploy.sh script. We use this mechanism of artifact deployment customization, for instance, to deploy artifacts that were built with other systems than Maven, e.g., Gradle. The lemma-deploy.sh script provides four environment variables that are accessible by custom deployment scripts: DEPLOY_MAVEN_USER : The user to access the remote artifact repository for storage of build artifacts. DEPLOY_MAVEN_PASSWORD : The password to access the remote artifact repository in combination with the user. DEPLOY_MAVEN_URL_SNAPSHOTS : The URL of the remote artifact repository for snapshot artifacts that are, e.g., not ready for production. DEPLOY_MAVEN_URL_RELEASES : The URL of the remote artifact repository for release artifacts. The lemma-deploy.sh script checks the return codes of custom deployments and immediately abort the deployment process (and thus the current CI pipeline run) if a custom deployment script finishes with a return code greater 0 . You can find many examples of customized deployments in LEMMA's codebase. A good starter is the custom deployment script of LEMMA's static analysis library , whose code you can find under the de.fhdo.lemma.analyzer.lib/deploy.sh file in LEMMA's codebase . The script uses Gradle to deploy LEMMA's static analysis library as per the configuration in the de.fhdo.lemma.analyzer.lib/deploy.gradle.kts file . Furthermore, the lemma-deploy.sh scripts exports the environment variable LEMMA_DEPLOYMENT with the value \"true\" . As for Eclipse Updatesite builds , the variable allows an additional means to recognize module deployments. We use this variable, e.g., to skips tests from previous module builds. See for example the pom.xml file of the parent project of LEMMA's Domain Data Modeling Language , which activates its deployment build profile for this purpose based on the value of the LEMMA_DEPLOYMENT environment variable.","title":"Customizing Module Deployments"},{"location":"developer-guide/continuous-integration/#build-and-deployment-of-module-specific-docker-images","text":"LEMMA's CI pipeline integrates a step to deploy module-specific Docker images, which may enable to, e.g., provide model processors as standalone applications including the required runtime environment. Hint The CI pipeline performs the deployment only for changes in LEMMA's main branch.","title":"Build and Deployment of Module-Specific Docker Images"},{"location":"developer-guide/continuous-integration/#deployment-script_1","text":"The build and deployment of module-specific Docker images is controlled by the docker-images-push.sh script in the build/docker-images-push folder of LEMMA's codebase . The script is meant to be executed by LEMMA's CI pipeline only. Specifically, its intended use does not involve deployments from local hardware.","title":"Deployment Script"},{"location":"developer-guide/continuous-integration/#integrating-new-modules-with-the-deployment-script_1","text":"The docker-images-push.sh script operates on the same file of module entries as the lemma.sh script, i.e., lemma-build-modules.txt . In case the script encounters a file called build.sh in the docker folder of a LEMMA module, it will delegate the build of a Docker image to this script. The build.sh script receives as its first (and only) argument the version of its module, e.g., \"0.8.5-SNAPSHOT\" , from the docker-images-push.sh script. The version string corresponds to the version configured with the module's build system. For example, Maven usually determines versions by the <version> tag in a pom.xml file, whereas Gradle assigns the version string to the version variable in a gradle.properties file. The build.sh script must export an environment variable called LEMMA_DOCKER_IMAGE_TAG with the name of the Docker image that it builds, e.g., \"lemma/static_analyzer:latest\" . The content of this variable will then be used by the docker-images-push.sh script to deploy the image, if its build succeeded, i.e., the build.sh script exited with a return code of 0 . You can find many examples for the provisioning of module-specific Docker images in LEMMA's codebase. A good starter is the build.sh script for the image of LEMMA's static analyzer , whose code you can find under the de.fhdo.lemma.analyzer/docker/build.sh file in LEMMA's codebase .","title":"Integrating New Modules With the Deployment Script"},{"location":"developer-guide/continuous-integration/#checklist","text":"The following checklist provides a quick overview for developers to integrate their new modules with LEMMA's CI pipeline. It only applies to modules that are standalone , e.g., Maven parent projects or executable model processors, which are not sub-projects of other model processors: Optional : In case the module uses another build system than Maven : Customize module build for chosen build system via build.sh and build.bat scripts ( details ). Depending on the operating system, LEMMA's CI pipeline will delegate the module's build to these scripts. Customize module deployment for chosen build system via deploy.sh script ( details ). LEMMA's CI pipeline will delegate the module's deployment to this script. Add module folder to lemma-build-modules.txt file and the modules array in the lemma.bat script ( details ). LEMMA's CI pipeline will consider the module during the build stage. Add module folder to the lemma-deployment-modules.txt file ( details ). LEMMA's CI pipeline will consider the module during the deployment stage. Optional : In case the module is an Eclipse plugin : Add module folder to lemma-build-updatesite-modules.txt file as well as the feature.xml file in LEMMA's de.fhdo.lemma.eclipse.updatesite.feature module ( details ). LEMMA's CI pipeline will consider the module during the build and deployment of the Eclipse Updatesite. Optional : Module shall provide its own Docker image : Add a build.sh script to a folder called docker in the module's root folder ( details ). LEMMA's CI pipeline will consider the module during the build and deployment of module-specific Docker images. Technically speaking, the Bash-specific regular expression for release tags is ^v[0-9]+\\.[0-9]+(\\.[0-9]+)? . \u21a9","title":"Checklist"},{"location":"developer-guide/intermediate-model-specifications/","text":"Intermediate Model Specifications LEMMA defines intermediate specifications for domain models , service models , and operation models in order to facilitate model processing . However, there exist no intermediate specifications for technology models and mapping models . First, technology information is a crucial concern in model processing. Therefore, LEMMA will directly incorporate possible technology information assigned to the elements of domain, service, and operation models into the corresponding intermediate models during the process of intermediate model derivation . Hence, model processors have immediate access to all technology information. Second, since mapping models import service models for their technology-specific refinement, the transformation of a mapping model into an intermediate representation boils down to the iterative derivation of the intermediate representations of all imported service models. Benefits of Intermediate Models While it would also be possible to leverage Xtext's standalone mechanism to parse LEMMA models and then iterate the resulting object graph for model processing purposes, the usage of intermediate models based on well-defined intermediate specifications is beneficial in model processing for several reasons: Intermediate representations of modeling language concepts can constitute a well-defined API for model processors. Intermediate specifications decouple modeling languages from model processors. As a result, modeling languages may evolve independently from model processors as long as the corresponding intermediate representations remain stable. Intermediate specifications decrease the semantic gap between modeling languages and certain kinds of model processing. That is, because they allow implicit incorporation of language-specific characteristics into intermediate models. Such characteristics may comprise, e.g., resolved inheritance hierarchies or reified default values. Consequently, technology-specific model processors like code generators can directly use these information. First, this form of preprocessing relieves model processors from acquiring language-specific information. Second, it fosters consistent behavior of model processors by centralizing the responsibility for the provisioning of language-specific information. In the context of LEMMA, intermediate models make model processing independent of a certain modeling technology. That is, because LEMMA serializes intermediate models in the vendor-independent XML Metadata Interchange (XMI) format . What's Next? In the following, we describe how to obtain the intermediate representation of a LEMMA model as an XMI file and provide the intermediate specifications for domain models , service models , and operation models . More precisely, these specifications constitute dedicated intermediate metamodels that govern the intermediate representations of LEMMA models both physically (i.e., within XMI files) and in-memory (i.e., as object graphs that originated from XMI parsing).","title":"Introduction"},{"location":"developer-guide/intermediate-model-specifications/#intermediate-model-specifications","text":"LEMMA defines intermediate specifications for domain models , service models , and operation models in order to facilitate model processing . However, there exist no intermediate specifications for technology models and mapping models . First, technology information is a crucial concern in model processing. Therefore, LEMMA will directly incorporate possible technology information assigned to the elements of domain, service, and operation models into the corresponding intermediate models during the process of intermediate model derivation . Hence, model processors have immediate access to all technology information. Second, since mapping models import service models for their technology-specific refinement, the transformation of a mapping model into an intermediate representation boils down to the iterative derivation of the intermediate representations of all imported service models.","title":"Intermediate Model Specifications"},{"location":"developer-guide/intermediate-model-specifications/#benefits-of-intermediate-models","text":"While it would also be possible to leverage Xtext's standalone mechanism to parse LEMMA models and then iterate the resulting object graph for model processing purposes, the usage of intermediate models based on well-defined intermediate specifications is beneficial in model processing for several reasons: Intermediate representations of modeling language concepts can constitute a well-defined API for model processors. Intermediate specifications decouple modeling languages from model processors. As a result, modeling languages may evolve independently from model processors as long as the corresponding intermediate representations remain stable. Intermediate specifications decrease the semantic gap between modeling languages and certain kinds of model processing. That is, because they allow implicit incorporation of language-specific characteristics into intermediate models. Such characteristics may comprise, e.g., resolved inheritance hierarchies or reified default values. Consequently, technology-specific model processors like code generators can directly use these information. First, this form of preprocessing relieves model processors from acquiring language-specific information. Second, it fosters consistent behavior of model processors by centralizing the responsibility for the provisioning of language-specific information. In the context of LEMMA, intermediate models make model processing independent of a certain modeling technology. That is, because LEMMA serializes intermediate models in the vendor-independent XML Metadata Interchange (XMI) format .","title":"Benefits of Intermediate Models"},{"location":"developer-guide/intermediate-model-specifications/#whats-next","text":"In the following, we describe how to obtain the intermediate representation of a LEMMA model as an XMI file and provide the intermediate specifications for domain models , service models , and operation models . More precisely, these specifications constitute dedicated intermediate metamodels that govern the intermediate representations of LEMMA models both physically (i.e., within XMI files) and in-memory (i.e., as object graphs that originated from XMI parsing).","title":"What's Next?"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/","text":"Intermediate Domain Model Specification This page specifies the structure and semantics of the intermediate metamodel for LEMMA domain models . All obtained intermediate LEMMA domain models must conform to this metamodel to ensure consistent behavior of LEMMA model processors . The following figure shows the metamodel's structure: Structure of the metamodel for intermediate domain models The source code of the metamodel specification can be found at https://github.com/SeelabFhdo/lemma/blob/main/de.fhdo.lemma.data.intermediate.metamodel/model/IntermediateDataModel.xcore . Each of the following sections describes certain concepts of the metamodel. Note Attributes that may contain more than one value but exhibit a * multiplicity, i.e., they may contain an arbitrary number of values or even none at all ( * is shorthand UML notation for 0..* ), are never null. In case no multiplicity is stated after the object type of an attribute, the attribute may be null. For example, an attribute defined as String name implicitly has a multiplicity 0..1 and in the zero-case the String may be null. However, in case the attribute's type is a built-in primitive Java type, e.g. int , the attribute will never be null but exhibits the type's default value in case it did not receive an explicit value. Model Root Class IntermediateDataModel Root of an intermediate domain model. String[1] sourceModelUri file:// URI pointing to the source domain model file from which this intermediate domain model was derived. Note Model processors must not depend on this URI being absolute or relative. Both cases may occur in practice and are up to the modeler. IntermediateImport[*] imports References to the intermediate representations of imported domain models. IntermediateVersion[*] versions Versions being defined in the source domain model. IntermediateContext[*] contexts Contexts being defined in the source domain model. If a domain model has versions it may not have contexts under the model root. They are, instead, encapsulated within the versions attribute. IntermediateComplexType[*] complexTypes IntermediateDataStructure , IntermediateCollectionType , and IntermediateEnumeration , instances being defined in the source domain model. If a domain model has versions or contexts , it may not have complexTypes under the model root. They are, instead, encapsulated within the versions or contexts attributes Note At least one of the attributes versions , contexts , or compexTypes will have values, because LEMMA does not allow empty domain models. Imports LEMMA models and their elements may refer to each other. For instance, a service model may refer to domain-specific types defined in a domain model. This interlinkage of the different LEMMA model kinds and their elements is realized on the basis of an import mechanism. That is, a service model may import a domain model to enable the modeler to refer to modeled domain-specific types. However, certain model kinds also allow for importing instances of the same type. A domain model, for example, may import other domain models to use their data structures as types for the fields of its own structures. Class IntermediateImport Concept to represent the import of a domain model into the source domain model. String[1] name Alias of the import. Unique within the same domain model . String[1] importUri Unique file:// URI that points to the location of the intermediate representation of the imported domain model. Note Model processors must not depend on this URI being absolute or relative. Both cases may occur in practice and are up to the modeler. String[1] importTypeName Name of the import type. For domain models, the value of this attribute is always \"DATATYPES\". IntermediateDataModel[1] dataModel Link to the containing IntermediateDataModel instance. String[1] getImportTypeNameForDatatypes ( ) Helper that returns the name of the import type for domain-specific types. This method will always return the value \"DATATYPES\", which corresponds to the only possible value of the importTypeName attribute. Namespace Concepts Namespace concepts allow for organizing a domain model. Conceptually, they correspond to Java's package mechanism. Class IntermediateVersion A namespace concept to organize evolved contents of a domain model in different versions. String[1] name Name of the version. Unique within the same domain model . IntermediateComplexType[*] complexTypes Complex types defined directly within the version. IntermediateContext[*] contexts Contexts encapsulated by the version. Note For the same IntermediateVersion , either the complexTypes or the contexts attribute will contain values but neither both. IntermediateDataModel[1] dataModel Link to the containing IntermediateDataModel instance. Class IntermediateContext A namespace concept to organize domain-specific types of a domain model in semantic domains that may correspond to Bounded Contexts . String[1] name Name of the context. Unique within the same domain model or version . String[1] qualifiedName Qualified name of the context. The qualified name of the context consists of the name of the version , if any, and the name of the context separated by a dot. In case the context is not part of a version , the qualifiedName equals the context's name . Hint The IntermedateVersion class does not comprise a qualifiedName attribute, because versions may not be contained within an instance of another model concept's class except for the nameless model root . IntermediateComplexType[1..*] complexTypes Complex types being defined within the context. IntermediateDataModel dataModel Link to the containing IntermediateDataModel instance. IntermediateVersion version Link to the containing IntermediateVersion instance. Note Only one of the attributes dataModel or version has a value, depending on whether the context is defined directly under the model root or within a version . Note Contexts may not be nested. Built-in Type System This subsection describes concepts that are part of LEMMA's built-in type system provided by the Domain Data Modeling Language. The type system is aligned to Java and contains all built-in Java primitive types as well as the native types date , string , and unspecified . Besides the unspecified type, the type conversions observe Java's widening primitive conversions for primitively typed fields . The unspecified type, however, is not compatible with any other type. More precisely, two distinct fields with the unspecified type are not considered to be compatible. That is, the unspecified type communicates the intended current absence of a type, e.g., to determine that a typing decision has not been taken, yet. Two data structures are compatible, if their fields are compatible, independent of their type ordering. Two distinct enumerations are compatible, if the value-receiving enumeration comprises all initialization values of the value-providing enumeration. Enum IntermediateTypeKind Enumeration to specify the kind of an IntermediateType instance being referenced in some place. COLLECTION Referenced type is an IntermediateCollectionType . ENUMERATION Referenced type is an IntermediateEnumeration . PRIMITIVE Referenced type is an IntermediatePrimitiveType . STRUCTURE Referenced type is an IntermediateDataStructure . Enum IntermediateTypeOrigin Enumeration to specify the origin of an IntermediateType instance being referenced in some place. DATA_MODEL Type is an IntermediateComplexType defined in a domain model. BUILTIN Type is a built-in type. TECHNOLOGY Type is technology-specific. Technology-specific types may be used to map built-in primitive types to technology-specific types, e.g., float to float32 in the Go programming language . Moreover, they may be used to declare technology-specific structure or collection types. Code generators need to be able to interpret technology-specific types that were defined in a LEMMA technology model. Hint Currently, the following combinations of IntermediateTypeKind and IntermediateTypeOrigin values are possible: Kind Origin COLLECTION DATA_MODEL , TECHNOLOGY ENUMERATION DATA_MODEL PRIMITIVE BUILTIN , TECHNOLOGY STRUCTURE DATA_MODEL , TECHNOLOGY Abstract Class IntermediateType Abstract super class for all types. String[1] name Name of the type. IntermediateTypeOrigin[1] origin Origin of the type. IntermediateTypeKind[1] kind Kind of the type. IntermediateDataField[1] dataField Data field that is typed by this type's instance. Class IntermediatePrimitiveType : IntermediateType Representation of a primitive type being used within the domain model. Integer size Size of the primitive type in bits. The built-in primitive types have the following sizes: Type Size (in bits) boolean 1 byte 8 char 16 date null (object type) double 64 float 32 int 32 long 64 short 16 string null (object type) unspecified null (communicates type absence) IntermediateDataField initializedDataField Link to the IntermediateDataField , whose initialization value is compatible with this primitive type. IntermediateEnumerationField initializedEnumerationField Link to the IntermediateEnumerationField , whose initialization value is compatible with this primitive type. Custom, Domain-Specific Types Class IntermediateComplexType : IntermediateType Super class of complex types like IntermediateDataStructure , IntermediateCollectionType , and IntermediateEnumeration . String[1] qualifiedName Qualified name of the type. Corresponds to the name of the type prefixed by its version , if any, and its context , if any. The qualifying fragments are separated by dots. IntermediateImportedAspect[*] aspects The aspects that were assigned to the complex type. IntermediateDataModel dataModel Link to the containing IntermediateDataModel instance. IntermediateVersion version Link to the containing IntermediateVersion instance. IntermediateContext context Link to the containing IntermediateContext instance. Note Only one of the attributes dataModel , version , or context has a value, depending on whether the type is defined directly under the model root , within a version , or within a context . Class IntermediateImportedComplexType : IntermediateComplexType This class represents an IntermediateComplexType that has been imported from another domain model. IntermediateImport import The import from which the complex type originates. Class IntermediateDataStructure : IntermediateComplexType A domain-specific data structure that usually comprises a variety of typed fields . String[*] featureNames This attribute contains the names of all features specified for the data structure. The following values are possible: Feature Name Description \"AGGREGATE\" Data structure is an Aggregate in the sense of Domain-driven Design (DDD) . \"APPLICATION_SERVICE\" Data structure is a Service with application focus in the sense of DDD. \"DOMAIN_EVENT\" Data structure is a Domain Event in the sense of DDD. \"DOMAIN_SERVICE\" Data structure is a Service with domain focus in the sense of DDD. \"ENTITY\" Data structure is an Entity in the sense of DDD. \"FACTORY\" Data structure is a Factory in the sense of DDD. \"INFRASTRUCTURE_SERVICE\" Data structure is a Service with infrastructure focus in the sense of DDD. \"REPOSITORY\" Data structure is a Repository in the sense of DDD. \"SERVICE\" Data structure is a Service in the sense of DDD. \"SPECIFICATION\" Data structure is a Specification in the sense of DDD. \"VALUE_OBJECT\" Data structure is a Value Object in the sense of DDD. Note DDD-related features should follow the constraints described here . LEMMA's Domain Data Modeling Language currently only issues warnings in case constraints are violated. Model processors are however free to deny functioning and yield errors in case they detect constraint violations. IntermediateDataStructure super The super data structure from which this data structure inherits. Note LEMMA's Domain Data Modeling Language supports single inheritance only. Furthermore, the super data structure must be defined within the same domain model. It cannot be imported from another domain model. IntermediateDataField[*] dataFields Data fields of the structure. Hint In case the data structure inherits from a super structure, the attribute also contains inherited, non-hidden fields. Inherited fields of a structure can be distinguished from \"local\" fields by means of the IntermediateDataField concept's inherited attribute . IntermediateDataOperation[*] operations Operations of the structure. Hint In case the data structure inherits from a super structure, the attribute also contains inherited, non-hidden operations. Inherited operations of a structure can be distinguished from \"local\" operations by means of the IntermediateOperation concept's inherited attribute. Class IntermediateDataOperation An operation within an IntermediateDataStructure . String[1] name Name of the operation. Unique within the same structure . String[1] qualifiedName Qualified name of the operation. Corresponds to the name of the operation prefixed by the qualified name of the defining IntermediateDataStructure . The name fragments are separated by dots. boolean hidden Flag to indicate if the operation is hidden. Semantically, this flag corresponds to Java's private accessibility modifier. However, the flag differs in that an inherited operation may also be set to hidden. That is, operations' visibility may be overridden. A hidden operation is not visible in any of the following levels of the inheritance hierarchy. boolean inherited Flag to indicate if the operation was inherited from a super structure . String[*] featureNames This attribute contains the names of all features specified for the operation. The following values are possible: Feature Name Description \"CLOSURE\" Operation is a Closure in the sense of DDD. \"IDENTIFIER\" Operation acts as identifier for an Entity in the sense of DDD (see also the featureNames attribute of the IntermediateDataStructure concept ). \"SIDE_EFFECT_FREE\" Operation is side-effect-free in the sense of DDD. \"VALIDATOR\" Operation acts as validator for a Specification in the sense of DDD (see also the featureNames attribute of the IntermediateDataStructure concept ). Note DDD-related features should follow the constraints described here . LEMMA's Domain Data Modeling Language currently only issues warnings in case constraints are violated. Model processors are however free to deny functioning and yield errors in case they detect constraint violations. IntermediateDataOperationReturnType returnType The return type of the operation. This attribute is empty when no return type was specified. IntermediateDataOperationParameter[*] parameters The parameters of the operation. IntermediateImportedAspect[*] aspects The aspects that were assigned to the operation. Class IntermediateDataOperationReturnType The return type of an IntermediateDataOperation . IntermediateType[1] type The return type. Hint The attribute always holds a unique IntermediateType instance , i.e., instances of the same types are not reused. Hint Model processors must use this type as the operation's return type and not the originalType . IntermediateType[1] originalType The original return type of the operation. Hint The attribute always holds a value. In case the value differs from that of the type attribute , the return type got altered in a mapping model and the type attribute attribute holds an instance of the IntermediateImportedTechnologySpecificType concept that identifies the technology-specific type to which the original return type was mapped. IntermediateImportedAspect[*] aspects The aspects that were assigned to the return type within a mapping model . Class IntermediateDataOperationParameter A parameter within an IntermediateDataOperation . String[1] name Name of the parameter. Unique within the same operation . String[1] qualifiedName Qualified name of the parameter. Corresponds to the name of the parameter prefixed by the qualified name of the defining IntermediateDataOperation . The name fragments are separated by dots. IntermediateType[1] type The type of the parameter. Hint The attribute always holds a unique IntermediateType instance , i.e., instances of the same types are not reused. Hint Model processors must use this type as the operation's return type and not the originalType . IntermediateType[1] originalType The original type of the parameter. Hint The attribute always holds a value. In case the value differs from that of the type attribute , the type got altered in a mapping model and the type attribute attribute holds an instance of the IntermediateImportedTechnologySpecificType concept that identifies the technology-specific type to which the parameter's original type was mapped. IntermediateImportedAspect[*] aspects The aspects that were assigned to the return type within a mapping model . Class IntermediateDataField A field within an IntermediateDataStructure . String[1] name Name of the field. Unique within the same structure or collection type . String[1] qualifiedName Qualified name of the field. Corresponds to the name of the field prefixed by the qualified name of the defining IntermediateDataStructure . The name fragments are separated by dots. boolean hidden Flag to indicate if the field is hidden. Semantically, this flag corresponds to Java's private accessibility modifier. However, the flag differs in that an inherited field may also be set to hidden. That is, fields' visibility may be overridden. A hidden field is not visible in any of the following levels of the inheritance hierarchy. boolean immutable Flag to indicate whether the field is immutable or not. In Java, for example, an immutable field could correspond to a field that has no public setter. boolean inherited Flag to indicate if the field was inherited from a super structure . String[*] featureNames This attribute contains the names of all features specified for the field. The following values are possible: Feature Name Description \"IDENTIFIER\" Field acts as identifier for an Entity in the sense of DDD (see also the featureNames attribute of the IntermediateDataStructure concept ). \"NEVER_EMPTY\" Field should never be empty. \"PART\" Field is a part of a DDD Aggregate (see also the featureNames attribute of the IntermediateDataStructure concept ). Note DDD-related features should follow the constraints described here . LEMMA's Domain Data Modeling Language currently only issues warnings in case constraints are violated. Model processors are however free to deny functioning and yield errors in case they detect constraint violations. String initializationValue If the field has an initialization value, it is encoded in this attribute. It is guaranteed that the initialization value is compatible to all primitive types in the initializationValueCompatibleTypes attribute. Note Only fields defined in data structures can receive an initialization value. Note A field with the built-in primitive type unspecified cannot receive an initialization value. IntermediatePrimitiveType[*] initializationValueCompatibleTypes If the field exhibits an initialization value, this attribute comprises all primitive types to which the initialization value is compatible. Note There is no determined order in which the primitive types appear in the attribute. IntermediateType[1] type The type of the field. Hint The attribute always holds a unique IntermediateType instance , i.e., instances of the same types are not reused. Hint Model processors must use this type as the field's type and not the originalType . IntermediateType[1] originalType The original type of the field. Hint The attribute always holds a value. In case the value differs from that of the type attribute , the type got altered in a mapping model and the type attribute attribute holds an instance of the IntermediateImportedTechnologySpecificType concept that identifies the technology-specific type to which the field's original type was mapped. IntermediateImportedAspect[*] aspects The aspects that were assigned to the field within a mapping model . IntermediateDataStructure dataStructure Link to the defining IntermediateDataStructure instance. Class IntermediateCollectionType : IntermediateComplexType A domain-specific collection type. boolean primitiveCollection Flag to indicate if this is a collection that contains a sequence of primitive values. boolean structuredCollection Flag to indicate if this collection consists of one or more data fields . Note Exactly one of the flags primitiveCollection or structuredCollection will always be true . IntermediatePrimitiveType primitiveType In case the collection is a primitive collection , this attribute contains the IntermediatePrimitiveType instance that identifies the primitive type of the collection's values. IntermediateDataField[*] dataFields In case the collection is a structured collection , this attribute contains the IntermediateDataStructure instances that prescribe the structure of the collection's values. Class IntermediateEnumeration : IntermediateComplexType A domain-specific enumeration. String[*] featureNames This attribute contains the names of all features specified for the enumeration. The following values are possible: Feature Name Description \"DOMAIN_EVENT\" Enumeration is a Domain Event in the sense of DDD. \"VALUE_OBJECT\" Enumeration is a Value Object in the sense of DDD. Note DDD-related features should follow the constraints described here . LEMMA's Domain Data Modeling Language currently only issues warnings in case constraints are violated. Model processors are however free to deny functioning and yield errors in case they detect constraint violations. IntermediateEnumerationField[1..*] fields The fields of the enumeration. Class IntermediateEnumerationField A field of an IntermediateEnumeration . String[1] name Name of the field. Unique within the same enumeration . String[1] qualifiedName Qualified name of the field. Corresponds to the name of the field prefixed by the qualified name of the defining IntermediateEnumeration . The name fragments are separated by dots. String initializationValue Initialization value of the field. It is guaranteed that the initialization value is compatible to all primitive types in the initializationValueCompatibleTypes attribute. IntermediatePrimitiveType[*] initializationValueCompatibleTypes If the field exhibits an initialization value, this attribute comprises all primitive types to which the initialization value is compatible. Note There is no determined order in which the primitive types appear in the attribute. IntermediateEnumeration enumeration Link to the defining IntermediateEnumeration instance. Technologies In the following, concepts for technology assignment, e.g., to complex types and intermediate concepts for constructs from other modeling languages such as IntermediateMicroservice are described. Class IntermediateImportedTechnologySpecificType : IntermediateType Intermediate representation of a type defined within a technology model . String[1] qualifiedName Qualified name of the type. Consists of the name of the defining technology, the \"_types\" prefix as internal qualifier within the technology model, and the name of the type, separated by dots. IntermediateImport[1] import The IntermediateImport instance pointing to the technology model from which the type was imported. Class IntermediateImportedAspect Aspects allow semantic refinement of modeled complex types , operations , their parameters and return types , as well as fields . Next to domain-specific modeling concepts, aspects also target constructs from other LEMMA modeling languages and their intermediate representations, e.g., IntermediateMicroservice and IntermediateOperationNode . Aspects are defined within technology models . An aspect definition might be accompanied with properties and have their applicability constrained to certain peculiarities of concept instances to which they apply. With this mechanism it is possible to create, e.g., aspects for the OR mapping of data structures or the specification of HTTP status codes returned by a microservice operation. String[1] name Name of the aspect. String[1] qualifiedName Qualified name of the aspect. Consists of the name of the defining technology, the \"_aspects\" prefix as internal qualifier within the technology model, and the name of the aspect, separated by dots. String[*] featureNames This attribute contains the names of all features specified for the aspect. The following values are possible: Feature Name Description \"SINGE_VALUED\" Flag to indicate that an aspect may only be applied once at a target element. IntermediateImport[1] import The IntermediateImport instance pointing to the technology model from which the type was imported. IntermediateAspectProperty[*] properties Properties of the aspect as defined in its technology model. IntermediateAspectPropertyValue[*] propertyValues Values for aspect properties as assigned in the aspect's application within the source model. IntermediateComplexType complexType IntermediateComplexType to which the aspect was applied. IntermediateDataOperation operation IntermediateDataOperation to which the aspect was applied. IntermediateDataOperationParameter parameter IntermediateDataOperationParameter to which the aspect was applied. IntermediateDataField dataField IntermediateDataField to which the aspect was applied. Map<IntermediateAspectProperty, String> getEffectivePropertyValues ( ) Helper to return the effective property values for an aspect application. The effective property values consist of the default values for the aspect's properties and the property values specific to the aspect's application . Class IntermediateAspectProperty Specification of an aspect property. String[1] name Name of the property. Unique within the same aspect . String[1] type Name of the property's primitive type . The attribute can receive one of the following values: \"boolean\" \"byte\" \"char\" \"date\" \"double\" \"float\" \"int\" \"long\" \"short\" \"string\" Note A property cannot be of the built-in primitive type unspecified . String defaultValue This attribute encodes a possible default value of the property. It is guaranteed that this value fits the property's type . String[*] featureNames This attribute contains the names of all features specified for the property. The following values are possible: Feature Name Description \"MANDATORY\" Flag to indicate that the property needs to receive a value. It is guaranteed that all mandatory properties receive a value during the application of the respective aspect . \"SINGE_VALUED\" Flag to indicate that a property may only receive a value once. It is guaranteed that all single-valued properties receive at most one value during the application of the respective aspect . IntermediateImportedAspect aspect The aspect to which the property belongs. Class IntermediateAspectPropertyValue Value of an IntermediateAspectProperty . String[1] value The value encoded as a String. IntermediateAspectProperty[1] property The aspect property for which the value was specified. IntermediateImportedAspect aspect The aspect application to which the property value belongs.","title":"Intermediate Domain Model Specification"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#intermediate-domain-model-specification","text":"This page specifies the structure and semantics of the intermediate metamodel for LEMMA domain models . All obtained intermediate LEMMA domain models must conform to this metamodel to ensure consistent behavior of LEMMA model processors . The following figure shows the metamodel's structure: Structure of the metamodel for intermediate domain models The source code of the metamodel specification can be found at https://github.com/SeelabFhdo/lemma/blob/main/de.fhdo.lemma.data.intermediate.metamodel/model/IntermediateDataModel.xcore . Each of the following sections describes certain concepts of the metamodel. Note Attributes that may contain more than one value but exhibit a * multiplicity, i.e., they may contain an arbitrary number of values or even none at all ( * is shorthand UML notation for 0..* ), are never null. In case no multiplicity is stated after the object type of an attribute, the attribute may be null. For example, an attribute defined as String name implicitly has a multiplicity 0..1 and in the zero-case the String may be null. However, in case the attribute's type is a built-in primitive Java type, e.g. int , the attribute will never be null but exhibits the type's default value in case it did not receive an explicit value.","title":"Intermediate Domain Model Specification"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#model-root","text":"","title":"Model Root"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateDataModel","text":"Root of an intermediate domain model.","title":"Class IntermediateDataModel"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataModel-sourceModelUri","text":"file:// URI pointing to the source domain model file from which this intermediate domain model was derived. Note Model processors must not depend on this URI being absolute or relative. Both cases may occur in practice and are up to the modeler.","title":"String[1] sourceModelUri"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataModel-imports","text":"References to the intermediate representations of imported domain models.","title":"IntermediateImport[*] imports"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataModel-versions","text":"Versions being defined in the source domain model.","title":"IntermediateVersion[*] versions"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataModel-contexts","text":"Contexts being defined in the source domain model. If a domain model has versions it may not have contexts under the model root. They are, instead, encapsulated within the versions attribute.","title":"IntermediateContext[*] contexts"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataModel-complexTypes","text":"IntermediateDataStructure , IntermediateCollectionType , and IntermediateEnumeration , instances being defined in the source domain model. If a domain model has versions or contexts , it may not have complexTypes under the model root. They are, instead, encapsulated within the versions or contexts attributes Note At least one of the attributes versions , contexts , or compexTypes will have values, because LEMMA does not allow empty domain models.","title":"IntermediateComplexType[*] complexTypes"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#imports","text":"LEMMA models and their elements may refer to each other. For instance, a service model may refer to domain-specific types defined in a domain model. This interlinkage of the different LEMMA model kinds and their elements is realized on the basis of an import mechanism. That is, a service model may import a domain model to enable the modeler to refer to modeled domain-specific types. However, certain model kinds also allow for importing instances of the same type. A domain model, for example, may import other domain models to use their data structures as types for the fields of its own structures.","title":"Imports"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateImport","text":"Concept to represent the import of a domain model into the source domain model.","title":"Class IntermediateImport"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImport-name","text":"Alias of the import. Unique within the same domain model .","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImport-importUri","text":"Unique file:// URI that points to the location of the intermediate representation of the imported domain model. Note Model processors must not depend on this URI being absolute or relative. Both cases may occur in practice and are up to the modeler.","title":"String[1] importUri"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImport-importTypeName","text":"Name of the import type. For domain models, the value of this attribute is always \"DATATYPES\".","title":"String[1] importTypeName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImport-dataModel","text":"Link to the containing IntermediateDataModel instance.","title":"IntermediateDataModel[1] dataModel"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImport-getImportTypeNameForDatatypes","text":"Helper that returns the name of the import type for domain-specific types. This method will always return the value \"DATATYPES\", which corresponds to the only possible value of the importTypeName attribute.","title":"String[1] getImportTypeNameForDatatypes()"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#namespace-concepts","text":"Namespace concepts allow for organizing a domain model. Conceptually, they correspond to Java's package mechanism.","title":"Namespace Concepts"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateVersion","text":"A namespace concept to organize evolved contents of a domain model in different versions.","title":"Class IntermediateVersion"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateVersion-name","text":"Name of the version. Unique within the same domain model .","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateVersion-complexTypes","text":"Complex types defined directly within the version.","title":"IntermediateComplexType[*] complexTypes"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateVersion-contexts","text":"Contexts encapsulated by the version. Note For the same IntermediateVersion , either the complexTypes or the contexts attribute will contain values but neither both.","title":"IntermediateContext[*] contexts"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateVersion-dataModel","text":"Link to the containing IntermediateDataModel instance.","title":"IntermediateDataModel[1] dataModel"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateContext","text":"A namespace concept to organize domain-specific types of a domain model in semantic domains that may correspond to Bounded Contexts .","title":"Class IntermediateContext"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateContext-name","text":"Name of the context. Unique within the same domain model or version .","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateContext-qualifiedName","text":"Qualified name of the context. The qualified name of the context consists of the name of the version , if any, and the name of the context separated by a dot. In case the context is not part of a version , the qualifiedName equals the context's name . Hint The IntermedateVersion class does not comprise a qualifiedName attribute, because versions may not be contained within an instance of another model concept's class except for the nameless model root .","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateContext-complexTypes","text":"Complex types being defined within the context.","title":"IntermediateComplexType[1..*] complexTypes"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateContext-dataModel","text":"Link to the containing IntermediateDataModel instance.","title":"IntermediateDataModel dataModel"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateContext-version","text":"Link to the containing IntermediateVersion instance. Note Only one of the attributes dataModel or version has a value, depending on whether the context is defined directly under the model root or within a version . Note Contexts may not be nested.","title":"IntermediateVersion version"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#built-in-type-system","text":"This subsection describes concepts that are part of LEMMA's built-in type system provided by the Domain Data Modeling Language. The type system is aligned to Java and contains all built-in Java primitive types as well as the native types date , string , and unspecified . Besides the unspecified type, the type conversions observe Java's widening primitive conversions for primitively typed fields . The unspecified type, however, is not compatible with any other type. More precisely, two distinct fields with the unspecified type are not considered to be compatible. That is, the unspecified type communicates the intended current absence of a type, e.g., to determine that a typing decision has not been taken, yet. Two data structures are compatible, if their fields are compatible, independent of their type ordering. Two distinct enumerations are compatible, if the value-receiving enumeration comprises all initialization values of the value-providing enumeration.","title":"Built-in Type System"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateTypeKind","text":"Enumeration to specify the kind of an IntermediateType instance being referenced in some place.","title":"Enum IntermediateTypeKind"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateTypeKind-COLLECTION","text":"Referenced type is an IntermediateCollectionType .","title":"COLLECTION"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateTypeKind-ENUMERATION","text":"Referenced type is an IntermediateEnumeration .","title":"ENUMERATION"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateTypeKind-PRIMITIVE","text":"Referenced type is an IntermediatePrimitiveType .","title":"PRIMITIVE"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateTypeKind-STRUCTURE","text":"Referenced type is an IntermediateDataStructure .","title":"STRUCTURE"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateTypeOrigin","text":"Enumeration to specify the origin of an IntermediateType instance being referenced in some place.","title":"Enum IntermediateTypeOrigin"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateTypeOrigin-DATA_MODEL","text":"Type is an IntermediateComplexType defined in a domain model.","title":"DATA_MODEL"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateTypeOrigin-BUILTIN","text":"Type is a built-in type.","title":"BUILTIN"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateTypeOrigin-TECHNOLOGY","text":"Type is technology-specific. Technology-specific types may be used to map built-in primitive types to technology-specific types, e.g., float to float32 in the Go programming language . Moreover, they may be used to declare technology-specific structure or collection types. Code generators need to be able to interpret technology-specific types that were defined in a LEMMA technology model. Hint Currently, the following combinations of IntermediateTypeKind and IntermediateTypeOrigin values are possible: Kind Origin COLLECTION DATA_MODEL , TECHNOLOGY ENUMERATION DATA_MODEL PRIMITIVE BUILTIN , TECHNOLOGY STRUCTURE DATA_MODEL , TECHNOLOGY","title":"TECHNOLOGY"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateType","text":"Abstract super class for all types.","title":"Abstract Class IntermediateType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateType-name","text":"Name of the type.","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateType-origin","text":"Origin of the type.","title":"IntermediateTypeOrigin[1] origin"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateType-kind","text":"Kind of the type.","title":"IntermediateTypeKind[1] kind"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateType-dataField","text":"Data field that is typed by this type's instance.","title":"IntermediateDataField[1] dataField"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediatePrimitiveType","text":"Representation of a primitive type being used within the domain model.","title":"Class IntermediatePrimitiveType : IntermediateType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediatePrimitiveType-size","text":"Size of the primitive type in bits. The built-in primitive types have the following sizes: Type Size (in bits) boolean 1 byte 8 char 16 date null (object type) double 64 float 32 int 32 long 64 short 16 string null (object type) unspecified null (communicates type absence)","title":"Integer size"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediatePrimitiveType-initializedDataField","text":"Link to the IntermediateDataField , whose initialization value is compatible with this primitive type.","title":"IntermediateDataField initializedDataField"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediatePrimitiveType-initializedEnumerationField","text":"Link to the IntermediateEnumerationField , whose initialization value is compatible with this primitive type.","title":"IntermediateEnumerationField initializedEnumerationField"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#custom-domain-specific-types","text":"","title":"Custom, Domain-Specific Types"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateComplexType","text":"Super class of complex types like IntermediateDataStructure , IntermediateCollectionType , and IntermediateEnumeration .","title":"Class IntermediateComplexType : IntermediateType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateComplexType-qualifiedName","text":"Qualified name of the type. Corresponds to the name of the type prefixed by its version , if any, and its context , if any. The qualifying fragments are separated by dots.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateComplexType-aspects","text":"The aspects that were assigned to the complex type.","title":"IntermediateImportedAspect[*] aspects"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateComplexType-dataModel","text":"Link to the containing IntermediateDataModel instance.","title":"IntermediateDataModel dataModel"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateComplexType-version","text":"Link to the containing IntermediateVersion instance.","title":"IntermediateVersion version"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateComplexType-context","text":"Link to the containing IntermediateContext instance. Note Only one of the attributes dataModel , version , or context has a value, depending on whether the type is defined directly under the model root , within a version , or within a context .","title":"IntermediateContext context"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateImportedComplexType","text":"This class represents an IntermediateComplexType that has been imported from another domain model.","title":"Class IntermediateImportedComplexType : IntermediateComplexType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImportedComplexType-import","text":"The import from which the complex type originates.","title":"IntermediateImport import"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateDataStructure","text":"A domain-specific data structure that usually comprises a variety of typed fields .","title":"Class IntermediateDataStructure : IntermediateComplexType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataStructure-featureNames","text":"This attribute contains the names of all features specified for the data structure. The following values are possible: Feature Name Description \"AGGREGATE\" Data structure is an Aggregate in the sense of Domain-driven Design (DDD) . \"APPLICATION_SERVICE\" Data structure is a Service with application focus in the sense of DDD. \"DOMAIN_EVENT\" Data structure is a Domain Event in the sense of DDD. \"DOMAIN_SERVICE\" Data structure is a Service with domain focus in the sense of DDD. \"ENTITY\" Data structure is an Entity in the sense of DDD. \"FACTORY\" Data structure is a Factory in the sense of DDD. \"INFRASTRUCTURE_SERVICE\" Data structure is a Service with infrastructure focus in the sense of DDD. \"REPOSITORY\" Data structure is a Repository in the sense of DDD. \"SERVICE\" Data structure is a Service in the sense of DDD. \"SPECIFICATION\" Data structure is a Specification in the sense of DDD. \"VALUE_OBJECT\" Data structure is a Value Object in the sense of DDD. Note DDD-related features should follow the constraints described here . LEMMA's Domain Data Modeling Language currently only issues warnings in case constraints are violated. Model processors are however free to deny functioning and yield errors in case they detect constraint violations.","title":"String[*] featureNames"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataStructure-super","text":"The super data structure from which this data structure inherits. Note LEMMA's Domain Data Modeling Language supports single inheritance only. Furthermore, the super data structure must be defined within the same domain model. It cannot be imported from another domain model.","title":"IntermediateDataStructure super"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataStructure-dataFields","text":"Data fields of the structure. Hint In case the data structure inherits from a super structure, the attribute also contains inherited, non-hidden fields. Inherited fields of a structure can be distinguished from \"local\" fields by means of the IntermediateDataField concept's inherited attribute .","title":"IntermediateDataField[*] dataFields"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataStructure-operations","text":"Operations of the structure. Hint In case the data structure inherits from a super structure, the attribute also contains inherited, non-hidden operations. Inherited operations of a structure can be distinguished from \"local\" operations by means of the IntermediateOperation concept's inherited attribute.","title":"IntermediateDataOperation[*] operations"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateDataOperation","text":"An operation within an IntermediateDataStructure .","title":"Class IntermediateDataOperation"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperation-name","text":"Name of the operation. Unique within the same structure .","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperation-qualifiedName","text":"Qualified name of the operation. Corresponds to the name of the operation prefixed by the qualified name of the defining IntermediateDataStructure . The name fragments are separated by dots.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperation-hidden","text":"Flag to indicate if the operation is hidden. Semantically, this flag corresponds to Java's private accessibility modifier. However, the flag differs in that an inherited operation may also be set to hidden. That is, operations' visibility may be overridden. A hidden operation is not visible in any of the following levels of the inheritance hierarchy.","title":"boolean hidden"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperation-inherited","text":"Flag to indicate if the operation was inherited from a super structure .","title":"boolean inherited"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperation-featureNames","text":"This attribute contains the names of all features specified for the operation. The following values are possible: Feature Name Description \"CLOSURE\" Operation is a Closure in the sense of DDD. \"IDENTIFIER\" Operation acts as identifier for an Entity in the sense of DDD (see also the featureNames attribute of the IntermediateDataStructure concept ). \"SIDE_EFFECT_FREE\" Operation is side-effect-free in the sense of DDD. \"VALIDATOR\" Operation acts as validator for a Specification in the sense of DDD (see also the featureNames attribute of the IntermediateDataStructure concept ). Note DDD-related features should follow the constraints described here . LEMMA's Domain Data Modeling Language currently only issues warnings in case constraints are violated. Model processors are however free to deny functioning and yield errors in case they detect constraint violations.","title":"String[*] featureNames"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperation-returnType","text":"The return type of the operation. This attribute is empty when no return type was specified.","title":"IntermediateDataOperationReturnType returnType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperation-parameters","text":"The parameters of the operation.","title":"IntermediateDataOperationParameter[*] parameters"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperation-aspects","text":"The aspects that were assigned to the operation.","title":"IntermediateImportedAspect[*] aspects"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateDataOperationReturnType","text":"The return type of an IntermediateDataOperation .","title":"Class IntermediateDataOperationReturnType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperationReturnType-type","text":"The return type. Hint The attribute always holds a unique IntermediateType instance , i.e., instances of the same types are not reused. Hint Model processors must use this type as the operation's return type and not the originalType .","title":"IntermediateType[1] type"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperationReturnType-originalType","text":"The original return type of the operation. Hint The attribute always holds a value. In case the value differs from that of the type attribute , the return type got altered in a mapping model and the type attribute attribute holds an instance of the IntermediateImportedTechnologySpecificType concept that identifies the technology-specific type to which the original return type was mapped.","title":"IntermediateType[1] originalType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperationReturnType-aspects","text":"The aspects that were assigned to the return type within a mapping model .","title":"IntermediateImportedAspect[*] aspects"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateDataOperationParameter","text":"A parameter within an IntermediateDataOperation .","title":"Class IntermediateDataOperationParameter"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperationParameter-name","text":"Name of the parameter. Unique within the same operation .","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperationParameter-qualifiedName","text":"Qualified name of the parameter. Corresponds to the name of the parameter prefixed by the qualified name of the defining IntermediateDataOperation . The name fragments are separated by dots.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperationParameter-type","text":"The type of the parameter. Hint The attribute always holds a unique IntermediateType instance , i.e., instances of the same types are not reused. Hint Model processors must use this type as the operation's return type and not the originalType .","title":"IntermediateType[1] type"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperationParameter-originalType","text":"The original type of the parameter. Hint The attribute always holds a value. In case the value differs from that of the type attribute , the type got altered in a mapping model and the type attribute attribute holds an instance of the IntermediateImportedTechnologySpecificType concept that identifies the technology-specific type to which the parameter's original type was mapped.","title":"IntermediateType[1] originalType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataOperationParameter-aspects","text":"The aspects that were assigned to the return type within a mapping model .","title":"IntermediateImportedAspect[*] aspects"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateDataField","text":"A field within an IntermediateDataStructure .","title":"Class IntermediateDataField"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataField-name","text":"Name of the field. Unique within the same structure or collection type .","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataField-qualifiedName","text":"Qualified name of the field. Corresponds to the name of the field prefixed by the qualified name of the defining IntermediateDataStructure . The name fragments are separated by dots.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataField-hidden","text":"Flag to indicate if the field is hidden. Semantically, this flag corresponds to Java's private accessibility modifier. However, the flag differs in that an inherited field may also be set to hidden. That is, fields' visibility may be overridden. A hidden field is not visible in any of the following levels of the inheritance hierarchy.","title":"boolean hidden"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataField-immutable","text":"Flag to indicate whether the field is immutable or not. In Java, for example, an immutable field could correspond to a field that has no public setter.","title":"boolean immutable"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataField-inherited","text":"Flag to indicate if the field was inherited from a super structure .","title":"boolean inherited"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataField-featureNames","text":"This attribute contains the names of all features specified for the field. The following values are possible: Feature Name Description \"IDENTIFIER\" Field acts as identifier for an Entity in the sense of DDD (see also the featureNames attribute of the IntermediateDataStructure concept ). \"NEVER_EMPTY\" Field should never be empty. \"PART\" Field is a part of a DDD Aggregate (see also the featureNames attribute of the IntermediateDataStructure concept ). Note DDD-related features should follow the constraints described here . LEMMA's Domain Data Modeling Language currently only issues warnings in case constraints are violated. Model processors are however free to deny functioning and yield errors in case they detect constraint violations.","title":"String[*] featureNames"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataField-initializationValue","text":"If the field has an initialization value, it is encoded in this attribute. It is guaranteed that the initialization value is compatible to all primitive types in the initializationValueCompatibleTypes attribute. Note Only fields defined in data structures can receive an initialization value. Note A field with the built-in primitive type unspecified cannot receive an initialization value.","title":"String initializationValue"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataField-initializationValueCompatibleTypes","text":"If the field exhibits an initialization value, this attribute comprises all primitive types to which the initialization value is compatible. Note There is no determined order in which the primitive types appear in the attribute.","title":"IntermediatePrimitiveType[*] initializationValueCompatibleTypes"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataField-type","text":"The type of the field. Hint The attribute always holds a unique IntermediateType instance , i.e., instances of the same types are not reused. Hint Model processors must use this type as the field's type and not the originalType .","title":"IntermediateType[1] type"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataField-originalType","text":"The original type of the field. Hint The attribute always holds a value. In case the value differs from that of the type attribute , the type got altered in a mapping model and the type attribute attribute holds an instance of the IntermediateImportedTechnologySpecificType concept that identifies the technology-specific type to which the field's original type was mapped.","title":"IntermediateType[1] originalType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataField-aspects","text":"The aspects that were assigned to the field within a mapping model .","title":"IntermediateImportedAspect[*] aspects"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateDataField-dataStructure","text":"Link to the defining IntermediateDataStructure instance.","title":"IntermediateDataStructure dataStructure"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateCollectionType","text":"A domain-specific collection type.","title":"Class IntermediateCollectionType : IntermediateComplexType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateCollectionType-primitiveCollection","text":"Flag to indicate if this is a collection that contains a sequence of primitive values.","title":"boolean primitiveCollection"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateCollectionType-structuredCollection","text":"Flag to indicate if this collection consists of one or more data fields . Note Exactly one of the flags primitiveCollection or structuredCollection will always be true .","title":"boolean structuredCollection"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateCollectionType-primitiveType","text":"In case the collection is a primitive collection , this attribute contains the IntermediatePrimitiveType instance that identifies the primitive type of the collection's values.","title":"IntermediatePrimitiveType primitiveType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateCollectionType-dataFields","text":"In case the collection is a structured collection , this attribute contains the IntermediateDataStructure instances that prescribe the structure of the collection's values.","title":"IntermediateDataField[*] dataFields"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateEnumeration","text":"A domain-specific enumeration.","title":"Class IntermediateEnumeration : IntermediateComplexType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateEnumeration-featureNames","text":"This attribute contains the names of all features specified for the enumeration. The following values are possible: Feature Name Description \"DOMAIN_EVENT\" Enumeration is a Domain Event in the sense of DDD. \"VALUE_OBJECT\" Enumeration is a Value Object in the sense of DDD. Note DDD-related features should follow the constraints described here . LEMMA's Domain Data Modeling Language currently only issues warnings in case constraints are violated. Model processors are however free to deny functioning and yield errors in case they detect constraint violations.","title":"String[*] featureNames"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateEnumeration-fields","text":"The fields of the enumeration.","title":"IntermediateEnumerationField[1..*] fields"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateEnumerationField","text":"A field of an IntermediateEnumeration .","title":"Class IntermediateEnumerationField"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateEnumerationField-name","text":"Name of the field. Unique within the same enumeration .","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateEnumerationField-qualifiedName","text":"Qualified name of the field. Corresponds to the name of the field prefixed by the qualified name of the defining IntermediateEnumeration . The name fragments are separated by dots.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateEnumerationField-initializationValue","text":"Initialization value of the field. It is guaranteed that the initialization value is compatible to all primitive types in the initializationValueCompatibleTypes attribute.","title":"String initializationValue"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateEnumerationField-initializationValueCompatibleTypes","text":"If the field exhibits an initialization value, this attribute comprises all primitive types to which the initialization value is compatible. Note There is no determined order in which the primitive types appear in the attribute.","title":"IntermediatePrimitiveType[*] initializationValueCompatibleTypes"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateEnumerationField-enumeration","text":"Link to the defining IntermediateEnumeration instance.","title":"IntermediateEnumeration enumeration"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#technologies","text":"In the following, concepts for technology assignment, e.g., to complex types and intermediate concepts for constructs from other modeling languages such as IntermediateMicroservice are described.","title":"Technologies"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateImportedTechnologySpecificType","text":"Intermediate representation of a type defined within a technology model .","title":"Class IntermediateImportedTechnologySpecificType : IntermediateType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImportedTechnologySpecificType-qualifiedName","text":"Qualified name of the type. Consists of the name of the defining technology, the \"_types\" prefix as internal qualifier within the technology model, and the name of the type, separated by dots.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImportedTechnologySpecificType-import","text":"The IntermediateImport instance pointing to the technology model from which the type was imported.","title":"IntermediateImport[1] import"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateImportedAspect","text":"Aspects allow semantic refinement of modeled complex types , operations , their parameters and return types , as well as fields . Next to domain-specific modeling concepts, aspects also target constructs from other LEMMA modeling languages and their intermediate representations, e.g., IntermediateMicroservice and IntermediateOperationNode . Aspects are defined within technology models . An aspect definition might be accompanied with properties and have their applicability constrained to certain peculiarities of concept instances to which they apply. With this mechanism it is possible to create, e.g., aspects for the OR mapping of data structures or the specification of HTTP status codes returned by a microservice operation.","title":"Class IntermediateImportedAspect"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImportedAspect-name","text":"Name of the aspect.","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImportedAspect-qualifiedName","text":"Qualified name of the aspect. Consists of the name of the defining technology, the \"_aspects\" prefix as internal qualifier within the technology model, and the name of the aspect, separated by dots.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImportedAspect-featureNames","text":"This attribute contains the names of all features specified for the aspect. The following values are possible: Feature Name Description \"SINGE_VALUED\" Flag to indicate that an aspect may only be applied once at a target element.","title":"String[*] featureNames"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImportedAspect-import","text":"The IntermediateImport instance pointing to the technology model from which the type was imported.","title":"IntermediateImport[1] import"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImportedAspect-properties","text":"Properties of the aspect as defined in its technology model.","title":"IntermediateAspectProperty[*] properties"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImportedAspect-propertyValues","text":"Values for aspect properties as assigned in the aspect's application within the source model.","title":"IntermediateAspectPropertyValue[*] propertyValues"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImportedAspect-complexType","text":"IntermediateComplexType to which the aspect was applied.","title":"IntermediateComplexType complexType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImportedAspect-operation","text":"IntermediateDataOperation to which the aspect was applied.","title":"IntermediateDataOperation operation"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImportedAspect-parameter","text":"IntermediateDataOperationParameter to which the aspect was applied.","title":"IntermediateDataOperationParameter parameter"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImportedAspect-dataField","text":"IntermediateDataField to which the aspect was applied.","title":"IntermediateDataField dataField"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateImportedAspect-getEffectivePropertyValues","text":"Helper to return the effective property values for an aspect application. The effective property values consist of the default values for the aspect's properties and the property values specific to the aspect's application .","title":"Map&lt;IntermediateAspectProperty, String&gt; getEffectivePropertyValues()"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateAspectProperty","text":"Specification of an aspect property.","title":"Class IntermediateAspectProperty"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateAspectProperty-name","text":"Name of the property. Unique within the same aspect .","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateAspectProperty-type","text":"Name of the property's primitive type . The attribute can receive one of the following values: \"boolean\" \"byte\" \"char\" \"date\" \"double\" \"float\" \"int\" \"long\" \"short\" \"string\" Note A property cannot be of the built-in primitive type unspecified .","title":"String[1] type"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateAspectProperty-defaultValue","text":"This attribute encodes a possible default value of the property. It is guaranteed that this value fits the property's type .","title":"String defaultValue"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateAspectProperty-featureNames","text":"This attribute contains the names of all features specified for the property. The following values are possible: Feature Name Description \"MANDATORY\" Flag to indicate that the property needs to receive a value. It is guaranteed that all mandatory properties receive a value during the application of the respective aspect . \"SINGE_VALUED\" Flag to indicate that a property may only receive a value once. It is guaranteed that all single-valued properties receive at most one value during the application of the respective aspect .","title":"String[*] featureNames"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateAspectProperty-aspect","text":"The aspect to which the property belongs.","title":"IntermediateImportedAspect aspect"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#concept-IntermediateAspectPropertyValue","text":"Value of an IntermediateAspectProperty .","title":"Class IntermediateAspectPropertyValue"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateAspectPropertyValue-value","text":"The value encoded as a String.","title":"String[1] value"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateAspectPropertyValue-property","text":"The aspect property for which the value was specified.","title":"IntermediateAspectProperty[1] property"},{"location":"developer-guide/intermediate-model-specifications/intermediate-domain-model-specification/#attribute-IntermediateAspectPropertyValue-aspect","text":"The aspect application to which the property value belongs.","title":"IntermediateImportedAspect aspect"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/","text":"Intermediate Operation Model Specification This page specifies the structure and semantics of the intermediate metamodel for LEMMA operation models . All obtained intermediate LEMMA operation models must conform to this metamodel to ensure consistent behavior of LEMMA model processors . The following figure shows the metamodel's structure: Structure of the metamodel for intermediate operation models The source code of the metamodel specification can be found at https://github.com/SeelabFhdo/lemma/blob/main/de.fhdo.lemma.operation.intermediate.metamodel/model/IntermediateOperationModel.xcore . Each of the following sections describes certain concepts of the metamodel. Note Attributes that may contain more than one value but exhibit a * multiplicity, i.e., they may contain an arbitrary number of values or even none at all ( * is shorthand UML notation for 0..* ), are never null. In case no multiplicity is stated after the object type of an attribute, the attribute may be null. For example, an attribute defined as String name implicitly has a multiplicity 0..1 and in the zero-case the String may be null. However, in case the attribute's type is a built-in primitive Java type, e.g. int , the attribute will never be null but exhibits the type's default value in case it did not receive an explicit value. Model Root Class IntermediateOperationModel Root of an intermediate operation model. String[1] sourceModelUri file:// URI pointing to the source operation model file from which this intermediate operation model was derived. Note Model processors must not depend on this URI being absolute or relative. Both cases may occur in practice and are up to the modeler. IntermediateImport[*] imports References to imported technology models , intermediate operation models, or intermediate service models . IntermediateContainer[*] containers Containers defined in the operation model. IntermediateInfrastructureNode[*] infrastructureNodes Infrastructure nodes defined in the operation model. Note Operation models must not be empty. Consequently, at least one of the attributes containers or infrastructureNodes is never empty. Operation Nodes Abstract Class IntermediateOperationNode Super class of IntermediateContainer and IntermediateInfrastructureNode . String[1] name Name of the operation node. Unique within the same operation model . IntermediateImport[1..*] imports References to imported technology models . IntermediateOperationEnvironment[1] operationEnvironment The node's operation environment. OperationMicroserviceReference[*] deployedServices References to the microservices that are associated with the node. Note In case the concrete instance of the node is an IntermediateInfrastructureNode and despite its name, the attribute identifies the microservices that use the node. IntermediateEndpoint[1..*] endpoints Endpoints specified for the node. IntermediateServiceDeploymentSpecification[*] specifications Deployment specifications for services that are associated with the node . IntermediateTechnologySpecificPropertyValue[*] defaultValues Default values for technology-specific configuration properties. In general, these values account for all services that are associated with the node . Hint The getEffectiveConfigurationValues method allows the retrieval of the effective configuration values of a given associated service. IntermediateImportedAspect[*] aspects Aspects of the operation node. IntermediateTechnologySpecificPropertyValue[*] getEffectiveConfigurationValues ( OperationMicroserviceReference service ) Helper to return the effective configuration values of the operation node for the given OperationMicroserviceReference . The effective configuration values consist of the default values for the technology-specific properties on the node and the property values specific to the service's deployment . Hint Service-specific property values overwrite default values. Class IntermediateOperationEndpoint : IntermediateEndpoint Intermediate representation of an endpoint on an operation node . This representation extends the IntermediateEndpoint concept from the intermediate service model specification by the endpoint's technology. IntermediateEndpointTechnology[1] endpointTechnology Technology of the endpoint. IntermediateOperationNode[1] node Operation node for which the endpoint was specified. Class IntermediateEndpointTechnology : IntermediateTechnology Intermediate representation of the technology of an operation node's endpoint . This representation extends the IntermediateTechnology concept from the intermediate service model specification to make the technology information on operation node endpoints specific to operation models. IntermediateOperationEndpoint[1] endpoint The endpoint to which this technology was assigned. Class IntermediateTechnologySpecificPropertyValue Represents the value of a technology-specific property . String[1] value The property's value. Hint The value is represented as a string but is always compatible to the property's type . IntermediateTechnologySpecificProperty[1] technologySpecificProperty The property for which the value was specified. IntermediateServiceDeploymentSpecification specification The service deployment specification that this value configures. IntermediateOperationNode operationNode The operation node that this value configures. Class IntermediateContainer : IntermediateOperationNode This concept reifies a container as a certain kind of operation node. String qualifiedDeploymentTechnologyName Qualified name of the container's deployment technology. IntermediateDeploymentTechnologyReference[1] technologyReference Reference to the container's deployment technology. IntermediateOperationModel[1] operationModel The container's defining operation model. IntermediateOperationNodeReference[*] dependsOnNodes Dependencies of a container on other nodes, e.g., databases or service discoveries required by deployed microservices . IntermediateOperationNodeReference[*] usedByNodes Usage relationships of a container to other nodes that make use of the container's infrastructure-related capabilities. Note The attribute models the dependency of another node on a container. The dependsOnNodes attribute takes the opposite perspective and reflects the dependency of a container on another node. Class IntermediateInfrastructureNode : IntermediateOperationNode This concept reifies an infrastructure node as a certain kind of operation node. String qualifiedInfrastructureTechnologyName Qualified name of the infrastructure node's technology. IntermediateInfrastructureTechnologyReference[1] reference Reference to the infrastructure node's technology. IntermediateOperationModel[1] operationModel The infrastructure node's defining operation model. IntermediateOperationNodeReference[*] dependsOnNodes Dependencies of an infrastructure node on other nodes, e.g., databases or service discoveries required for the node's intended infrastructure capability. IntermediateOperationNodeReference[*] usedByNodes Usage relationships of an infrastructure node to other nodes that make use of the node's infrastructure-related capabilities. Note The attribute models the dependency of another node on an infrastructure node. The dependsOnNodes attribute takes the opposite perspective and reflects the dependency of an infrastructure node on another node. Class IntermediateOperationNodeReference A reference to an operation node . String[1] name Name of the referenced operation node. boolean imported This flag indicates whether the operation node reference originates from another operation model or is located in the same operation model where it occurs. IntermediateImport import In case the operation node is imported , this attribute points to the import of the operation model that defines the node. String[1] qualifiedTechnologyName Name of the referenced operation node's technology. IntermediateOperationNode dependsOnNode Link to the operation node that depends on the referenced operation node. Hint The attribute only receives a value in case the linked operation node is local and not imported from another operation model. IntermediateOperationNode usedByNode Link to the operation node that uses the referenced operation node. Hint The attribute only receives a value in case the linked operation node is local and not imported from another operation model. Operation Technologies Abstract Class IntermediateOperationTechnology Super class for operation technologies. String[1] name Name of the operation technology. IntermediateOperationEnvironment[1] environment The technology's operation environment. IntermediateTechnologySpecificProperty[*] properties Technology-specific properties provided by the operation technology. Class IntermediateOperationEnvironment The operation environment of a certain operation technology. Operation environments may refer to technology that is mandatory to execute modeled operation nodes. For example, an operation environment may explicitly determine the version of the used operation technology. String[1] environmentName Name of the operation environment. boolean default Flag to indicate whether this is the default operation environment of an operation technology. IntermediateOperationTechnology[1] operationTechnology The operation technology to which this environment belongs. Class IntermediateTechnologySpecificProperty A property of a certain operation technology. String[1] name The name of the property. String[1] type The name of the property's primitive type . The following values are possible: \"boolean\" \"byte\" \"char\" \"date\" \"double\" \"float\" \"int\" \"long\" \"short\" \"string\" Note A property cannot be of the built-in primitive type unspecified . String defaultValue This attribute encodes the possible default value of the property. it is guaranteed that the default value fits the property's type . String[*] featureNames This attribute contains the names of all features specified for the property. The following values are possible: Feature Name Description \"MANDATORY\" Flag to indicate that the property needs to receive a value. It is guaranteed that all mandatory properties receive a value. \"SINGE_VALUED\" Flag to indicate that a property may only receive a value once. It is guaranteed that all single-valued properties receive at most one value. IntermediateOperationTechnology operationTechnology The operation technology to which the property belongs. Class IntermediateDeploymentTechnology : IntermediateOperationTechnology A concrete operation technology that represents a deployment technology. IntermediateDeploymentTechnologyReference[1] reference The technology reference that points to this deployment technology. Class IntermediateDeploymentTechnologyReference A reference to a deployment technology. IntermediateImport[1] import The import of the technology model, which defines the referenced deployment technology. IntermediateDeploymentTechnology[1] technology The referenced deployment technology. IntermediateContainer[1] container The container that uses the deployment technology. Class IntermediateInfrastructureTechnology : IntermediateOperationTechnology A concrete operation technology that represents an infrastructure technology. IntermediateInfrastructureTechnologyReference[1] reference The technology reference that points to this infrastructure technology. Class IntermediateInfrastructureTechnologyReference A reference to an infrastructure technology. IntermediateImport[1] import The import of the technology model, which defines the referenced infrastructure technology. IntermediateInfrastructureTechnology[1] technology The referenced infrastructure technology. IntermediateInfrastructureNode[1] container The infrastructure node that uses the infrastructure technology. Service Deployment Specifications Class IntermediateServiceDeploymentSpecification Specification of a microservice's deployment/usage of an operation node. OperationMicroserviceReference[1] operationMicroserviceReference The microservice targeted by the specification. IntermediateOperationEndpoint[*] endpoints Endpoints specified for the microservice. IntermediateTechnologySpecificPropertyValue[*] propertyValues Configuration values specific to the microservice. IntermediateOperationNode[1] operationNode The operation node to which the microservice is assigned. Class OperationMicroserviceReference : MicroserviceReference Reference to a microservice imported from an intermediate service model . The concept extends the MicroserviceReference concept from the intermediate service model specification and adds operation-related information. boolean effectivelyImplemented The value of the attribute corresponds to that of the effectivelyImplemented flag of the referenced microservice. String[1] microserviceType The value of the attribute corresponds to that of the type attribute of the referenced microservice. String[1] visibility The value of the attribute corresponds to that of the visibility attribute of the referenced microservice. IntermediateOperationNode[1] node The operation node to which the referenced microservice is deployed or that is used by the microservice.","title":"Intermediate Operation Model Specification"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#intermediate-operation-model-specification","text":"This page specifies the structure and semantics of the intermediate metamodel for LEMMA operation models . All obtained intermediate LEMMA operation models must conform to this metamodel to ensure consistent behavior of LEMMA model processors . The following figure shows the metamodel's structure: Structure of the metamodel for intermediate operation models The source code of the metamodel specification can be found at https://github.com/SeelabFhdo/lemma/blob/main/de.fhdo.lemma.operation.intermediate.metamodel/model/IntermediateOperationModel.xcore . Each of the following sections describes certain concepts of the metamodel. Note Attributes that may contain more than one value but exhibit a * multiplicity, i.e., they may contain an arbitrary number of values or even none at all ( * is shorthand UML notation for 0..* ), are never null. In case no multiplicity is stated after the object type of an attribute, the attribute may be null. For example, an attribute defined as String name implicitly has a multiplicity 0..1 and in the zero-case the String may be null. However, in case the attribute's type is a built-in primitive Java type, e.g. int , the attribute will never be null but exhibits the type's default value in case it did not receive an explicit value.","title":"Intermediate Operation Model Specification"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#model-root","text":"","title":"Model Root"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateOperationModel","text":"Root of an intermediate operation model.","title":"Class IntermediateOperationModel"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationModel-sourceModelUri","text":"file:// URI pointing to the source operation model file from which this intermediate operation model was derived. Note Model processors must not depend on this URI being absolute or relative. Both cases may occur in practice and are up to the modeler.","title":"String[1] sourceModelUri"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationModel-imports","text":"References to imported technology models , intermediate operation models, or intermediate service models .","title":"IntermediateImport[*] imports"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationModel-containers","text":"Containers defined in the operation model.","title":"IntermediateContainer[*] containers"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationModel-infrastructureNodes","text":"Infrastructure nodes defined in the operation model. Note Operation models must not be empty. Consequently, at least one of the attributes containers or infrastructureNodes is never empty.","title":"IntermediateInfrastructureNode[*] infrastructureNodes"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#operation-nodes","text":"","title":"Operation Nodes"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateOperationNode","text":"Super class of IntermediateContainer and IntermediateInfrastructureNode .","title":"Abstract Class IntermediateOperationNode"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNode-name","text":"Name of the operation node. Unique within the same operation model .","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNode-imports","text":"References to imported technology models .","title":"IntermediateImport[1..*] imports"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNode-operationEnvironment","text":"The node's operation environment.","title":"IntermediateOperationEnvironment[1] operationEnvironment"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNode-deployedServices","text":"References to the microservices that are associated with the node. Note In case the concrete instance of the node is an IntermediateInfrastructureNode and despite its name, the attribute identifies the microservices that use the node.","title":"OperationMicroserviceReference[*] deployedServices"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNode-endpoints","text":"Endpoints specified for the node.","title":"IntermediateEndpoint[1..*] endpoints"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNode-specifications","text":"Deployment specifications for services that are associated with the node .","title":"IntermediateServiceDeploymentSpecification[*] specifications"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNode-defaultValues","text":"Default values for technology-specific configuration properties. In general, these values account for all services that are associated with the node . Hint The getEffectiveConfigurationValues method allows the retrieval of the effective configuration values of a given associated service.","title":"IntermediateTechnologySpecificPropertyValue[*] defaultValues"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNode-aspects","text":"Aspects of the operation node.","title":"IntermediateImportedAspect[*] aspects"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNode-getEffectiveConfigurationValues","text":"Helper to return the effective configuration values of the operation node for the given OperationMicroserviceReference . The effective configuration values consist of the default values for the technology-specific properties on the node and the property values specific to the service's deployment . Hint Service-specific property values overwrite default values.","title":"IntermediateTechnologySpecificPropertyValue[*] getEffectiveConfigurationValues(OperationMicroserviceReference service)"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateOperationEndpoint","text":"Intermediate representation of an endpoint on an operation node . This representation extends the IntermediateEndpoint concept from the intermediate service model specification by the endpoint's technology.","title":"Class IntermediateOperationEndpoint : IntermediateEndpoint"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationEndpoint-endpointTechnology","text":"Technology of the endpoint.","title":"IntermediateEndpointTechnology[1] endpointTechnology"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationEndpoint-node","text":"Operation node for which the endpoint was specified.","title":"IntermediateOperationNode[1] node"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateEndpointTechnology","text":"Intermediate representation of the technology of an operation node's endpoint . This representation extends the IntermediateTechnology concept from the intermediate service model specification to make the technology information on operation node endpoints specific to operation models.","title":"Class IntermediateEndpointTechnology : IntermediateTechnology"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateEndpointTechnology-endpoint","text":"The endpoint to which this technology was assigned.","title":"IntermediateOperationEndpoint[1] endpoint"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateTechnologySpecificPropertyValue","text":"Represents the value of a technology-specific property .","title":"Class IntermediateTechnologySpecificPropertyValue"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateTechnologySpecificPropertyValue-value","text":"The property's value. Hint The value is represented as a string but is always compatible to the property's type .","title":"String[1] value"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateTechnologySpecificPropertyValue-technologySpecificProperty","text":"The property for which the value was specified.","title":"IntermediateTechnologySpecificProperty[1] technologySpecificProperty"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateTechnologySpecificPropertyValue-specification","text":"The service deployment specification that this value configures.","title":"IntermediateServiceDeploymentSpecification specification"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateTechnologySpecificPropertyValue-operationNode","text":"The operation node that this value configures.","title":"IntermediateOperationNode operationNode"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateContainer","text":"This concept reifies a container as a certain kind of operation node.","title":"Class IntermediateContainer : IntermediateOperationNode"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateContainer-qualifiedDeploymentTechnologyName","text":"Qualified name of the container's deployment technology.","title":"String qualifiedDeploymentTechnologyName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateContainer-technologyReference","text":"Reference to the container's deployment technology.","title":"IntermediateDeploymentTechnologyReference[1] technologyReference"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateContainer-operationModel","text":"The container's defining operation model.","title":"IntermediateOperationModel[1] operationModel"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateContainer-dependsOnNodes","text":"Dependencies of a container on other nodes, e.g., databases or service discoveries required by deployed microservices .","title":"IntermediateOperationNodeReference[*] dependsOnNodes"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateContainer-usedByNodes","text":"Usage relationships of a container to other nodes that make use of the container's infrastructure-related capabilities. Note The attribute models the dependency of another node on a container. The dependsOnNodes attribute takes the opposite perspective and reflects the dependency of a container on another node.","title":"IntermediateOperationNodeReference[*] usedByNodes"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateInfrastructureNode","text":"This concept reifies an infrastructure node as a certain kind of operation node.","title":"Class IntermediateInfrastructureNode : IntermediateOperationNode"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateInfrastructureNode-qualifiedInfrastructureTechnologyName","text":"Qualified name of the infrastructure node's technology.","title":"String qualifiedInfrastructureTechnologyName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateInfrastructureNode-reference","text":"Reference to the infrastructure node's technology.","title":"IntermediateInfrastructureTechnologyReference[1] reference"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateInfrastructureNode-operationModel","text":"The infrastructure node's defining operation model.","title":"IntermediateOperationModel[1] operationModel"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateInfrastructureNode-dependsOnNodes","text":"Dependencies of an infrastructure node on other nodes, e.g., databases or service discoveries required for the node's intended infrastructure capability.","title":"IntermediateOperationNodeReference[*] dependsOnNodes"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateInfrastructureNode-usedByNodes","text":"Usage relationships of an infrastructure node to other nodes that make use of the node's infrastructure-related capabilities. Note The attribute models the dependency of another node on an infrastructure node. The dependsOnNodes attribute takes the opposite perspective and reflects the dependency of an infrastructure node on another node.","title":"IntermediateOperationNodeReference[*] usedByNodes"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateOperationNodeReference","text":"A reference to an operation node .","title":"Class IntermediateOperationNodeReference"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNodeReference-name","text":"Name of the referenced operation node.","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNodeReference-imported","text":"This flag indicates whether the operation node reference originates from another operation model or is located in the same operation model where it occurs.","title":"boolean imported"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNodeReference-import","text":"In case the operation node is imported , this attribute points to the import of the operation model that defines the node.","title":"IntermediateImport import"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNodeReference-qualifiedTechnologyName","text":"Name of the referenced operation node's technology.","title":"String[1] qualifiedTechnologyName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNodeReference-dependsOnNode","text":"Link to the operation node that depends on the referenced operation node. Hint The attribute only receives a value in case the linked operation node is local and not imported from another operation model.","title":"IntermediateOperationNode dependsOnNode"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationNodeReference-usedByNode","text":"Link to the operation node that uses the referenced operation node. Hint The attribute only receives a value in case the linked operation node is local and not imported from another operation model.","title":"IntermediateOperationNode usedByNode"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#operation-technologies","text":"","title":"Operation Technologies"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateOperationTechnology","text":"Super class for operation technologies.","title":"Abstract Class IntermediateOperationTechnology"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationTechnology-name","text":"Name of the operation technology.","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationTechnology-environment","text":"The technology's operation environment.","title":"IntermediateOperationEnvironment[1] environment"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationTechnology-properties","text":"Technology-specific properties provided by the operation technology.","title":"IntermediateTechnologySpecificProperty[*] properties"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateOperationEnvironment","text":"The operation environment of a certain operation technology. Operation environments may refer to technology that is mandatory to execute modeled operation nodes. For example, an operation environment may explicitly determine the version of the used operation technology.","title":"Class IntermediateOperationEnvironment"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationEnvironment-environmentName","text":"Name of the operation environment.","title":"String[1] environmentName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationEnvironment-default","text":"Flag to indicate whether this is the default operation environment of an operation technology.","title":"boolean default"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateOperationEnvironment-operationTechnology","text":"The operation technology to which this environment belongs.","title":"IntermediateOperationTechnology[1] operationTechnology"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateTechnologySpecificProperty","text":"A property of a certain operation technology.","title":"Class IntermediateTechnologySpecificProperty"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateTechnologySpecificProperty-name","text":"The name of the property.","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateTechnologySpecificProperty-type","text":"The name of the property's primitive type . The following values are possible: \"boolean\" \"byte\" \"char\" \"date\" \"double\" \"float\" \"int\" \"long\" \"short\" \"string\" Note A property cannot be of the built-in primitive type unspecified .","title":"String[1] type"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateTechnologySpecificProperty-defaultValue","text":"This attribute encodes the possible default value of the property. it is guaranteed that the default value fits the property's type .","title":"String defaultValue"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateTechnologySpecificProperty-featureNames","text":"This attribute contains the names of all features specified for the property. The following values are possible: Feature Name Description \"MANDATORY\" Flag to indicate that the property needs to receive a value. It is guaranteed that all mandatory properties receive a value. \"SINGE_VALUED\" Flag to indicate that a property may only receive a value once. It is guaranteed that all single-valued properties receive at most one value.","title":"String[*] featureNames"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateTechnologySpecificProperty-operationTechnology","text":"The operation technology to which the property belongs.","title":"IntermediateOperationTechnology operationTechnology"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateDeploymentTechnology","text":"A concrete operation technology that represents a deployment technology.","title":"Class IntermediateDeploymentTechnology : IntermediateOperationTechnology"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateDeploymentTechnology-reference","text":"The technology reference that points to this deployment technology.","title":"IntermediateDeploymentTechnologyReference[1] reference"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateDeploymentTechnologyReference","text":"A reference to a deployment technology.","title":"Class IntermediateDeploymentTechnologyReference"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateDeploymentTechnologyReference-import","text":"The import of the technology model, which defines the referenced deployment technology.","title":"IntermediateImport[1] import"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateDeploymentTechnologyReference-technology","text":"The referenced deployment technology.","title":"IntermediateDeploymentTechnology[1] technology"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateDeploymentTechnologyReference-container","text":"The container that uses the deployment technology.","title":"IntermediateContainer[1] container"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateInfrastructureTechnology","text":"A concrete operation technology that represents an infrastructure technology.","title":"Class IntermediateInfrastructureTechnology : IntermediateOperationTechnology"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateInfrastructureTechnology-reference","text":"The technology reference that points to this infrastructure technology.","title":"IntermediateInfrastructureTechnologyReference[1] reference"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateInfrastructureTechnologyReference","text":"A reference to an infrastructure technology.","title":"Class IntermediateInfrastructureTechnologyReference"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateInfrastructureTechnologyReference-import","text":"The import of the technology model, which defines the referenced infrastructure technology.","title":"IntermediateImport[1] import"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateInfrastructureTechnologyReference-technology","text":"The referenced infrastructure technology.","title":"IntermediateInfrastructureTechnology[1] technology"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateInfrastructureTechnologyReference-container","text":"The infrastructure node that uses the infrastructure technology.","title":"IntermediateInfrastructureNode[1] container"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#service-deployment-specifications","text":"","title":"Service Deployment Specifications"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-IntermediateServiceDeploymentSpecification","text":"Specification of a microservice's deployment/usage of an operation node.","title":"Class IntermediateServiceDeploymentSpecification"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateServiceDeploymentSpecification-operationMicroserviceReference","text":"The microservice targeted by the specification.","title":"OperationMicroserviceReference[1] operationMicroserviceReference"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateServiceDeploymentSpecification-endpoints","text":"Endpoints specified for the microservice.","title":"IntermediateOperationEndpoint[*] endpoints"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateServiceDeploymentSpecification-propertyValues","text":"Configuration values specific to the microservice.","title":"IntermediateTechnologySpecificPropertyValue[*] propertyValues"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-IntermediateServiceDeploymentSpecification-operationNode","text":"The operation node to which the microservice is assigned.","title":"IntermediateOperationNode[1] operationNode"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#concept-OperationMicroserviceReference","text":"Reference to a microservice imported from an intermediate service model . The concept extends the MicroserviceReference concept from the intermediate service model specification and adds operation-related information.","title":"Class OperationMicroserviceReference : MicroserviceReference"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-OperationMicroserviceReference-effectivelyImplemented","text":"The value of the attribute corresponds to that of the effectivelyImplemented flag of the referenced microservice.","title":"boolean effectivelyImplemented"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-OperationMicroserviceReference-microserviceType","text":"The value of the attribute corresponds to that of the type attribute of the referenced microservice.","title":"String[1] microserviceType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-OperationMicroserviceReference-visibility","text":"The value of the attribute corresponds to that of the visibility attribute of the referenced microservice.","title":"String[1] visibility"},{"location":"developer-guide/intermediate-model-specifications/intermediate-operation-model-specification/#attribute-OperationMicroserviceReference-node","text":"The operation node to which the referenced microservice is deployed or that is used by the microservice.","title":"IntermediateOperationNode[1] node"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/","text":"Intermediate Service Model Specification This page specifies the structure and semantics of the intermediate metamodel for LEMMA service models . All obtained intermediate LEMMA service models must conform to this metamodel to ensure consistent behavior of LEMMA model processors . The following figure shows the metamodel's structure: Structure of the metamodel for intermediate service models The source code of the metamodel specification can be found at https://github.com/SeelabFhdo/lemma/blob/main/de.fhdo.lemma.service.intermediate.metamodel/model/IntermediateServiceModel.xcore . Each of the following sections describes certain concepts of the metamodel. Note Attributes that may contain more than one value but exhibit a * multiplicity, i.e., they may contain an arbitrary number of values or even none at all ( * is shorthand UML notation for 0..* ), are never null. In case no multiplicity is stated after the object type of an attribute, the attribute may be null. For example, an attribute defined as String name implicitly has a multiplicity 0..1 and in the zero-case the String may be null. However, in case the attribute's type is a built-in primitive Java type, e.g. int , the attribute will never be null but exhibits the type's default value in case it did not receive an explicit value. Model Root Class IntermediateServiceModel Root of an intermediate service model. String[1] sourceModelUri file:// URI pointing to the source service model file from which this intermediate service model was derived. Note Model processors must not depend on this URI being absolute or relative. Both cases may occur in practice and are up to the modeler. IntermediateImport[*] imports References to imported technology models , intermediate domain models , or intermediate service models. IntermediateMicroservice[1..*] microservices Microservices defined in the service model. Microservices Class IntermediateMicroservice A modeled microservice. String[1] sourceModelUri file:// URI pointing to the source service model file from which this microservice originates. Note Model processors must not depend on this URI being absolute or relative. Both cases may occur in practice and are up to the modeler. String[1] name Name of the microservice. Unique within the same service model . String version Optional version of the service. String[1] qualifiedName Qualified name of the service. Consists of the service's name prefixed by its version , if any. Both name fragments are separated by dots. String[1] type Type of the microservice. The following values are possible: Type Description \"FUNCTIONAL\" A functional microservice realizes the business functions of a microservice architecture. \"INFRASTRUCTURE\" Infrastructure microservices provide the architecture with capabilities that are not related to business but technical functions. Examples of such functions comprise database lookups or integration of legacy systems. \"UTILITY\" Teams may realize utility microservices to implement reusable, business-related helper functions, e.g., for currency conversion. String[1] visibility Visibility of the microservice. The following values are possible: Visibility Description \"INTERNAL\" Service must only be visible to the services of the same team. \"ARCHITECTURE\" Service must only be visible to the services of the same architecture, but not to external consumers. \"PUBLIC\" Service must be visible to all services of the same architecture and also to external consumers. boolean effectivelyImplemented Flag to indicate if the microservice has at least one operation that is not marked as being not implemented (either directly or transitively via its defining interface . Hint Model processors should consider to also handle not (yet) implemented microservices. Code generators, for example, might produce code that returns failures upon invocation of non-implemented service capabilities. IntermediateTechnology[*] technologies Technologies assigned to the microservice. Hint There can only be one technology that defines default primitive types . Moreover, it is guaranteed that default protocol/data format combinations are unambiguous. For instance, there can only be one default synchronous protocol across all referenced technologies. Note In case no fitting technologies are specified for a microservice, model processors are free to omit processing steps if they cover only specific technologies. IntermediateEndpoint[*] endpoints Endpoints specified for the microservice. Hint If no endpoints were modeled for the microservice's (default) protocol specifications , the addresses attribute of the IntermediateEndpoint instance will be empty. Hint If no endpoints were specified or could be determined from (default) protocol specifications , or in case the addresses attribute is empty, model processors may assume sensible defaults. IntermediateProtocolSpecification[0..2] protocols Protocol specifications of the microservice. There might be at most one protocol specification per communication type (synchronous or asynchronous). Hint If the service has no protocol specifications, code generators may produce sensible defaults, e.g., from the microservice's name. Note In case the microservice had no protocols assigned in the source service model, the default protocols of the missing communication types are taken from the service's technologies , if any. That is, the attribute will only be empty if the microservice had no protocol-defining technology assigned. MicroserviceReference[*] requiredMicroservices References to required microservices. InterfaceReference[*] requiredInterfaces References to required interfaces. OperationReference[*] requiredOperations References to required operations. IntermediateImportedAspect[*] aspects Aspects of the microservice. IntermediateServiceModel serviceModel Link to the defining IntermediateServiceModel instance. Class IntermediateInterface This class represents an interface of an IntermediateMicroservice . String[1] name Name of the interface. Unique within the same microservice . String version Optional version of the interface. String[1] qualifiedName Qualified name of the interface. Consists of the defining microservice's qualified name , and the interface's version and name. All name fragments are separated by dots. String[1] visibility Visibility of the interface. The following values are possible: Visibility Description \"INTERNAL\" Interface must only be visible to the services of the same team. \"IN_MODEL\" Interface must only be visible to the services within the same service model file. \"ARCHITECTURE\" Interface must only be visible to the services of the same architecture, but not to external consumers. \"PUBLIC\" Interface must be visible to all services of the same architecture and also to external consumers. boolean notImplemented Flag to indicate if the interface was marked as being not implemented. Hint Model processors should consider to also handle not (yet) implemented interfaces. Code generators, for example, might produce code that returns failures upon invocation of non-implemented service capabilities. boolean hasImplementedOperations Flag to indicate if the interface has at least one operation that is not marked as being not implemented. Hint Model processors should consider to also handle not (yet) implemented interfaces. Code generators, for example, might produce code that returns failures upon invocation of non-implemented service capabilities. Note The notImplemented and hasImplementedOperations flags are independent of each other. The former is set by the modeler, while the latter is derived from the corresponding flags of the interface's operations . IntermediateEndpoint[*] endpoints Endpoints specified for the interface. Hint If no endpoints were modeled for the interface's (default) protocol specifications , the addresses attribute of the IntermediateEndpoint instance will be empty. Hint If no endpoints were specified or could be determined from (default) protocol specifications , or in case the addresses attribute is empty, model processors may assume sensible defaults. IntermediateProtocolSpecification[0..2] protocols Protocol specifications of the interface. There might be at most one protocol specification per communication type (synchronous or asynchronous). Hint If no protocols were explicitly specified for the interface, it \"inherits\" the specifications of its microservice . In case the service does also not exhibit protocol specifications, model processors should assume sensible defaults. Note In case the microservice had no protocols assigned in the source service model, the default protocols of the missing communication types are taken from the service's technologies , if any. That is, the attribute will only be empty if the microservice had no protocol-defining technology assigned. IntermediateOperation[*] operations Operations of the interface. IntermediateReferredOperation[*] referredOperations Referred operations of the interface. Note An interface defines at least one operation or refers to an existing operation, i.e., at least one of the attributes operations and [ referredOperations ] is not empty. IntermediateImportedAspectconcept-[*] aspects Aspects of the interface. IntermediateMicroservice microservice Link to the defining IntermediateMicroservice instance. Class IntermediateOperation This class represents an operation of an IntermediateInterface . String[1] name Name of the operation. Unique within the same interface . String[1] qualifiedName Qualified name of the operation. Consists of the operation's name prefixed by its interface's qualified name . Both name fragments are separated by dots. String[1] visibility Visibility of the microservice. The following values are possible: Visibility Description \"INTERNAL\" Operation must only be visible to the services of the same team. \"IN_MODEL\" Operation must only be visible to the services within the same service model file. \"ARCHITECTURE\" Operation must only be visible to the services of the same architecture, but not to external consumers. \"PUBLIC\" Operation must be visible to all services of the same architecture and also to external consumers. boolean notImplemented Flag to indicate if the operation was marked as being not implemented. Hint Model processors should consider to also handle not (yet) implemented operations. Code generators, for example, might produce code that returns failures upon invocation of non-implemented service capabilities. IntermediateEndpoint[*] endpoints Endpoints specified for the interface. Hint If no endpoints were modeled for the operation's (default) protocol specifications , the addresses attribute of the IntermediateEndpoint instance will be empty. Hint If no endpoints were specified or could be determined from (default) protocol specifications , or in case the addresses attribute is empty, model processors may assume sensible defaults. IntermediateProtocolSpecification[0..2] protocols Protocol specifications of the operation. There might be at most one protocol specification per communication type (synchronous or asynchronous). Hint If no protocols were explicitly specified for the operation, it \"inherits\" the specifications of its interface . In case the interface does also not exhibit protocol specifications, model processors should assume sensible defaults. IntermediateParameter[*] parameters The operation's parameters. Hint There might be more than one outgoing parameter and it is up to model processors on how to interpret such circumstances. For example, a code generator might represent all outgoing parameters as fields of a uniforming data structure. IntermediateApiOperationComment[0..1] apiOperationComment API comment of the operation. IntermediateImportedAspect[*] aspects Aspects of the operation. IntermediateInterface interface Link to the defining IntermediateInterface instance. Class IntermediateApiOperationComment This concept represents an API-related comment of a microservice operation . Such comments shall describe the purpose of a microservice operation, possibly including its parameters (cf. the IntermediateApiParameterComment concept). String[1] comment Comment content. IntermediateApiParameterComment[*] parameterComments API comments for the operation's parameters. Hint It is possible that a parameter is commented more than once. It is up to model processors how they treat such a situation. For instance, a code generator might ignore all comments except for the last one. IntermediateOperation operation The operation documented by this comment. Class IntermediateApiParameterComment This concept represents an API-related comment of a microservice operation parameter . String[1] comment Comment content. boolean required Flag to indicate if this parameter is required by the described API. Note It is possible to even document parameters that were modeled optional as required. boolean returned Flag to indicate if this parameter is returned by the described API. IntermediateParameter parameter The parameter documented by this comment. IntermediateApiOperationComment operationComment The API operation comment to which this parameter comment belongs. Class IntermediateParameter A microservice operation parameter. String[1] name Name of the parameter. Unique within the same operation . String[1] qualifiedName Qualified name of the parameter. Consists of the parameter's name prefixed by its operation's qualified name . Both name fragments are separated by dots. String[1] exchangePattern Exchange pattern of the parameter. The following values are possible: Pattern Description \"IN\" Incoming information exchange. \"OUT\" Outgoing information exchange. \"INOUT\" Incoming and outgoing information exchange. String[1] communicationType Communication type of the parameter. The following values are possible: Type Description \"ASYNCHRONOUS\" Asynchronous communication. \"SYNCHRONOUS\" Synchronous communication. boolean communicatesFault Flag to indicate that the parameter communicates failure values to the caller. Note If necessary, it is up to model processors to ensure that callers are aware of the parameter communicating failure values. boolean optional Flag to indicate that the parameter is optional. Note The combination of exchange pattern , communication type , and the optional attribute determines a parameter's and thus operation's \"timing behavior\": Exchange Pattern Communication Type Optional? Timing Behavior \"IN\" \"ASYNCHRONOUS\" false Operation must receive value at some point in time during its execution for the respective parameter. \"IN\" \"ASYNCHRONOUS\" true Operation may receive value at some point in time during its execution for the respective parameter. \"IN\" \"SYNCHRONOUS\" false Operation is only executable with the respective parameter receiving a value. \"IN\" \"SYNCHRONOUS\" true Operation is executable without the respective parameter receiving a value. Furthermore, the operation cannot expect to ever receive a value for the respective parameter. \"OUT\" \"ASYNCHRONOUS\" false Operation uses the respective parameter to emit a value at some point in time during its execution. \"OUT\" \"ASYNCHRONOUS\" true Operation may use the respective parameter to emit a value at some point in time during its execution. \"OUT\" \"SYNCHRONOUS\" false Operation uses the respective parameter to emit a value after its execution. \"OUT\" \"SYNCHRONOUS\" true Operation may use the respective parameter to emit a value after its execution. \"INOUT\" all all Operation treats the parameter as an incoming and outgoing parameter for the concrete communication type and optional flag. IntermediateType[1] type The type of the parameter. Hint Model processors must use this type as the parameter's type and not the originalType . Note A parameter can receive the unspecified type only if the operation is not implemented . IntermediateType[1] originalType The original type of the parameter. Hint The attribute always holds a value. In case the value differs from that of the type attribute , the parameter type got altered in a mapping model and the type attribute attribute holds an instance of the IntermediateImportedTechnologySpecificType concept that identifies the technology-specific type to which the original return type was mapped. OperationReference initializedByOperation Link to the IntermediateOperation that initializes the parameter. Note It is not guaranteed that the operation's return values and the parameter's type are compatible. This is due to LEMMA's Service Modeling Language yielding a warning only in case it detected a (possible) type incompatibility. IntermediateImportedAspect[*] aspects Aspects of the parameter. DataFieldAspects[*] fieldAspects Aspects that were assigned to fields of the structure type or enumeration type of the parameter within a mapping model . Hint These aspects are relevant only in the context of the parameter within its defining operation. That is, they are not relevant in the context of the type that defines the fields within its domain model . IntermediateOperation operation Link to the defining IntermediateOperation instance. Class DataFieldAspects This concept gathers aspects , which were assigned to fields of a parameter's structure type or enumeration type within a mapping model . String[1] name The name of the structure type's or enumeration type's field to which the aspects were assigned in the context of the parameter. String[1] qualifiedName Qualified name of the field. Consists of the field's name prefixed by the parameter's qualified name . Both name fragments are separated by dots. IntermediateImportedAspect[1..*] aspects The aspects that were assigned to the field in the context of the parameter. IntermediateParameter parameter Link to the defining IntermediateParameter instance. Class IntermediateReferredOperation Referred operation of an interface . By contrast to \"locally defined\" operations , referred operations do not implement their own business logic. Instead, they act as fa\u00e7ades to implemented operations within the same microservice. That is, requests/responses to the original operation/the caller are just forwarded by referred operations. Referred operations exhibit the same parameters as the original operations. However, they may have different endpoints , protocols , and aspects . String[1] nameInReferringInterface The name of the referred operation within the referring interface. Currently, this name is identical to the name of the original operation . However, model processors should not rely on that fact and instead use the content of this attribute to process the referring operation. String[1] qualifiedNameInReferringInterface The qualified name of the referred operation within the referring interface. It consists of the name of the referring operation prefixed by the defining interface's qualified name . Both name fragments are separated by dots. IntermediateOperation[1] operation Link to the original operation . Note The type of the attribute is IntermediateOperation instead of OperationReference because the original operation must reside in the same microservice as the referring operation and can thus not originate from an imported service model . IntermediateEndpoint[*] endpoints Endpoints specified for the referred operation. Hint If no endpoints were modeled for the referred operation's (default) protocol specifications , the addresses attribute of the IntermediateEndpoint instance will be empty. Hint If no endpoints were specified or could be determined from (default) protocol specifications , or in case the addresses attribute is empty, model processors may assume sensible defaults. IntermediateProtocolSpecification[0..2] protocols Protocol specifications of the referred operation. There might be at most one protocol specification per communication type (synchronous or asynchronous). Hint If no protocols were explicitly specified for the referred operation, it \"inherits\" the specifications of its interface . In case the interface does also not exhibit protocol specifications, model processors should assume sensible defaults. IntermediateImportedAspect[*] aspects Aspects of the referred operation. IntermediateInterface referringInterface Link to the IntermediateInterface instance, which refers to the operation. Communication This subsection describes concepts for the specification of microservice communication. Class IntermediateEndpoint A protocol- and format-specific endpoint, e.g., \"http://example.org\" for the HTTP protocol and \"application/json\" for the JSON data format. String[1] communicationType Communication type of the endpoint. Corresponds to the type of the endpoint's protocol . The following values are possible: Type Description \"ASYNCHRONOUS\" Asynchronous communication. \"SYNCHRONOUS\" Synchronous communication. String[1] protocol Name of the endpoint's protocol. String[1] dataFormat Name of the endpoint's data format. LEMMA does not prescribe the notation of data formats in defining technology models . For instance, model processors may refer to the JSON format by means of its simple name, e.g., \"json\", or its MIME type, i.e., \"application/json\". Hence, it is in the responsibility of model processor developers to ensure that processors are compatible with technology models. String[*] addresses List of protocol- and format-specific addresses that were assigned to the endpoint, e.g., \"http://example.org\". Hint If the list of addresses is empty, model processors should assume sensible defaults as described for microservices , interfaces , operations , and referred operations . Hint In case the modeler did not specify a data format for an endpoint, it depends on the technology model, which endpoints are created in the intermediate service model: If the technology model defines a default protocol and thus a default format, an endpoint for this protocol and format is created in the intermediate service model. If the protocol is not the default protocol for the communication type and hence does not define a default format, endpoints for all formats supported by the protocol are created. Hint The addresses are not checked for validity by the Service Modeling Language. Model processors are required to perform validation, if necessary. IntermediateTechnology[1] technology Link to the technology model , which defines the protocol and data format. IntermediateMicroservice microservice Microservice for which the endpoint was specified. IntermediateInterface interface Interface for which the endpoint was specified. IntermediateOperation operation Operation for which the endpoint was specified. IntermediateReferredOperation referredOperation Referred operation for which the endpoint was specified. Class IntermediateProtocolSpecification A protocol and data format specification. String[1] communicationType Communication type of the specification. The following values are possible: Type Description \"ASYNCHRONOUS\" Asynchronous communication. \"SYNCHRONOUS\" Synchronous communication. String[1] protocol Name of the specification's protocol. String[1] dataFormat Name of the specification's data format. Technologies Class IntermediateTechnology Intermediate representation of a technology that originates from an imported technology model and has been applied to a microservice. String[1] name The technology's name. IntermediateImport[1] import Intermediate representation of the technology model's import. IntermediateMicroservice[1] microservice Intermediate representation of the microservice to which the technology has been applied. References This subsection describes concepts that model references to possibly imported microservices , interfaces , or operations . Class MicroserviceReference Reference to a possibly imported microservice . String[1] name Name of the referenced microservice. String version Version of the referenced microservice. String[1] qualifiedName Qualified name of the referenced microservice. boolean imported Flag to indicate if the referenced microservice was imported from another service model. IntermediateImport import The import, which points to the imported service model from which the referenced microservice originates. Iff the imported flag flag is true , this attribute also contains a value. IntermediateMicroservice localMicroservice Link to the referenced microservice in the same service model as the MicroserviceReference . Iff the imported flag flag is false , this attribute also contains a value. Hint If the attribute is null , i.e., the referenced microservice is defined in another, imported service model, model processors need to retrieve details about the referenced service from the imported service model themselves. That is, they need to parse the imported model and find the referenced microservice leveraging the qualifiedName attribute of the MicroserviceReference instance. IntermediateMicroservice requiringMicroservice Link to the microservice that requires the referenced microservice. Class InterfaceReference Reference to a possibly imported interface . String[1] name Name of the referenced interface. String version Version of the referenced interface. String[1] qualifiedName Qualified name of the referenced interface. boolean imported Flag to indicate if the referenced interface was imported from another service model. IntermediateImport import The import, which points to the imported service model from which the referenced interface originates. Iff the the imported flag flag is true , this attribute also contains a value. IntermediateInterface localInterface Link to the referenced interface in the same service model as the InterfaceReference . Iff the imported flag flag is false , this attribute also contains a value. Hint If the attribute is null , i.e., the referenced interface is defined in another, imported service model, model processors need to retrieve details about the referenced interface from the imported service model themselves. That is, they need to parse the imported model and find the referenced interface leveraging the qualifiedName attribute of the InterfaceReference instance. IntermediateMicroservice requiringMicroservice Link to the microservice that requires the referenced interface. Class OperationReference Reference to a possibly imported operation . String[1] name Name of the referenced operation. String[1] qualifiedName Qualified name of the referenced operation. boolean imported Flag to indicate if the referenced operation was imported from another service model. IntermediateImport import The import, which points to the imported service model from which the referenced operation originates. Iff the the imported flag flag is true , this attribute also contains a value. IntermediateOperation localOperation Link to the referenced operation in the same service model as the OperationReference . Iff the imported flag flag is false , this attribute also contains a value. Hint If the attribute is null , i.e., the referenced operation is defined in another, imported service model, model processors need to retrieve details about the referenced operation from the imported service model themselves. That is, they need to parse the imported model and find the referenced operation leveraging the qualifiedName attribute of the OperationReference instance. IntermediateMicroservice requiringMicroservice Link to the microservice that requires the referenced operation. IntermediateParameter initializedParameter Link to the parameter that is initialized by the referenced operation.","title":"Intermediate Service Model Specification"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#intermediate-service-model-specification","text":"This page specifies the structure and semantics of the intermediate metamodel for LEMMA service models . All obtained intermediate LEMMA service models must conform to this metamodel to ensure consistent behavior of LEMMA model processors . The following figure shows the metamodel's structure: Structure of the metamodel for intermediate service models The source code of the metamodel specification can be found at https://github.com/SeelabFhdo/lemma/blob/main/de.fhdo.lemma.service.intermediate.metamodel/model/IntermediateServiceModel.xcore . Each of the following sections describes certain concepts of the metamodel. Note Attributes that may contain more than one value but exhibit a * multiplicity, i.e., they may contain an arbitrary number of values or even none at all ( * is shorthand UML notation for 0..* ), are never null. In case no multiplicity is stated after the object type of an attribute, the attribute may be null. For example, an attribute defined as String name implicitly has a multiplicity 0..1 and in the zero-case the String may be null. However, in case the attribute's type is a built-in primitive Java type, e.g. int , the attribute will never be null but exhibits the type's default value in case it did not receive an explicit value.","title":"Intermediate Service Model Specification"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#model-root","text":"","title":"Model Root"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-IntermediateServiceModel","text":"Root of an intermediate service model.","title":"Class IntermediateServiceModel"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateServiceModel-sourceModelUri","text":"file:// URI pointing to the source service model file from which this intermediate service model was derived. Note Model processors must not depend on this URI being absolute or relative. Both cases may occur in practice and are up to the modeler.","title":"String[1] sourceModelUri"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateServiceModel-imports","text":"References to imported technology models , intermediate domain models , or intermediate service models.","title":"IntermediateImport[*] imports"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateServiceModel-microservices","text":"Microservices defined in the service model.","title":"IntermediateMicroservice[1..*] microservices"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#microservices","text":"","title":"Microservices"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-IntermediateMicroservice","text":"A modeled microservice.","title":"Class IntermediateMicroservice"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-sourceModelUri","text":"file:// URI pointing to the source service model file from which this microservice originates. Note Model processors must not depend on this URI being absolute or relative. Both cases may occur in practice and are up to the modeler.","title":"String[1] sourceModelUri"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-name","text":"Name of the microservice. Unique within the same service model .","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-version","text":"Optional version of the service.","title":"String version"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-qualifiedName","text":"Qualified name of the service. Consists of the service's name prefixed by its version , if any. Both name fragments are separated by dots.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-type","text":"Type of the microservice. The following values are possible: Type Description \"FUNCTIONAL\" A functional microservice realizes the business functions of a microservice architecture. \"INFRASTRUCTURE\" Infrastructure microservices provide the architecture with capabilities that are not related to business but technical functions. Examples of such functions comprise database lookups or integration of legacy systems. \"UTILITY\" Teams may realize utility microservices to implement reusable, business-related helper functions, e.g., for currency conversion.","title":"String[1] type"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-visibility","text":"Visibility of the microservice. The following values are possible: Visibility Description \"INTERNAL\" Service must only be visible to the services of the same team. \"ARCHITECTURE\" Service must only be visible to the services of the same architecture, but not to external consumers. \"PUBLIC\" Service must be visible to all services of the same architecture and also to external consumers.","title":"String[1] visibility"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-effectivelyImplemented","text":"Flag to indicate if the microservice has at least one operation that is not marked as being not implemented (either directly or transitively via its defining interface . Hint Model processors should consider to also handle not (yet) implemented microservices. Code generators, for example, might produce code that returns failures upon invocation of non-implemented service capabilities.","title":"boolean effectivelyImplemented"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-technologies","text":"Technologies assigned to the microservice. Hint There can only be one technology that defines default primitive types . Moreover, it is guaranteed that default protocol/data format combinations are unambiguous. For instance, there can only be one default synchronous protocol across all referenced technologies. Note In case no fitting technologies are specified for a microservice, model processors are free to omit processing steps if they cover only specific technologies.","title":"IntermediateTechnology[*] technologies"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-endpoints","text":"Endpoints specified for the microservice. Hint If no endpoints were modeled for the microservice's (default) protocol specifications , the addresses attribute of the IntermediateEndpoint instance will be empty. Hint If no endpoints were specified or could be determined from (default) protocol specifications , or in case the addresses attribute is empty, model processors may assume sensible defaults.","title":"IntermediateEndpoint[*] endpoints"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-protocols","text":"Protocol specifications of the microservice. There might be at most one protocol specification per communication type (synchronous or asynchronous). Hint If the service has no protocol specifications, code generators may produce sensible defaults, e.g., from the microservice's name. Note In case the microservice had no protocols assigned in the source service model, the default protocols of the missing communication types are taken from the service's technologies , if any. That is, the attribute will only be empty if the microservice had no protocol-defining technology assigned.","title":"IntermediateProtocolSpecification[0..2] protocols"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-requiredMicroservices","text":"References to required microservices.","title":"MicroserviceReference[*] requiredMicroservices"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-requiredInterfaces","text":"References to required interfaces.","title":"InterfaceReference[*] requiredInterfaces"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-requiredOperations","text":"References to required operations.","title":"OperationReference[*] requiredOperations"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-aspects","text":"Aspects of the microservice.","title":"IntermediateImportedAspect[*] aspects"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateMicroservice-serviceModel","text":"Link to the defining IntermediateServiceModel instance.","title":"IntermediateServiceModel serviceModel"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-IntermediateInterface","text":"This class represents an interface of an IntermediateMicroservice .","title":"Class IntermediateInterface"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateInterface-name","text":"Name of the interface. Unique within the same microservice .","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateInterface-version","text":"Optional version of the interface.","title":"String version"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateInterface-qualifiedName","text":"Qualified name of the interface. Consists of the defining microservice's qualified name , and the interface's version and name. All name fragments are separated by dots.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateInterface-visibility","text":"Visibility of the interface. The following values are possible: Visibility Description \"INTERNAL\" Interface must only be visible to the services of the same team. \"IN_MODEL\" Interface must only be visible to the services within the same service model file. \"ARCHITECTURE\" Interface must only be visible to the services of the same architecture, but not to external consumers. \"PUBLIC\" Interface must be visible to all services of the same architecture and also to external consumers.","title":"String[1] visibility"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateInterface-notImplemented","text":"Flag to indicate if the interface was marked as being not implemented. Hint Model processors should consider to also handle not (yet) implemented interfaces. Code generators, for example, might produce code that returns failures upon invocation of non-implemented service capabilities.","title":"boolean notImplemented"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateInterface-hasImplementedOperations","text":"Flag to indicate if the interface has at least one operation that is not marked as being not implemented. Hint Model processors should consider to also handle not (yet) implemented interfaces. Code generators, for example, might produce code that returns failures upon invocation of non-implemented service capabilities. Note The notImplemented and hasImplementedOperations flags are independent of each other. The former is set by the modeler, while the latter is derived from the corresponding flags of the interface's operations .","title":"boolean hasImplementedOperations"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateInterface-endpoints","text":"Endpoints specified for the interface. Hint If no endpoints were modeled for the interface's (default) protocol specifications , the addresses attribute of the IntermediateEndpoint instance will be empty. Hint If no endpoints were specified or could be determined from (default) protocol specifications , or in case the addresses attribute is empty, model processors may assume sensible defaults.","title":"IntermediateEndpoint[*] endpoints"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateInterface-protocols","text":"Protocol specifications of the interface. There might be at most one protocol specification per communication type (synchronous or asynchronous). Hint If no protocols were explicitly specified for the interface, it \"inherits\" the specifications of its microservice . In case the service does also not exhibit protocol specifications, model processors should assume sensible defaults. Note In case the microservice had no protocols assigned in the source service model, the default protocols of the missing communication types are taken from the service's technologies , if any. That is, the attribute will only be empty if the microservice had no protocol-defining technology assigned.","title":"IntermediateProtocolSpecification[0..2] protocols"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateInterface-operations","text":"Operations of the interface.","title":"IntermediateOperation[*] operations"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateInterface-referredOperations","text":"Referred operations of the interface. Note An interface defines at least one operation or refers to an existing operation, i.e., at least one of the attributes operations and [ referredOperations ] is not empty.","title":"IntermediateReferredOperation[*] referredOperations"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateInterface-aspects","text":"Aspects of the interface.","title":"IntermediateImportedAspectconcept-[*] aspects"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateInterface-microservice","text":"Link to the defining IntermediateMicroservice instance.","title":"IntermediateMicroservice microservice"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-IntermediateOperation","text":"This class represents an operation of an IntermediateInterface .","title":"Class IntermediateOperation"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateOperation-name","text":"Name of the operation. Unique within the same interface .","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateOperation-qualifiedName","text":"Qualified name of the operation. Consists of the operation's name prefixed by its interface's qualified name . Both name fragments are separated by dots.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateOperation-visibility","text":"Visibility of the microservice. The following values are possible: Visibility Description \"INTERNAL\" Operation must only be visible to the services of the same team. \"IN_MODEL\" Operation must only be visible to the services within the same service model file. \"ARCHITECTURE\" Operation must only be visible to the services of the same architecture, but not to external consumers. \"PUBLIC\" Operation must be visible to all services of the same architecture and also to external consumers.","title":"String[1] visibility"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateOperation-notImplemented","text":"Flag to indicate if the operation was marked as being not implemented. Hint Model processors should consider to also handle not (yet) implemented operations. Code generators, for example, might produce code that returns failures upon invocation of non-implemented service capabilities.","title":"boolean notImplemented"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateOperation-endpoints","text":"Endpoints specified for the interface. Hint If no endpoints were modeled for the operation's (default) protocol specifications , the addresses attribute of the IntermediateEndpoint instance will be empty. Hint If no endpoints were specified or could be determined from (default) protocol specifications , or in case the addresses attribute is empty, model processors may assume sensible defaults.","title":"IntermediateEndpoint[*] endpoints"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateOperation-protocols","text":"Protocol specifications of the operation. There might be at most one protocol specification per communication type (synchronous or asynchronous). Hint If no protocols were explicitly specified for the operation, it \"inherits\" the specifications of its interface . In case the interface does also not exhibit protocol specifications, model processors should assume sensible defaults.","title":"IntermediateProtocolSpecification[0..2] protocols"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateOperation-parameters","text":"The operation's parameters. Hint There might be more than one outgoing parameter and it is up to model processors on how to interpret such circumstances. For example, a code generator might represent all outgoing parameters as fields of a uniforming data structure.","title":"IntermediateParameter[*] parameters"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateOperation-apiOperationComment","text":"API comment of the operation.","title":"IntermediateApiOperationComment[0..1] apiOperationComment"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateOperation-aspects","text":"Aspects of the operation.","title":"IntermediateImportedAspect[*] aspects"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateOperation-interface","text":"Link to the defining IntermediateInterface instance.","title":"IntermediateInterface interface"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-IntermediateApiOperationComment","text":"This concept represents an API-related comment of a microservice operation . Such comments shall describe the purpose of a microservice operation, possibly including its parameters (cf. the IntermediateApiParameterComment concept).","title":"Class IntermediateApiOperationComment"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateApiOperationComment-comment","text":"Comment content.","title":"String[1] comment"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateApiOperationComment-parameterComments","text":"API comments for the operation's parameters. Hint It is possible that a parameter is commented more than once. It is up to model processors how they treat such a situation. For instance, a code generator might ignore all comments except for the last one.","title":"IntermediateApiParameterComment[*] parameterComments"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateApiOperationComment-operation","text":"The operation documented by this comment.","title":"IntermediateOperation operation"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-IntermediateApiParameterComment","text":"This concept represents an API-related comment of a microservice operation parameter .","title":"Class IntermediateApiParameterComment"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateApiParameterComment-comment","text":"Comment content.","title":"String[1] comment"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateApiParameterComment-required","text":"Flag to indicate if this parameter is required by the described API. Note It is possible to even document parameters that were modeled optional as required.","title":"boolean required"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateApiParameterComment-returned","text":"Flag to indicate if this parameter is returned by the described API.","title":"boolean returned"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateApiParameterComment-parameter","text":"The parameter documented by this comment.","title":"IntermediateParameter parameter"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateApiParameterComment-operationComment","text":"The API operation comment to which this parameter comment belongs.","title":"IntermediateApiOperationComment operationComment"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-IntermediateParameter","text":"A microservice operation parameter.","title":"Class IntermediateParameter"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateParameter-name","text":"Name of the parameter. Unique within the same operation .","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateParameter-qualifiedName","text":"Qualified name of the parameter. Consists of the parameter's name prefixed by its operation's qualified name . Both name fragments are separated by dots.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateParameter-exchangePattern","text":"Exchange pattern of the parameter. The following values are possible: Pattern Description \"IN\" Incoming information exchange. \"OUT\" Outgoing information exchange. \"INOUT\" Incoming and outgoing information exchange.","title":"String[1] exchangePattern"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateParameter-communicationType","text":"Communication type of the parameter. The following values are possible: Type Description \"ASYNCHRONOUS\" Asynchronous communication. \"SYNCHRONOUS\" Synchronous communication.","title":"String[1] communicationType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateParameter-communicatesFault","text":"Flag to indicate that the parameter communicates failure values to the caller. Note If necessary, it is up to model processors to ensure that callers are aware of the parameter communicating failure values.","title":"boolean communicatesFault"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateParameter-optional","text":"Flag to indicate that the parameter is optional. Note The combination of exchange pattern , communication type , and the optional attribute determines a parameter's and thus operation's \"timing behavior\": Exchange Pattern Communication Type Optional? Timing Behavior \"IN\" \"ASYNCHRONOUS\" false Operation must receive value at some point in time during its execution for the respective parameter. \"IN\" \"ASYNCHRONOUS\" true Operation may receive value at some point in time during its execution for the respective parameter. \"IN\" \"SYNCHRONOUS\" false Operation is only executable with the respective parameter receiving a value. \"IN\" \"SYNCHRONOUS\" true Operation is executable without the respective parameter receiving a value. Furthermore, the operation cannot expect to ever receive a value for the respective parameter. \"OUT\" \"ASYNCHRONOUS\" false Operation uses the respective parameter to emit a value at some point in time during its execution. \"OUT\" \"ASYNCHRONOUS\" true Operation may use the respective parameter to emit a value at some point in time during its execution. \"OUT\" \"SYNCHRONOUS\" false Operation uses the respective parameter to emit a value after its execution. \"OUT\" \"SYNCHRONOUS\" true Operation may use the respective parameter to emit a value after its execution. \"INOUT\" all all Operation treats the parameter as an incoming and outgoing parameter for the concrete communication type and optional flag.","title":"boolean optional"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateParameter-type","text":"The type of the parameter. Hint Model processors must use this type as the parameter's type and not the originalType . Note A parameter can receive the unspecified type only if the operation is not implemented .","title":"IntermediateType[1] type"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateParameter-originalType","text":"The original type of the parameter. Hint The attribute always holds a value. In case the value differs from that of the type attribute , the parameter type got altered in a mapping model and the type attribute attribute holds an instance of the IntermediateImportedTechnologySpecificType concept that identifies the technology-specific type to which the original return type was mapped.","title":"IntermediateType[1] originalType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateParameter-initializedByOperation","text":"Link to the IntermediateOperation that initializes the parameter. Note It is not guaranteed that the operation's return values and the parameter's type are compatible. This is due to LEMMA's Service Modeling Language yielding a warning only in case it detected a (possible) type incompatibility.","title":"OperationReference initializedByOperation"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateParameter-aspects","text":"Aspects of the parameter.","title":"IntermediateImportedAspect[*] aspects"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateParameter-fieldAspects","text":"Aspects that were assigned to fields of the structure type or enumeration type of the parameter within a mapping model . Hint These aspects are relevant only in the context of the parameter within its defining operation. That is, they are not relevant in the context of the type that defines the fields within its domain model .","title":"DataFieldAspects[*] fieldAspects"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateParameter-operation","text":"Link to the defining IntermediateOperation instance.","title":"IntermediateOperation operation"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-DataFieldAspects","text":"This concept gathers aspects , which were assigned to fields of a parameter's structure type or enumeration type within a mapping model .","title":"Class DataFieldAspects"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-DataFieldAspects-name","text":"The name of the structure type's or enumeration type's field to which the aspects were assigned in the context of the parameter.","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-DataFieldAspects-qualifiedName","text":"Qualified name of the field. Consists of the field's name prefixed by the parameter's qualified name . Both name fragments are separated by dots.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-DataFieldAspects-aspects","text":"The aspects that were assigned to the field in the context of the parameter.","title":"IntermediateImportedAspect[1..*] aspects"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-DataFieldAspects-parameter","text":"Link to the defining IntermediateParameter instance.","title":"IntermediateParameter parameter"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-IntermediateReferredOperation","text":"Referred operation of an interface . By contrast to \"locally defined\" operations , referred operations do not implement their own business logic. Instead, they act as fa\u00e7ades to implemented operations within the same microservice. That is, requests/responses to the original operation/the caller are just forwarded by referred operations. Referred operations exhibit the same parameters as the original operations. However, they may have different endpoints , protocols , and aspects .","title":"Class IntermediateReferredOperation"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateReferredOperation-nameInReferringInterface","text":"The name of the referred operation within the referring interface. Currently, this name is identical to the name of the original operation . However, model processors should not rely on that fact and instead use the content of this attribute to process the referring operation.","title":"String[1] nameInReferringInterface"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateReferredOperation-qualifiedNameInReferringInterface","text":"The qualified name of the referred operation within the referring interface. It consists of the name of the referring operation prefixed by the defining interface's qualified name . Both name fragments are separated by dots.","title":"String[1] qualifiedNameInReferringInterface"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateReferredOperation-operation","text":"Link to the original operation . Note The type of the attribute is IntermediateOperation instead of OperationReference because the original operation must reside in the same microservice as the referring operation and can thus not originate from an imported service model .","title":"IntermediateOperation[1] operation"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateReferredOperation-endpoints","text":"Endpoints specified for the referred operation. Hint If no endpoints were modeled for the referred operation's (default) protocol specifications , the addresses attribute of the IntermediateEndpoint instance will be empty. Hint If no endpoints were specified or could be determined from (default) protocol specifications , or in case the addresses attribute is empty, model processors may assume sensible defaults.","title":"IntermediateEndpoint[*] endpoints"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateReferredOperation-protocols","text":"Protocol specifications of the referred operation. There might be at most one protocol specification per communication type (synchronous or asynchronous). Hint If no protocols were explicitly specified for the referred operation, it \"inherits\" the specifications of its interface . In case the interface does also not exhibit protocol specifications, model processors should assume sensible defaults.","title":"IntermediateProtocolSpecification[0..2] protocols"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateReferredOperation-aspects","text":"Aspects of the referred operation.","title":"IntermediateImportedAspect[*] aspects"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateReferredOperation-referringInterface","text":"Link to the IntermediateInterface instance, which refers to the operation.","title":"IntermediateInterface referringInterface"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#communication","text":"This subsection describes concepts for the specification of microservice communication.","title":"Communication"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-IntermediateEndpoint","text":"A protocol- and format-specific endpoint, e.g., \"http://example.org\" for the HTTP protocol and \"application/json\" for the JSON data format.","title":"Class IntermediateEndpoint"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateEndpoint-communicationType","text":"Communication type of the endpoint. Corresponds to the type of the endpoint's protocol . The following values are possible: Type Description \"ASYNCHRONOUS\" Asynchronous communication. \"SYNCHRONOUS\" Synchronous communication.","title":"String[1] communicationType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateEndpoint-protocol","text":"Name of the endpoint's protocol.","title":"String[1] protocol"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateEndpoint-dataFormat","text":"Name of the endpoint's data format. LEMMA does not prescribe the notation of data formats in defining technology models . For instance, model processors may refer to the JSON format by means of its simple name, e.g., \"json\", or its MIME type, i.e., \"application/json\". Hence, it is in the responsibility of model processor developers to ensure that processors are compatible with technology models.","title":"String[1] dataFormat"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateEndpoint-addresses","text":"List of protocol- and format-specific addresses that were assigned to the endpoint, e.g., \"http://example.org\". Hint If the list of addresses is empty, model processors should assume sensible defaults as described for microservices , interfaces , operations , and referred operations . Hint In case the modeler did not specify a data format for an endpoint, it depends on the technology model, which endpoints are created in the intermediate service model: If the technology model defines a default protocol and thus a default format, an endpoint for this protocol and format is created in the intermediate service model. If the protocol is not the default protocol for the communication type and hence does not define a default format, endpoints for all formats supported by the protocol are created. Hint The addresses are not checked for validity by the Service Modeling Language. Model processors are required to perform validation, if necessary.","title":"String[*] addresses"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateEndpoint-technology","text":"Link to the technology model , which defines the protocol and data format.","title":"IntermediateTechnology[1] technology"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateEndpoint-microservice","text":"Microservice for which the endpoint was specified.","title":"IntermediateMicroservice microservice"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateEndpoint-interface","text":"Interface for which the endpoint was specified.","title":"IntermediateInterface interface"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateEndpoint-operation","text":"Operation for which the endpoint was specified.","title":"IntermediateOperation operation"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateEndpoint-referredOperation","text":"Referred operation for which the endpoint was specified.","title":"IntermediateReferredOperation referredOperation"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-IntermediateProtocolSpecification","text":"A protocol and data format specification.","title":"Class IntermediateProtocolSpecification"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateProtocolSpecification-communicationType","text":"Communication type of the specification. The following values are possible: Type Description \"ASYNCHRONOUS\" Asynchronous communication. \"SYNCHRONOUS\" Synchronous communication.","title":"String[1] communicationType"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateProtocolSpecification-protocol","text":"Name of the specification's protocol.","title":"String[1] protocol"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateProtocolSpecification-dataFormat","text":"Name of the specification's data format.","title":"String[1] dataFormat"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#technologies","text":"","title":"Technologies"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-IntermediateTechnology","text":"Intermediate representation of a technology that originates from an imported technology model and has been applied to a microservice.","title":"Class IntermediateTechnology"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateTechnology-name","text":"The technology's name.","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateTechnology-import","text":"Intermediate representation of the technology model's import.","title":"IntermediateImport[1] import"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-IntermediateTechnology-microservice","text":"Intermediate representation of the microservice to which the technology has been applied.","title":"IntermediateMicroservice[1] microservice"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#references","text":"This subsection describes concepts that model references to possibly imported microservices , interfaces , or operations .","title":"References"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-MicroserviceReference","text":"Reference to a possibly imported microservice .","title":"Class MicroserviceReference"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-MicroserviceReference-name","text":"Name of the referenced microservice.","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-MicroserviceReference-version","text":"Version of the referenced microservice.","title":"String version"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-MicroserviceReference-qualifiedName","text":"Qualified name of the referenced microservice.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-MicroserviceReference-imported","text":"Flag to indicate if the referenced microservice was imported from another service model.","title":"boolean imported"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-MicroserviceReference-import","text":"The import, which points to the imported service model from which the referenced microservice originates. Iff the imported flag flag is true , this attribute also contains a value.","title":"IntermediateImport import"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-MicroserviceReference-localMicroservice","text":"Link to the referenced microservice in the same service model as the MicroserviceReference . Iff the imported flag flag is false , this attribute also contains a value. Hint If the attribute is null , i.e., the referenced microservice is defined in another, imported service model, model processors need to retrieve details about the referenced service from the imported service model themselves. That is, they need to parse the imported model and find the referenced microservice leveraging the qualifiedName attribute of the MicroserviceReference instance.","title":"IntermediateMicroservice localMicroservice"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-MicroserviceReference-requiringMicroservice","text":"Link to the microservice that requires the referenced microservice.","title":"IntermediateMicroservice requiringMicroservice"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-InterfaceReference","text":"Reference to a possibly imported interface .","title":"Class InterfaceReference"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-InterfaceReference-name","text":"Name of the referenced interface.","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-InterfaceReference-version","text":"Version of the referenced interface.","title":"String version"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-InterfaceReference-qualifiedName","text":"Qualified name of the referenced interface.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-InterfaceReference-imported","text":"Flag to indicate if the referenced interface was imported from another service model.","title":"boolean imported"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-InterfaceReference-import","text":"The import, which points to the imported service model from which the referenced interface originates. Iff the the imported flag flag is true , this attribute also contains a value.","title":"IntermediateImport import"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-InterfaceReference-localInterface","text":"Link to the referenced interface in the same service model as the InterfaceReference . Iff the imported flag flag is false , this attribute also contains a value. Hint If the attribute is null , i.e., the referenced interface is defined in another, imported service model, model processors need to retrieve details about the referenced interface from the imported service model themselves. That is, they need to parse the imported model and find the referenced interface leveraging the qualifiedName attribute of the InterfaceReference instance.","title":"IntermediateInterface localInterface"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-InterfaceReference-requiringMicroservice","text":"Link to the microservice that requires the referenced interface.","title":"IntermediateMicroservice requiringMicroservice"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#concept-OperationReference","text":"Reference to a possibly imported operation .","title":"Class OperationReference"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-OperationReference-name","text":"Name of the referenced operation.","title":"String[1] name"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-OperationReference-qualifiedName","text":"Qualified name of the referenced operation.","title":"String[1] qualifiedName"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-OperationReference-imported","text":"Flag to indicate if the referenced operation was imported from another service model.","title":"boolean imported"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-OperationReference-import","text":"The import, which points to the imported service model from which the referenced operation originates. Iff the the imported flag flag is true , this attribute also contains a value.","title":"IntermediateImport import"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-OperationReference-localOperation","text":"Link to the referenced operation in the same service model as the OperationReference . Iff the imported flag flag is false , this attribute also contains a value. Hint If the attribute is null , i.e., the referenced operation is defined in another, imported service model, model processors need to retrieve details about the referenced operation from the imported service model themselves. That is, they need to parse the imported model and find the referenced operation leveraging the qualifiedName attribute of the OperationReference instance.","title":"IntermediateOperation localOperation"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-OperationReference-requiringMicroservice","text":"Link to the microservice that requires the referenced operation.","title":"IntermediateMicroservice requiringMicroservice"},{"location":"developer-guide/intermediate-model-specifications/intermediate-service-model-specification/#attribute-OperationReference-initializedParameter","text":"Link to the parameter that is initialized by the referenced operation.","title":"IntermediateParameter initializedParameter"},{"location":"developer-guide/intermediate-model-specifications/obtaining-intermediate-models/","text":"Obtaining Intermediate Models In the following, we exemplify the process to practically obtain the intermediate representation of a LEMMA service model, i.e., a LEMMA intermediate service model . This model conforms to the intermediate specification for LEMMA service models or, more precisely, the intermediate metamodel of LEMMA's Service Modeling Language . Handling of Imported Models By default, the derivation of the intermediate representation of a LEMMA model also considers the handling of imported models. However, the concrete handling of imported models depends on their kind: Domain Models : By default, the derivation of intermediate service models also comprises the derivation of the intermediate representations of all imported LEMMA domain models . Technology Models : The information from technology models is always incorporated into intermediate domain, service, or operation models. Service Models : By default, the derivation of intermediate service models also comprises the derivation of the intermediate representations of all imported LEMMA service models. Mapping Models : Similarly to technology models, the information from mapping models is always incorporated into intermediate domain, service, or operation models. In addition, LEMMA supports the derivation of intermediate models from service models imported into mapping models. Since the derivation of these intermediate models boils down to the iterative transformation of imported service models into their intermediate representations, it also involves the derivation of the intermediate representations of domain models, which are imported by mapped service models, by default. Operation Models : By default, the derivation of intermediate operation models also comprises the derivation of the intermediate representations of all imported LEMMA service models and their imported domain models. Obtaining Intermediate Service Models Using the Eclipse IDE LEMMA provides users with an Eclipse plugin for GUI-based and guided intermediate model derivation. While in the following we illustrate the usage of this plugin for LEMMA service models, the process is the same for obtaining intermediate models from LEMMA mapping and operation models. Note We employ the same service model from the tour of LEMMA features . Recall that the model resides in a file called ChargingStationManagementCommandSide.services visible in the Project Explorer of the corresponding Eclipse workspace: The code of the ChargingStationManagementCommandSide.services is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import datatypes from \"../../domain/ChargingStationManagement.data\" as Domain // EXTENSION (1) import technology from \"../../technology/Java.technology\" as Java // EXTENSION (2) import technology from \"../../technology/Spring.technology\" as Spring // EXTENSION (3) @technology (Java) // EXTENSION (4) @technology (Spring) // EXTENSION (5) @Spring::_aspects.Application (name= \"ChargingStationManagementCommandSide\" ) // EXTENSION (6) @Spring::_aspects.DatasourceConfiguration ( url = \"jdbc:h2:mem:command-side-db\" , username = \"${COMMAND_SIDE_SERVICE_DB_USER}\" , password = \"${COMMAND_SIDE_SERVICE_DB_PASSWORD}\" ) public functional microservice de.puls.ChargingStationManagementCommandSide { // EXTENSION (7) @endpoints (Spring::_protocols.rest: \"/resources\" ;) interface CommandSide { --- API endpoint for creating a parking area @requires command Command object to specify the values of the new parking area @returns response CreateParkingAreaCommandResponse with the identifier of the created parking area or an error message --- // EXTENSION (8) @endpoints (Spring::_protocols.rest: \"/parkingarea\" ;) // EXTENSION (9) @Spring::_aspects.Post createParkingArea( // EXTENSION (10) @Spring::_aspects.RequestBody // EXTENSION (11) @Spring::_aspects.Valid sync in command : Domain::ChargingStationManagement.CreateParkingAreaCommand, // EXTENSION (12) @Spring::_aspects.ResponseEntity sync out response : Domain::ChargingStationManagement.CreateParkingAreaCommandResponse ); } } Step 1: Start an Intermediate Model Derivation Process LEMMA's Eclipse plugin for intermediate model derivation supports two modes to transform LEMMA models into intermediate representations: Single-Model Mode In this mode, only the currently selected model will be considered for intermediate model derivation. To activate this mode, right-click on the model in the Eclipse Project Explorer and select the \"Generate Intermediate $MODEL_KIND Models...\" entry from the context menu, whereby the $MODEL_KIND string indicates the kind of the selected model, e.g., \"Service\" or \"Operation\". For the example service model ChargingStationManagementCommandSide.services , the context menu with the transformation entry looks as follows: Alternatively, to activate single-model mode, you might as well hit the following button that the Eclipse plugin contributes to the Eclipse toolbar: In addition, single-model mode is reachable from LEMMA's Eclipse menu: Multi-Model Mode This mode enables bulk transformation of LEMMA models in the current Eclipse workspace into their intermediate representations. The mode can be activated from LEMMA's Eclipse menu: Step 2: Select Models for Intermediate Transformation Independent of the selected intermediate transformation mode (cf. Step 1 ), LEMMA's Eclipse plugin for intermediate model transformation shows a dialog window that allows fine-grained selection of the models to derive intermediate representations from. When activating single-model transformation on the example service model ChargingStationManagementCommandSide.services , the model selection dialog window looks as follows: The dialog window groups the LEMMA models that can be transformed into intermediate representations by their projects in the current Eclipse workspace. Furthermore, a model clusters all transformable models, which it imports. Thus, the above model selection dialog window for the ChargingStationManagementCommandSide.services service model comprises a node for the model's Eclipse project, i.e., charging-station-management , a node for the service model, as well as a node for the ChargingStationManagement.data domain model , which is imported by the service model and represents a transformable model. From the dialog window, we can determine the set of models to derive intermediate representations from by selecting them with a mouse click on their node and hitting the \"Continue with selected models\" button. Alternatively, we can also hit the \"Select all models and continue\" button, which will select all displayed models for subsequent intermediate transformation. Step 3: Specify Transformation Target Paths After confirmation of the model selection dialog (cf. Step 2 ), LEMMA's Eclipse plugin for intermediate model transformation expects the specification of target paths for the intermediate models to derive. To this end, the plugin displays the following dialog window: The table in the dialog window contains all models that were selected in the previous dialog window and informs about certain transformation-related characteristics per model: Selection column : This column contains a checkbox with which a model may be deselected from transformation. By contrast to the previous model selection dialog, the target path specification dialog enables to also deselect imported models like ChargingStationManagement.data . By default, all listed model files are selected for their intermediate transformation. Model file : Model file path relative to its Eclipse project. Model type : Model file type. Project-related transformation target path : Target path for the derived intermediate model. The column is editable and allows specification of transformation target paths relative to the Eclipse project of the model file . The default transformation target path consists of the \"intermediate\" folder, the \" $MODEL_TYPE models\" folder (where $MODEL_TYPE corresponds to the type of the model in the third table column), and the name of the model file with its extension changed to \"xmi\" (to indicate that the resulting intermediate model follows the XMI format). In addition to the table, the dialog window comprises two checkboxes, which concern the intermediate transformation process of all models: Convert absolute URIs in models to relative URIs : Intermediate transformation involves the conversion of import URIs into absolute file paths. For example, the transformation process will adapt the path to the ChargingStationManagement.data model, which is imported by the ChargingStationManagementCommandSide.services model via the LEMMA statement import datatypes from \"ChargingStationManagement.data\" as domain , to an absolute file URI in the user's file system, e.g., \"file:///home/user/models/ChargingStationManagement.data\". While this approach supports immediate model processing independent of model files' location on the user's file system, it is not portable. More precisely, when moving model files to another computer, the absolute import paths become invalid as they are system-specific. The checkbox prevents this issue as it converts import URIs to file URIs relative to the most common path of the transformed models as selected in the target path specification dialog. For instance, when not adapting the default transformation target path, the import URI of the ChargingStationManagement.data model within the intermediate representation of the ChargingStationManagementCommandSide.services model will resolve to \"../data models/domain.xmi\". Output models of refinement transformations : The intermediate transformation process consists of several model transformation modules written in ATL . Depending on the transformation scenario, ATL refinement transformations may occur during the transformation process. The transformations take a LEMMA model as input, adapt it as determined by the transformation scenario, and output this refined model. Such refinement transformations enrich, e.g., domain models with technology information from mapping models. For the user the results of these refinement transformations are not visible by default, because the transformation process passes them to the next transformation step in the form of in-memory object graphs. However, the \"Output models of refinement transformations\" option allows serialization of possible refined models for debugging purposes. When hitting the \"OK\" button in the target path specification dialog, the intermediate model transformation process starts. Step 4: Intermediate Model Serialization A dialog window informs about the progress of the intermediate transformation process: If the derivation of the intermediate representations of all selected LEMMA models was successful, the progress dialog window disappears and the XMI files of the intermediate models can be found in the user's file system at the locations determined in the target path specification dialog (cf. Step 3 ). In case the default paths were not changed, the Eclipse projects of the input LEMMA models comprise an \"intermediate\" folder that stores the XMI files:","title":"Obtaining Intermediate Models"},{"location":"developer-guide/intermediate-model-specifications/obtaining-intermediate-models/#obtaining-intermediate-models","text":"In the following, we exemplify the process to practically obtain the intermediate representation of a LEMMA service model, i.e., a LEMMA intermediate service model . This model conforms to the intermediate specification for LEMMA service models or, more precisely, the intermediate metamodel of LEMMA's Service Modeling Language .","title":"Obtaining Intermediate Models"},{"location":"developer-guide/intermediate-model-specifications/obtaining-intermediate-models/#handling-of-imported-models","text":"By default, the derivation of the intermediate representation of a LEMMA model also considers the handling of imported models. However, the concrete handling of imported models depends on their kind: Domain Models : By default, the derivation of intermediate service models also comprises the derivation of the intermediate representations of all imported LEMMA domain models . Technology Models : The information from technology models is always incorporated into intermediate domain, service, or operation models. Service Models : By default, the derivation of intermediate service models also comprises the derivation of the intermediate representations of all imported LEMMA service models. Mapping Models : Similarly to technology models, the information from mapping models is always incorporated into intermediate domain, service, or operation models. In addition, LEMMA supports the derivation of intermediate models from service models imported into mapping models. Since the derivation of these intermediate models boils down to the iterative transformation of imported service models into their intermediate representations, it also involves the derivation of the intermediate representations of domain models, which are imported by mapped service models, by default. Operation Models : By default, the derivation of intermediate operation models also comprises the derivation of the intermediate representations of all imported LEMMA service models and their imported domain models.","title":"Handling of Imported Models"},{"location":"developer-guide/intermediate-model-specifications/obtaining-intermediate-models/#obtaining-intermediate-service-models-using-the-eclipse-ide","text":"LEMMA provides users with an Eclipse plugin for GUI-based and guided intermediate model derivation. While in the following we illustrate the usage of this plugin for LEMMA service models, the process is the same for obtaining intermediate models from LEMMA mapping and operation models. Note We employ the same service model from the tour of LEMMA features . Recall that the model resides in a file called ChargingStationManagementCommandSide.services visible in the Project Explorer of the corresponding Eclipse workspace: The code of the ChargingStationManagementCommandSide.services is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import datatypes from \"../../domain/ChargingStationManagement.data\" as Domain // EXTENSION (1) import technology from \"../../technology/Java.technology\" as Java // EXTENSION (2) import technology from \"../../technology/Spring.technology\" as Spring // EXTENSION (3) @technology (Java) // EXTENSION (4) @technology (Spring) // EXTENSION (5) @Spring::_aspects.Application (name= \"ChargingStationManagementCommandSide\" ) // EXTENSION (6) @Spring::_aspects.DatasourceConfiguration ( url = \"jdbc:h2:mem:command-side-db\" , username = \"${COMMAND_SIDE_SERVICE_DB_USER}\" , password = \"${COMMAND_SIDE_SERVICE_DB_PASSWORD}\" ) public functional microservice de.puls.ChargingStationManagementCommandSide { // EXTENSION (7) @endpoints (Spring::_protocols.rest: \"/resources\" ;) interface CommandSide { --- API endpoint for creating a parking area @requires command Command object to specify the values of the new parking area @returns response CreateParkingAreaCommandResponse with the identifier of the created parking area or an error message --- // EXTENSION (8) @endpoints (Spring::_protocols.rest: \"/parkingarea\" ;) // EXTENSION (9) @Spring::_aspects.Post createParkingArea( // EXTENSION (10) @Spring::_aspects.RequestBody // EXTENSION (11) @Spring::_aspects.Valid sync in command : Domain::ChargingStationManagement.CreateParkingAreaCommand, // EXTENSION (12) @Spring::_aspects.ResponseEntity sync out response : Domain::ChargingStationManagement.CreateParkingAreaCommandResponse ); } }","title":"Obtaining Intermediate Service Models Using the Eclipse IDE"},{"location":"developer-guide/intermediate-model-specifications/obtaining-intermediate-models/#step-1-start-an-intermediate-model-derivation-process","text":"LEMMA's Eclipse plugin for intermediate model derivation supports two modes to transform LEMMA models into intermediate representations:","title":"Step 1: Start an Intermediate Model Derivation Process"},{"location":"developer-guide/intermediate-model-specifications/obtaining-intermediate-models/#single-model-mode","text":"In this mode, only the currently selected model will be considered for intermediate model derivation. To activate this mode, right-click on the model in the Eclipse Project Explorer and select the \"Generate Intermediate $MODEL_KIND Models...\" entry from the context menu, whereby the $MODEL_KIND string indicates the kind of the selected model, e.g., \"Service\" or \"Operation\". For the example service model ChargingStationManagementCommandSide.services , the context menu with the transformation entry looks as follows: Alternatively, to activate single-model mode, you might as well hit the following button that the Eclipse plugin contributes to the Eclipse toolbar: In addition, single-model mode is reachable from LEMMA's Eclipse menu:","title":"Single-Model Mode"},{"location":"developer-guide/intermediate-model-specifications/obtaining-intermediate-models/#multi-model-mode","text":"This mode enables bulk transformation of LEMMA models in the current Eclipse workspace into their intermediate representations. The mode can be activated from LEMMA's Eclipse menu:","title":"Multi-Model Mode"},{"location":"developer-guide/intermediate-model-specifications/obtaining-intermediate-models/#step-2-select-models-for-intermediate-transformation","text":"Independent of the selected intermediate transformation mode (cf. Step 1 ), LEMMA's Eclipse plugin for intermediate model transformation shows a dialog window that allows fine-grained selection of the models to derive intermediate representations from. When activating single-model transformation on the example service model ChargingStationManagementCommandSide.services , the model selection dialog window looks as follows: The dialog window groups the LEMMA models that can be transformed into intermediate representations by their projects in the current Eclipse workspace. Furthermore, a model clusters all transformable models, which it imports. Thus, the above model selection dialog window for the ChargingStationManagementCommandSide.services service model comprises a node for the model's Eclipse project, i.e., charging-station-management , a node for the service model, as well as a node for the ChargingStationManagement.data domain model , which is imported by the service model and represents a transformable model. From the dialog window, we can determine the set of models to derive intermediate representations from by selecting them with a mouse click on their node and hitting the \"Continue with selected models\" button. Alternatively, we can also hit the \"Select all models and continue\" button, which will select all displayed models for subsequent intermediate transformation.","title":"Step 2: Select Models for Intermediate Transformation"},{"location":"developer-guide/intermediate-model-specifications/obtaining-intermediate-models/#step-3-specify-transformation-target-paths","text":"After confirmation of the model selection dialog (cf. Step 2 ), LEMMA's Eclipse plugin for intermediate model transformation expects the specification of target paths for the intermediate models to derive. To this end, the plugin displays the following dialog window: The table in the dialog window contains all models that were selected in the previous dialog window and informs about certain transformation-related characteristics per model: Selection column : This column contains a checkbox with which a model may be deselected from transformation. By contrast to the previous model selection dialog, the target path specification dialog enables to also deselect imported models like ChargingStationManagement.data . By default, all listed model files are selected for their intermediate transformation. Model file : Model file path relative to its Eclipse project. Model type : Model file type. Project-related transformation target path : Target path for the derived intermediate model. The column is editable and allows specification of transformation target paths relative to the Eclipse project of the model file . The default transformation target path consists of the \"intermediate\" folder, the \" $MODEL_TYPE models\" folder (where $MODEL_TYPE corresponds to the type of the model in the third table column), and the name of the model file with its extension changed to \"xmi\" (to indicate that the resulting intermediate model follows the XMI format). In addition to the table, the dialog window comprises two checkboxes, which concern the intermediate transformation process of all models: Convert absolute URIs in models to relative URIs : Intermediate transformation involves the conversion of import URIs into absolute file paths. For example, the transformation process will adapt the path to the ChargingStationManagement.data model, which is imported by the ChargingStationManagementCommandSide.services model via the LEMMA statement import datatypes from \"ChargingStationManagement.data\" as domain , to an absolute file URI in the user's file system, e.g., \"file:///home/user/models/ChargingStationManagement.data\". While this approach supports immediate model processing independent of model files' location on the user's file system, it is not portable. More precisely, when moving model files to another computer, the absolute import paths become invalid as they are system-specific. The checkbox prevents this issue as it converts import URIs to file URIs relative to the most common path of the transformed models as selected in the target path specification dialog. For instance, when not adapting the default transformation target path, the import URI of the ChargingStationManagement.data model within the intermediate representation of the ChargingStationManagementCommandSide.services model will resolve to \"../data models/domain.xmi\". Output models of refinement transformations : The intermediate transformation process consists of several model transformation modules written in ATL . Depending on the transformation scenario, ATL refinement transformations may occur during the transformation process. The transformations take a LEMMA model as input, adapt it as determined by the transformation scenario, and output this refined model. Such refinement transformations enrich, e.g., domain models with technology information from mapping models. For the user the results of these refinement transformations are not visible by default, because the transformation process passes them to the next transformation step in the form of in-memory object graphs. However, the \"Output models of refinement transformations\" option allows serialization of possible refined models for debugging purposes. When hitting the \"OK\" button in the target path specification dialog, the intermediate model transformation process starts.","title":"Step 3: Specify Transformation Target Paths"},{"location":"developer-guide/intermediate-model-specifications/obtaining-intermediate-models/#step-4-intermediate-model-serialization","text":"A dialog window informs about the progress of the intermediate transformation process: If the derivation of the intermediate representations of all selected LEMMA models was successful, the progress dialog window disappears and the XMI files of the intermediate models can be found in the user's file system at the locations determined in the target path specification dialog (cf. Step 3 ). In case the default paths were not changed, the Eclipse projects of the input LEMMA models comprise an \"intermediate\" folder that stores the XMI files:","title":"Step 4: Intermediate Model Serialization"},{"location":"developer-guide/java-base-generator-extension/","text":"Extending the Java Base Generator LEMMA's documentation is currently work in progress. Therefore, to learn more about the modular design of LEMMA's Java Base Generator and how to extend it with additional plugins for Java-based microservice technology, please refer to Section 8.7 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Extending the Java Base Generator"},{"location":"developer-guide/java-base-generator-extension/#extending-the-java-base-generator","text":"LEMMA's documentation is currently work in progress. Therefore, to learn more about the modular design of LEMMA's Java Base Generator and how to extend it with additional plugins for Java-based microservice technology, please refer to Section 8.7 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Extending the Java Base Generator"},{"location":"developer-guide/model-processing-framework/","text":"Model Processing Framework LEMMA's documentation is currently work in progress. Therefore, to learn more about the design and implementation of LEMMA's Model Processing Framework and how to use it to easily create standalone processors for LEMMA models using annotation-based Inversion of Control , please refer to Chapter 7 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Model Processing Framework"},{"location":"developer-guide/model-processing-framework/#model-processing-framework","text":"LEMMA's documentation is currently work in progress. Therefore, to learn more about the design and implementation of LEMMA's Model Processing Framework and how to use it to easily create standalone processors for LEMMA models using annotation-based Inversion of Control , please refer to Chapter 7 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Model Processing Framework"},{"location":"developer-guide/static-analysis-library/","text":"Static Analysis Library LEMMA's documentation is currently work in progress. Therefore, to learn more about the design of the static analysis library and the 20 metrics it provides for assessing the quality of LEMMA-based microservice models, please refer to Section 9.5 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Static Analysis Library"},{"location":"developer-guide/static-analysis-library/#static-analysis-library","text":"LEMMA's documentation is currently work in progress. Therefore, to learn more about the design of the static analysis library and the 20 metrics it provides for assessing the quality of LEMMA-based microservice models, please refer to Section 9.5 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Static Analysis Library"},{"location":"feature-overview/","text":"Feature Overview LEMMA constitutes a model-driven ecosystem that comes with the following features in the design, development and, deployment of microservice architectures : Concern-oriented Modeling Languages: LEMMA aims to reduce the inherent complexity of microservice architectures by providing its users with dedicated modeling languages for the various challenges in the engineering of microservice architectures. Specifically, these modeling languages focus on domain-driven microservice design , technology-agnostic API modeling , and concise deployment and operation specification . All modeling languages of LEMMA come with IDE support including syntax highlighting, code completion, and as-you-type validation. Practice-oriented: LEMMA's modeling languages are inspired by the requirements of real-world microservice architectures including distributed development, DevOps-based teams, and technology heterogeneity. Broad Applicability: LEMMA has been used for, e.g., (i) the translation of domain-driven microservice designs into implementations ; (ii) architecture recovery and quality attribute analysis ; and (iii) microservice code generation . Designed for Extensibility : LEMMA is designed to be extensible, e.g., with the support of new frameworks for microservice implementation or deployment. Have a look at our Developer Guide for the details. For additional details about LEMMA's features, you may also want to watch this YouTube video:","title":"Feature Overview"},{"location":"feature-overview/#feature-overview","text":"LEMMA constitutes a model-driven ecosystem that comes with the following features in the design, development and, deployment of microservice architectures : Concern-oriented Modeling Languages: LEMMA aims to reduce the inherent complexity of microservice architectures by providing its users with dedicated modeling languages for the various challenges in the engineering of microservice architectures. Specifically, these modeling languages focus on domain-driven microservice design , technology-agnostic API modeling , and concise deployment and operation specification . All modeling languages of LEMMA come with IDE support including syntax highlighting, code completion, and as-you-type validation. Practice-oriented: LEMMA's modeling languages are inspired by the requirements of real-world microservice architectures including distributed development, DevOps-based teams, and technology heterogeneity. Broad Applicability: LEMMA has been used for, e.g., (i) the translation of domain-driven microservice designs into implementations ; (ii) architecture recovery and quality attribute analysis ; and (iii) microservice code generation . Designed for Extensibility : LEMMA is designed to be extensible, e.g., with the support of new frameworks for microservice implementation or deployment. Have a look at our Developer Guide for the details. For additional details about LEMMA's features, you may also want to watch this YouTube video:","title":"Feature Overview"},{"location":"getting-started/","text":"Installation The implementation of LEMMA's modeling languages is based on Eclipse and the majority of LEMMA's components comes as a set of plugins for the Eclipse IDE . To facilitate the installation of these plugins, we provide an Eclipse Updatesite for LEMMA that you can install as described below. 1. Ensure a Suitable Package of the Eclipse IDE LEMMA works with all Eclipse packages greater or equal version 2021-03 that provide built-in Java support. In case you don't have a suitable Eclipse installation at hand or want to try LEMMA with a fresh installation, hit the following button to download the Eclipse IDE for Java Developers: Download the Eclipse IDE for Java Developers Minimum Eclipse Release The above download link for the Eclipse package points to Eclipse release 2022-09 which, at the time of writing, is the latest release of Eclipse. As already mentioned above, however, you may use LEMMA with any Eclipse release greater or equal 2021-03 . 2. Install LEMMA from its Eclipse Updatesite You can install LEMMA in an existing or fresh Eclipse installation by means of Eclipse's Updatesite mechanism . The required link to LEMMA's Updatesite is as follows: https://microservices.fh-dortmund.de/lemma/ Restart your Eclipse IDE after the installation of LEMMA from this Updatesite. 3. Verify Installation A first indicator for the successful installation of LEMMA is provided by the new entry \"LEMMA\" in Eclipse's main menu. Click on the menu entry and select the sub-menu entry \"About LEMMA\". The following window should appear to inform about the currently installed version of LEMMA. LEMMA's About dialog. To verify the successful installation of LEMMA even further, you can create a model in one of LEMMA's modeling languages and check whether the Eclipse IDE recognizes it correctly: Create a new Java project in Eclipse. Within the project, create a new file called test.data . Note that it is mandatory to use the extension .data as otherwise Eclipse will not be able to associate the file with LEMMA's Domain Data Modeling Language . In case the \"Configure Xtext\" dialog appears, just hit \"Yes\": Configure Xtext dialog. Add the following domain model code to the test.data file: 1 2 3 4 5 6 7 context HelloWorldCtx { structure HelloWorldStruct < valueObject > { immutable string string_field1, immutable string string_field2 = \"constant\" , immutable double double_field } } Eclipse should highlight the model code as follows: Example model code highlighted in Eclipse. Congratulations, you have successfully installed LEMMA. Now, you may want to take the Tour and explore some of LEMMA's core features. Troubleshooting Having trouble with the installation of LEMMA? Please do not hesitate to contact us via e-mail or open issue at LEMMA's GitHub page .","title":"Installation"},{"location":"getting-started/#installation","text":"The implementation of LEMMA's modeling languages is based on Eclipse and the majority of LEMMA's components comes as a set of plugins for the Eclipse IDE . To facilitate the installation of these plugins, we provide an Eclipse Updatesite for LEMMA that you can install as described below.","title":"Installation"},{"location":"getting-started/#1-ensure-a-suitable-package-of-the-eclipse-ide","text":"LEMMA works with all Eclipse packages greater or equal version 2021-03 that provide built-in Java support. In case you don't have a suitable Eclipse installation at hand or want to try LEMMA with a fresh installation, hit the following button to download the Eclipse IDE for Java Developers: Download the Eclipse IDE for Java Developers Minimum Eclipse Release The above download link for the Eclipse package points to Eclipse release 2022-09 which, at the time of writing, is the latest release of Eclipse. As already mentioned above, however, you may use LEMMA with any Eclipse release greater or equal 2021-03 .","title":"1. Ensure a Suitable Package of the Eclipse IDE"},{"location":"getting-started/#2-install-lemma-from-its-eclipse-updatesite","text":"You can install LEMMA in an existing or fresh Eclipse installation by means of Eclipse's Updatesite mechanism . The required link to LEMMA's Updatesite is as follows: https://microservices.fh-dortmund.de/lemma/ Restart your Eclipse IDE after the installation of LEMMA from this Updatesite.","title":"2. Install LEMMA from its Eclipse Updatesite"},{"location":"getting-started/#3-verify-installation","text":"A first indicator for the successful installation of LEMMA is provided by the new entry \"LEMMA\" in Eclipse's main menu. Click on the menu entry and select the sub-menu entry \"About LEMMA\". The following window should appear to inform about the currently installed version of LEMMA. LEMMA's About dialog. To verify the successful installation of LEMMA even further, you can create a model in one of LEMMA's modeling languages and check whether the Eclipse IDE recognizes it correctly: Create a new Java project in Eclipse. Within the project, create a new file called test.data . Note that it is mandatory to use the extension .data as otherwise Eclipse will not be able to associate the file with LEMMA's Domain Data Modeling Language . In case the \"Configure Xtext\" dialog appears, just hit \"Yes\": Configure Xtext dialog. Add the following domain model code to the test.data file: 1 2 3 4 5 6 7 context HelloWorldCtx { structure HelloWorldStruct < valueObject > { immutable string string_field1, immutable string string_field2 = \"constant\" , immutable double double_field } } Eclipse should highlight the model code as follows: Example model code highlighted in Eclipse. Congratulations, you have successfully installed LEMMA. Now, you may want to take the Tour and explore some of LEMMA's core features.","title":"3. Verify Installation"},{"location":"getting-started/#troubleshooting","text":"Having trouble with the installation of LEMMA? Please do not hesitate to contact us via e-mail or open issue at LEMMA's GitHub page .","title":"Troubleshooting"},{"location":"getting-started/tour/","text":"Tour In the following, we demonstrate some of the basic features of LEMMA regarding the construction and processing of microservice architecture models. Prerequisites To reproduce the presented modeling steps , you should first install LEMMA on your computer. To reproduce the presented model processing steps , the easiest way is to employ the Docker images of LEMMA's Java and deployment code generators. An installation of LEMMA already comes with an Eclipse plugin to simplify the usage of these images. However, the plugin uses Docker to instrument and execute the images so that you are required to install Docker on your computer as an additional technology. After having installed Docker, you can retrieve the images of LEMMA's Java and deployment code generators using the following commands in a commandline terminal that can access your Docker installation: 1 2 3 4 5 docker pull lemmahub/java_generator docker tag lemmahub/java_generator:latest lemma/java_generator:latest docker pull lemmahub/deployment_base_generator docker tag lemmahub/deployment_base_generator:latest lemma/deployment_base_generator:latest The Charging Station Management Example For the tour of LEMMA, we leverage a single microservice from an MSA 1 -based application as example. Basically, the application supports the management of parking spaces that are equipped with charging stations for electric vehicles. In the following, we will refer to this application as the \"Park and Charge Software Platform\", or short PCSP. The PCSP consists of several microservices, e.g., for user management, charging station search, and charging station management. For the tour of LEMMA, we will model the domain data, API, and deployment of the latter microservice, i.e., the ChargingStationManagement microservice. This microservice shall provide its clients with means to create parking spaces with charging stations at a specific location. Learn More About the PCSP You can learn more about the PCSP, and the rationale and decisions concerning its design in Sections 8.3 to 8.5 of the dissertation that conceived LEMMA 2 . What You Will Learn During the Tour In the following you will learn how to construct the following types of LEMMA models for the ChargingStationManagement microservice: Domain model: Defines the domain data of the microservice. Service model: Defines the API of the microservice. Operation model: Defines the deployment of the microservice. In addition, you will receive an impression on how model processing works with LEMMA. More specifically, you will learn how to derive executable Java code from the constructed models. The next sections will teach you how to construct the aforementioned LEMMA models for the ChargingStationManagement microservice by means of a LEMMA-enabled Eclipse installation . If you do not want to construct the models on your own, you can also find them in LEMMA's GitHub repository in the /examples/charging-station-management/models folder. Step 1: Create an Eclipse Project Run your LEMMA-enabled Eclipse installation and create a new Java project called charging-station-management . We will use this project to gather all models for the ChargingStationManagement microservice. In addition, create a folder called models within the project. The Project Explorer of your Eclipse workspace should now look similar to this: Step 2: Create a Domain Model LEMMA provides several modeling languages to express different viewpoints on a microservice architecture. A crucial viewpoint in almost every software project including MSA-based applications is the domain viewpoint . Therefore, LEMMA comprises the Domain Data Modeling Language to enable domain experts and microservice developers to collaboratively construct domain models . You will now create a LEMMA domain model for the ChargingStationManagement microservice by means of the Eclipse IDE. To this end, you first create a folder called domain in the models folder of the previously created charging-station-management Eclipse project. Next, you create a file called ChargingStationManagement.data within the domain folder. In case a dialog pops up, asking you to convert the charging-station-management project to an Xtext project, just confirm it with Yes . The .data extension of the domain model file is crucial as it signals Eclipse that the file constitutes a LEMMA domain model for which a dedicated Eclipse editor with syntax highlighting and interactive model validation exists. After having created the domain folder and the ChargingStationManagement.data in it, the Project Explorer of your Eclipse workspace should now look similar to this: Eclipse shows an error marker for the new model file because LEMMA's Domain Data Modeling Language does not allow empty domain models. To fix this issue, add the following model code to the ChargingStationManagement.data file by double-clicking the file in Eclipse's Project Explorer and entering the code in the text editor that just opened: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 context ChargingStationManagement { structure Location < valueObject > { immutable double latitude, immutable double longitude } structure ParkingArea < aggregate , entity > { long id < identifier > , string name, string description, Location location < part > , ChargerSpeed chargerSpeed, TimePeriods availability < part > , boolean activated } enum ChargerSpeed { FAST, NORMAL } collection TimePeriods { TimePeriod p } structure TimePeriod < valueObject > { immutable date start, immutable date end } } Bounded Contexts The Domain Data Modeling Language enables to organize the concepts of a microservice's domain excerpt within contexts . LEMMA's notion of context is inspired by the Bounded Context pattern from Domain-driven Design (DDD) and its importance for the tailoring of microservices' domain responsibilities . For the definition of contexts, the Domain Data Modeling Language provides the context keyword, which must be followed by the name of the context, and a pair of curly brackets to comprise the context's domain concepts (see below). Based on the context keyword, the domain model of the ChargingStationManagement microservice defines the ChargingStationManagement context as a cluster for its domain concepts. LEMMA supports three different kinds of domain concepts. Structured Domain Concepts and Domain-Driven Design A structured domain concept (or data structure ) is introduced by the structure keyword, followed by the name of the structure, and an arbitrary number of features . In LEMMA domain models, a feature assigns additional semantics, e.g., from patterns for tactical DDD , to a domain concept. Consider the Location structure from the domain model of the ChargingStationManagement microservice. It receives the valueObject feature to identify it as a DDD Value Object . A data structure can define an arbitrary number of typed and named data fields within curly brackets. In total, the Location structure consists of the two data fields latitude and longitude , both being typed as double s. LEMMA supports all of Java's primitive types , and also has built-in types for date s and String s. Next to their types and names, both data fields of the Location structure also exhibit the immutable modifier. It signals that fields can only receive values during the instantiation of of their defining structure. Afterwards, the values remain stable for the instance's lifetime and are not modifiable by callers. Since the primary use of DDD Value Objects is information sharing, e.g., in the form of [Data Transfer Objects]https://www.martinfowler.com/eaaCatalog/dataTransferObject.html, it is a best practice to flag their fields as immutable . The ParkingArea concept is another example of a data structure in the domain model of the ChargingStationManagement microservice. By contrast to the Location structure, ParkingArea receives the features aggregate and entity . It is thus a DDD Aggregate and DDD Entity . In DDD terms, this combination of patterns identifies ParkingArea as a root entity whose instances must support persistence, e.g., by storing them in a database. This latter characteristic is one of the fundamental differences between DDD Value Objects and Entities. The ParkingArea concept clusters seven data fields: id : This field is the identifier of the root entity and its value allows for distinguishing between ParkingArea instances. name and description : These String -typed data fields store the name and description of a ParkingArea . location : By contrast to the previous fields, location is not of a built-in primitive type but a custom complex type. More specifically, the field's type is the Location structure from the same context. Hence, a runtime value of the field will be a structure with the two nested fields latitude and longitude . Additionally, the field receives the part feature to express the intention that its values are always stored to and fetched from databases as part of the defining ParkingArea instance. This notion of aggregate-part-relationships follows DDD, in which aggregates determine a transactional boundary in the sense that the complex parts of an aggregate (i) are only accessible for callers using the aggregate; (ii) can only sensibly exist when their aggregate exists; and (iii) that they are in a valid state as prescribed by domain-specific rules when their aggregate is stored to or fetched from a database. chargerSpeed : This field informs about the speed by which the charging capabilities of a ParkingArea may provide electric vehicles with energy. Again, the field's type is a custom complex type, i.e., the ChargerSpeed enumeration. You will learn more about enumerations below. availability : This field stores information about the availability of a ParkingArea in the form of the two date fields start and end . Since a ParkingArea may be opened and closed at different times on different dates or time spans, the field's type is the custom collection TimePeriods . You will learn more about collections below. activated : This field enables to flexible activate and deactivate the charging capabilities of a ParkingArea , e.g., for maintenance purposes. Since the field must only maintain a true/false condition, it is of the built-in primitive type boolean . Enumeration Domain Concepts LEMMA's Domain Data Modeling Language supports the definition of enumerations in domain models. An enumeration domain concept is introduced by the enum keyword, followed by the enumeration name, and its literals in curly brackets. For example, the ChargerSpeed enumeration in the domain model for the ChargingStationManagement microservice defines the literals FAST and NORMAL for coarse-grained identification of the capacity of charging capabilities on a certain ParkingArea . Collection Domain Concepts Next to data structures and enumerations, LEMMA's Domain Data Modeling Language allows for defining collection domain concepts by means of the collection keyword, followed by the collection name, and the collection body in curly brackets. The domain model for the ChargingStationManagement microservice defines the TimePeriods collection. It clusters sequences of instances of the TimePeriod structure and is thus a structured collection type . In LEMMA, the structure of entries of a structured collection type is determined by the data fields in its body, e.g., TimePeriod p . Primitive collection types , on the other hand, exhibit bodies with exactly one built-in primitive type, e.g., int , and without an additional field name. Such collection types store sequences of primitive values. For instance, a hypothetical collection collection Numbers { int } stores an arbitrary amount of integer values. Additional Domain Concepts for Microservice Interaction Before you are going to create a service model for the ChargingStationManagement microservice in the upcoming Step 3 , you will first extend the above domain model with domain concepts dedicated to microservice interaction. After the TimePeriod structure, add the three structures CreateParkingAreaCommand , ParkingAreaInformation , and CreateParkingAreaCommandResponse to the domain model file ChargingStationManagement.data : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 context ChargingStationManagement { ... structure TimePeriod < valueObject > { immutable date start, immutable date end } // Domain concepts for microservice interaction structure CreateParkingAreaCommand < valueObject > { immutable ParkingAreaInformation info } structure ParkingAreaInformation < valueObject > { immutable string name, immutable string description, immutable Location location, immutable ChargerSpeed chargerSpeed, immutable TimePeriods availability, immutable boolean activated } structure CreateParkingAreaCommandResponse < valueObject > { immutable long id, immutable string errorMessage } } All three domain concepts are DDD Value Objects because the ChargingStationManagement microservice will use them to communicate information about parking areas to consumers. Note that the ParkingAreaInformation value object is a reduced version of the ParkingArea aggregate in the sense that it only comprises those data fields relevant to consumers. To foresee the required conversion of ParkingArea instances into ParkingAreaInformation instances, you could further extend the domain model with corresponding a LEMMA function signature in the ParkingArea aggregate: 1 2 3 4 5 6 7 8 9 10 11 12 context ChargingStationManagement { ... structure ParkingArea < aggregate , entity > { ... // Function signature to convert the current ParkingArea instance // into a ParkingAreaInformation instance function ParkingAreaInformation toParkingAreaInformation } ... } A LEMMA function signature starts with the function keyword, followed by the return type, and the name of the function. Potential input parameters follow in round brackets, and consist of a type and name. In case of an empty parameter list, the round brackets can be omitted as is the case for the toParkingAreaInformation function. LEMMA's Domain Data Modeling Language also supports procedure signatures for domain concept operations that do not return a value. A procedure signature starts with the procedure keyword, followed by the name of the procedure, and an optional parameter list. For instance, a hypothetical procedure signature procedure updateChargerSpeed(ChargerSpeed newSpeed) constitutes a procedure signature updateChargerSpeed with a single parameter newSpeed typed by the enumeration domain concept ChargerSpeed . The following listing shows the complete domain model file including the three domain concepts for microservice interaction and the toParkingAreaInformation function signature: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 context ChargingStationManagement { structure Location < valueObject > { immutable double latitude, immutable double longitude } structure ParkingArea < aggregate , entity > { long id < identifier > , string name, string description, Location location < part > , ChargerSpeed chargerSpeed, TimePeriods availability < part > , boolean activated, // Function signature to convert the current ParkingArea instance // into a ParkingAreaInformation instance function ParkingAreaInformation toParkingAreaInformation } enum ChargerSpeed { FAST, NORMAL } structure TimePeriod < valueObject > { immutable date start, immutable date end } collection TimePeriods { TimePeriod p } // Domain concepts for microservice interaction structure CreateParkingAreaCommand < valueObject > { immutable ParkingAreaInformation info } structure ParkingAreaInformation < valueObject > { immutable string name, immutable string description, immutable Location location, immutable ChargerSpeed chargerSpeed, immutable TimePeriods availability, immutable boolean activated } structure CreateParkingAreaCommandResponse < valueObject > { immutable long id, immutable string errorMessage } } Step 3: Create a Service Model In this step, we use LEMMA's Service Modeling Language to construct a service model for the ChargingStationManagement microservice. The modeling language covers the concerns of microservice developers, thereby providing a means to capture the service viewpoint on a microservice architecture. In the models folder of the charging-station-management Eclipse project, create a new folder called microservices and within that folder create another folder called command-side . Within the command-side folder, create a file called ChargingStationManagementCommandSide.services . The .services extension signals Eclipse that the file constitutes a LEMMA service model. The Project Explorer of your Eclipse workspace should now look similar to this: Rationale for the Folder Structure You may wonder why the service model file is nested within its own folder command-side and why it does not reside immediately within the folder microservices . The rationale for this folder structure is the fact that the PCSP applies the Command Query Responsibility Segregation (CQRS) pattern to organize its microservices. That is, each logical microservice consists of at most one physical command side microservice and one or more physical query side microservices . While the command side of a logical PCSP microservice is responsible for write actions like updating database entries, the query sides provide operations for read actions, e.g., querying database entries with certain characteristics. The query sides maintain their own databases and receive information about entry updates from command sides in an asynchronous fashion. As a result, CQRS permits independent scalability of write and read actions, of which the latter are usually much more frequent than the former, as well as the adoption of database technologies specialized for certain kinds of read actions, e.g., time series processing. For the tour of LEMMA, you will model the physical command side microservice of the logical ChargingStationManagement microservice. Consequently, we cluster related models in their own folder, i.e., command-side , and even attach the suffix `C Step 2 s, you can find them in LEMMA's GitHub repository in the /examples/charging-station-management/models/microservices/query-side folder. As for the initial domain model constructed in Step 2 , LEMMA does not allow empty service models and thus displays an error marker for the ChargingStationManagementCommandSide.services file. To fix this issue, add the following code in LEMMA's Service Modeling Language to the file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import datatypes from \"../../domain/ChargingStationManagement.data\" as Domain public functional microservice de.puls.ChargingStationManagementCommandSide { interface CommandSide { --- API endpoint for creating a parking area @requires command Command object to specify the values of the new parking area @returns response CreateParkingAreaCommandResponse with the identifier of the created parking area or an error message --- createParkingArea( sync in command : Domain::ChargingStationManagement.CreateParkingAreaCommand, sync out response : Domain::ChargingStationManagement.CreateParkingAreaCommandResponse ); } } Domain Concept Imports LEMMA's modeling languages provides the import keyword to enable integratation of models for the same or different viewpoints on a microservice architecture. import statements always have the following syntactic form: import [ELEMENT_TYPE] from \"[MODEL_PATH]\" as [ALIAS] In the above service model for the command side of the ChargingStationManagement microservice, the imported [ELEMENT_TYPE] is datatypes which accounts for the import of domain concepts in order to type service operation parameters (see below). The [MODEL_PATH] points to the ChargingStationManagement.data that you constructed in Step 2 . Instead of the relative path from the folder that holds the service model file, i.e., models/microservices/command-side , to the folder that holds the domain model file, i.e., models/domain , you could also specify the absolute path to the imported domain model, e.g., /home/user/lemma-tour/models/domain/ChargingStationManagement.data . Finally, the [ALIAS] of an import statement determines a shorthand name for referencing imported model elements. In the above service model, all concepts imported from the domain model ChargingStationManagement.data are to be referenced under the alias Domain . Microservice Definition In LEMMA's Service Modeling Language , a microservice definition is introduced by an optional visibility modifier , followed by a mandatory service type identifier , the keyword microservice , and the fully-qualified name of the microservice. In the above command side service model, the visibility modifier for the ChargingStationManagementCommandSide microservice is public to express the intent that the microservice shall be available to consumers that are not part of the same microservice architecture. Microservices without an explicit visibility modifier receive have architecture visibility, i.e., they are visible only to consumers that belong to the same architecture and are not to be exposed to external consumers. The service type identifier is functional which marks the microservice to fulfill a functional, usually business-oriented, capability within the PCSP. Other service type identifiers are infrastructure (the microservice provides an infrastructure capability, e.g., monitoring) and utility (the microservice provides a reusable utility capability that is not motivated by only a single business case, e.g., currency conversion). The microservice keyword is followed by the name of the microservice. A microservice name must have at least one qualifying level to determine the microservice's namespace . Qualifying levels are separated by dots ( . ) and all qualifying levels except the last one constitute the microservice's namespace 3 . Consequently, the fully-qualified name of the ChargingStationManagementCommandSide microservice is de.puls.ChargingStationManagementCommandSide . It consists of the namespace de.puls and the microservice's simple name ChargingStationManagementCommandSide . Interface Definition The definition of a microservice ends with a pair of curly brackets that cluster the service's interfaces. In LEMMA, each microservice must comprise at least one interface, and each interface specifies a single portion of the service's API 4 as a collection of one or more service operations (see below). LEMMA's Service Modeling Language , provides the interface keyword to introduce an interface. The keyword is followed by the name of the interface. That is, the above service model for the ChargingStationManagementCommandSide microservice defines a single interface called CommandSide . Like microservices, interfaces can receive visibility modifiers. Without an explicit visibility modifier, interfaces inherit the visibility of their defining microservices. As a result, the visibility of the CommandSide interface is public as this is the visibility of the ChargingStationManagementCommandSide microservice. Operation Definition The definition of an interface ends with a pair of curly brackets that cluster the interface's operation. In LEMMA, each interface must comprise at least one operation. An operation definition does not require an introductory keyword. Instead, you state the name of the operation, followed by a pair of round brackets for possible parameters, and a semicolon to end the operation definition. Thus, in the above service model for the ChargingStationManagementCommandSide microservice, the CommandSide interface consists of a single operation createParkingArea which has two parameters (see below). LEMMA's Service Modeling Language also integrates a special syntax for API operation comments . It allows the documentation of an operation's purpose and can later be translated, e.g., into OpenAPI specifications . An API operation comment has to occur before the operation's definition and within a pair of three consecutive dashes ( --- ). Hence, the createParkingArea operation exhibits the API operation comment API endpoint for creating a parking area . Operation parameters may also receive a documentation as part of an API operation comment. For this purpose, LEMMA provides the built-in annotations @param , @requires , and @returns . @param and @requires document incoming operation parameters that are either optional ( @param ) or mandatory ( @requires ). @returns , on the other hand, documents outgoing operation parameters. After a built-in documentation annotation, the name of the parameter and the documentation comment follow. In the above service model for the ChargingStationManagementCommandSide microservice, you documented the purpose of the createParkingArea operation's incoming parameter command and the outgoing parameter response , respectively. Parameter Definition A modeled service operation may receive and return an arbitrary number of parameters. A parameter definition starts with a keyword that identifies the parameter's communication type . The sync keyword introduces parameters that an operation expects to receive or promises to return synchronously. The async keyword, on the other hand, introduces parameters that an operation expects to receive or promises to return asynchronously. Next to a communication type, a parameter definition in LEMMA's Service Modeling Language can explicitly state the direction of a parameter which can be incoming ( in modifier), outgoing ( out modifier), or bidirectional ( inout modifier). In case a parameter definition omits a direction modifier, the parameter is assumed to be incoming. A parameter definition is concluded by the parameter's name, a colon, and the parameter's type. The type of a parameter may either be a built-in primitive type like int or String , or a domain concept imported from a LEMMA domain model (see above). To reference an imported domain concept for typing purposes, you first have to state the alias of the import, e.g., Domain , followed by two consecutive colons ( :: ), and the fully-qualified name of the concept within the imported domain model. The fully-qualified name of a domain concept consists of the name of the concept's context and the name of the concept itself separated by a dot. The following table identifies the communication type, direction, and type of each parameter of the createParkingArea operation from the above service model for the ChargingStationManagementCommandSide microservice Parameter Communication Type Direction Type command synchronous ( sync ) incoming ( in ) CreateParkingAreaCommand domain concept (from context ChargingStationManagement of imported model with alias Domain ) response synchronous ( sync ) outgoing ( out ) CreateParkingAreaCommandResponse domain concept (from context ChargingStationManagement of imported model with alias Domain ) From the definitions of its parameters, we can phrase the purpose of the createParkingArea operation in natural language as follows: Purpose of the createParkingArea operation in natural language Take a command object comprising all relevant information to create a new parking area as input, execute, and return a response to the caller consisting of the identifier of the new parking area and/or an error message. Since both parameters are marked as synchronous, the invocation of createParkingArea is blocking for callers, i.e., they should wait for a response before they can proceed sensibly. Step 4: Enrich the Service Model with Technology Information So far, we have used LEMMA's Domain Data Modeling Language and Service Modeling Language to construct the domain model of the logical ChargingStationManagement microservice and the service model for its phyiscal command side microservice ( de.puls.ChargingStationManagementCommandSide ), respectively. Recall that LEMMA organizes its modeling languages into different architecture viewpoints on microservice architectures. That is, the domain model reifies the concepts of the domain view on the ChargingStationManagement microservice and the command side service model represents a portion of the service view on the microservice. Next to domain and service characteristics, another crucial aspect of MSA-based applications is technology or, more precisely, the possibility to employ an arbitrary number of heterogeneous technologies for microservice implementation and deployment 5 . LEMMA treats technology heterogeneity as a dedicated concern in microservice implementation and thus provides the Technology Modeling Language to cluster technology information in technology models that are flexibly applicable to modeled microservices. In the following, you will enrich the above technology-agnostic service model for the ChargingStationManagementCommandSide microservice with technology information for Java and the Spring framework . While this step binds the microservice to a certain technology stack, it also allows for generating executable code from the model, as we will see below. Before you can extend the service model with technology information, you are first required to construct or download LEMMA technology models for the desired technologies. As a first step, create a folder called technology in the models folder of the charging-station-management Eclipse project. Next, create the two files Java.technology and Spring.technology within the folder. The extension .technology informs Eclipse that the files are to comprise models expressed in LEMMA's Technology Modeling Language . The Project Explorer of your Eclipse workspace should now look similar to this: Next, copy the contents of the following two listings to the corresponding technology model file. Note Here, we will not go into further details concerning the construction of technology models. Please refer to the user guide of the Technology Modeling Language to learn about technology model construction. Additionally, the following two listings only comprise technology information relevant to the tour of LEMMA. You can follow these links to LEMMA's GitHub repository in order to examine the complete model contents: Java.technology , Spring.technology . Java.technology 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 technology Java { types { primitive type Boolean based on boolean default ; primitive type Byte based on byte default ; primitive type Character based on char default ; primitive type Date based on date default ; primitive type Double based on double default ; primitive type Float based on float default ; primitive type Integer based on int default ; primitive type Long based on long default ; primitive type Short based on short default ; primitive type String based on string default ; primitive type Object based on unspecified default ; } } Spring.technology 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 technology Spring { protocols { sync rest data formats \"application/json\" default with format \"application/json\" ; } service aspects { aspect Application < singleval > for microservices { string name; int port; } aspect DatasourceConfiguration for microservices { string driverClassName = \"org.h2.Driver\" ; string url < mandatory > ; string username < mandatory > ; string password < mandatory > ; } aspect Post < singleval > for operations { selector (protocol = rest); } aspect RequestBody < singleval > for parameters { selector (exchange_pattern = in); } aspect ResponseEntity < singleval > for parameters { selector (protocol = rest, exchange_pattern = out); } aspect Valid < singleval > for parameters ; } } With the technology models at hand, you can now turn the technology-agnostic service model for the ChargingStationManagementCommandSide microservice into a technology-specific service model. The following listing shows the result of this step and therefore identifies the technology extensions with // EXTENSION comments: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import datatypes from \"../../domain/ChargingStationManagement.data\" as Domain // EXTENSION (1) import technology from \"../../technology/Java.technology\" as Java // EXTENSION (2) import technology from \"../../technology/Spring.technology\" as Spring // EXTENSION (3) @technology (Java) // EXTENSION (4) @technology (Spring) // EXTENSION (5) @Spring::_aspects.Application (name= \"ChargingStationManagementCommandSide\" ) // EXTENSION (6) @Spring::_aspects.DatasourceConfiguration ( url = \"jdbc:h2:mem:command-side-db\" , username = \"${COMMAND_SIDE_SERVICE_DB_USER}\" , password = \"${COMMAND_SIDE_SERVICE_DB_PASSWORD}\" ) public functional microservice de.puls.ChargingStationManagementCommandSide { // EXTENSION (7) @endpoints (Spring::_protocols.rest: \"/resources\" ;) interface CommandSide { --- API endpoint for creating a parking area @requires command Command object to specify the values of the new parking area @returns response CreateParkingAreaCommandResponse with the identifier of the created parking area or an error message --- // EXTENSION (8) @endpoints (Spring::_protocols.rest: \"/parkingarea\" ;) // EXTENSION (9) @Spring::_aspects.Post createParkingArea( // EXTENSION (10) @Spring::_aspects.RequestBody // EXTENSION (11) @Spring::_aspects.Valid sync in command : Domain::ChargingStationManagement.CreateParkingAreaCommand, // EXTENSION (12) @Spring::_aspects.ResponseEntity sync out response : Domain::ChargingStationManagement.CreateParkingAreaCommandResponse ); } } Technology Model Imports and Applications Extensions (1) and (2) import the constructed Java and Spring technology models into the service model. The syntax for technology model imports is almost identical to that for domain model imports (see above). Specifically, technology model imports differ only for the import statement's [ELEMENT_TYPE] which receives the value technology instead of datatypes . Extensions (3) and (4) apply the imported technology models to the ChargingStationManagementCommandSide microservice using the Service Modeling Language's built-in @technology annotation. The annotation specifies in round brackets the aliases of the imported technology models to apply to a microservice. The application of technology models to microservices is necessary to express that a microservice depends on a certain technology and also makes technology aspects available for that microservice. Technology Aspect Applications In LEMMA, the syntax for technology aspect application follows this pattern: @[IMPORTED_TECHNOLOGY_MODEL_ALIAS]::_aspects.[ASPECT_NAME]([POTENTIAL_ASPECT_PROPERTIES]) Extensions (5) , (6) , and (9) to (12) rely on this syntactical pattern to apply technology aspects from the imported Spring technology model to the ChargingStationManagementCommandSide microservice, its createParkingArea operation, and the operation's parameters. The following table describes the semantics of the applied Spring aspects: Extension Applied Aspect Targeted Model Element Semantics (5) Application ChargingStationManagementCommandSide microservice The aspect allows configuring of certain Core Properties of Spring Applications . Using the aspect's name property as illustrated by the above service model, it is for example possible to determine a value for Spring's spring.application.name Core Property. (6) DatasourceConfiguration ChargingStationManagementCommandSide microservice The aspect allows configuring of certain Data Properties of Spring Applications . For instance, the aspect's url , username , and password properties support the specification of values for Spring's spring.datasource.url , spring.datasource.username , and spring.datasource.password Data Properties, as shown in the above service model. (9) Post createParkingArea operation The aspect maps to Spring's @PostMapping annotation . (10) RequestBody command parameter The aspect maps to Spring's @RequestBody annotation . (11) Valid command parameter The aspect maps to the @Valid annotation from the Bean Validation API for Java. (12) ResponseEntity response parameter The aspect maps to Spring's @ResponseEntity annotation . In general, it is in the responsibility of LEMMA model processors (see below) to process technology aspects in a sensible manner. For example, in the above model for the ChargingStationManagementCommandSide microservice, the name property in the application of the Application aspect on the microservice receives the value \"ChargingStationManagementCommandSide\". LEMMA's code generator for Java and Spring (see below) will leverage this information from the aspect application to produce the entry spring.application.name=\"ChargingStationManagementCommandSide\" in the application.properties file for the microservice. Similarly, the generator will produce the @PostMapping annotation on the Java method it derives from the createParkingArea microservice operation because the service model applies the corresponding Post aspect on the modeled operation. Increase of LEMMA's Expressiveness by the Aspect Mechanism LEMMA's technology aspect mechanism is not constrained to the configuration of technology-related characteristics alone. More precisely, the Technology Modeling Language does not constrain the semantic scope of aspect-based metadata, thereby making technology aspects a powerful feature that allows semantic enrichment of LEMMA models as required. For instance, technology aspects can be used to integrate patterns such as CQRS with LEMMA. A corresponding technology model can be found in LEMMA's GitHub repository in the /examples/charging-station-management/models/technology/Cqrs.technology file. Communication Protocol Endpoints Extensions (7) and (8) of the service model for the ChargingStationManagementCommandSide microservice configure communication protocol endpoints for the CommandSide interface and createParkingArea operation. Endpoint configurations follow this syntactical pattern: @endpoints([COMMUNICATION_PROTOCOL_REFERENCE]): \"[ENDPOINT_ADDRESSES]\" For the configuration of communication protocol endpoints, LEMMA's Service Modeling Language integrates the built-in annotation @endpoints . Applications of the annotation first reference in round brackets the communication protocol for which one or more endpoints shall be configured. The existence of communication protocols is specified within technology models. For example, the Spring.technology model that you constructed in the previous step, includes a definition of the rest protocol that maps to the eponymous architectural style . Within an endpoint configuration, we can refer to the communication protocol following a syntactical pattern very similar to technology aspect references within aspect applications: [IMPORTED_TECHNOLOGY_MODEL_ALIAS]::_protocols.[COMMUNICATION_PROTOCOL_NAME] Hence, to refer to the rest protocol from the Spring.technology model imported by the above service model under the Spring alias, you use the Spring::_protocols.rest statement in the applications of the @endpoints annotation on the CommandSide interface and createParkingArea operation. References to communication protocols within @endpoints annotations are followed by a colon and a list of endpoint addresses separated by commas. For the CommandSide interface and createParkingArea operation, the above service model specifies the endpoint addresses \"/resources\" and \"/parkingarea\", respectively. Step 5: Generate Java Code from the Service Model In the previous step, we enriched the service model with technology information that is can be used to map the model to executable Java code. In general, the process of mapping abstract model code to executable code in a programming language is called code generation . When focusing on Java and the Spring framework as the target environment for executable microservices, an intuitive mapping of the service model could consider, among others, the following relationships between model elements and Java code fragments: Map the modeled ChargingStationManagementCommandSide microservice to an eponymous Java class. Map the modeled CommandSide interface to an eponymous Java class. Since the interface exhibits a rest endpoint, add Spring's @RestController annotation to the class. Furthermore, configure the endpoint's \"/resources\" address for the interface by applying Spring's @RequestMapping annotation in the form @RequestMapping(value = {\"/resources\"}) . Map the modeled createParkingArea operation to a method within the Java class for the CommandSide interface. Among others, the method exhibits an application of Spring's @RequestMapping annotation for the \"/parkingarea\" rest endpoint, an application of Spring's PostMapping annotation (from the application of the @Post aspect on the modeled operation), and Java counterparts for the command and response parameters of the modeled operation. To obtain an executable, Java- and Spring-based microservice implementation from the above service model, you can leverage an Eclipse plugin that came as part of your LEMMA installation . You can activate the plugin by clicking on the \"Run As\"-button ( ) in Eclipse's menu bar or choose the \"Run\" entry from Eclipse's \"Run\" menu. Independent of whether you clicked the button or the menu entry, it is important that the service model is the current editor in the open Eclipse instance. If that is the case, the following dialog window will appear after clicking the button or the menu entry: In the window, hit the \"OK\" button which will result in the following dialog window to appear: Since you are going to generate executable microservice code from the service model via the Docker image of LEMMA's Java code generator , you can click on \"Continue\" thereby activating the following dialog window: This last dialog window allows for configuring the Java code generator. In fact, you can leave all configuration text boxes in their default state and only have to specify a target folder for the generated Java code. To this end, hit the \"Browse...\"-button next to the \"Generation target folder\" text box and select the \"src\" folder from the charging-station-management Eclipse project. The configuration dialog window should then look similar to this: Missing Java Base Generator Docker Image In case the dialog window displays an error marker for the \"Java Base Generator Docker image\" text box stating that the proposed lemma/java_generator:latest Docker image does not exist, it is likely the case that you did not rename the pulled image using the docker tag command as described in the \"Prerequisites\" section above. If that is the case, hit the \"Browse...\" button next to the \"Java Base Generator Docker image\" text box and select the Docker image with name lemmahub/java_generator:latest from the appearing dialog window. Finally, hit the \"Run\" button to start LEMMA's Java code generator on the service model for the ChargingStationManagementCommandS\u00edde microservice. Reusable Eclipse Run Configuration With hitting the \"Run\" button, LEMMA's Eclipse plugin for model processor execution will silently create an Eclipse Run Configuration called \"Run_JBG_Docker_ChargingStationManagementCommandSide_services\". You can review the Run Configuration within Eclipse using the menu entry \"Run > Run Configurations...\" and selecting the configuration from the launch group \"LEMMA Model Processor\" on the left side of the appearing dialog window. In the dialog window, you can hit the \"Show Command Line\" to review the command that the Run Configuration will execute on your system to run the Java code generator in a Docker container. The output of the button looks similar to this: The Run Configuration is reusable so that you do not have to complete the previous dialog window each time you want to re-generate code from the model. Instead, each time you click the \"Run As\"-button ( ) in the future while having the service model for the ChargingStationManagementCommandS\u00edde microservice opened in the active Eclipse editor, the Run Configuration will directly be executed. LEMMA's Eclipse plugin for model processor execution opens an Eclipse Console informing you about the various steps of the code generation process. The console message Model processor execution finished informs you about the success of the code generation process, which usually takes five to ten seconds. Step 7: Compile and Review the Generated Code After the code generation process finished, you can find the generated code in the \"src\" folder of the charging-station-management Eclipse project. Since LEMMA's Java code generator aims to produce all necessary artifacts for compiling and executing a microservice, you can find a pom.xml for the Maven build management system in the src/de/puls/ChargingStationManagementCommandSide folder. In case you have Maven and Java 11 or greater installed on your system, you can compile the generated code using the following command in the src/de/puls/ChargingStationManagementCommandSide folder: 1 mvn package After the command finished, the resulting Java archive can be found in the src/de/puls/ChargingStationManagementCommandSide/target folder within the charging-station-management-command-side-0.0.1-SNAPSHOT.jar file. From the src/de/puls/ChargingStationManagementCommandSidemain/java/de/puls/ChargingStationManagementCommandSide folder, you can also review the generated Java code. For example, you may want to have a look at the following files: ChargingStationManagementCommandSide.java : Class implementing the Spring entry point of the ChargingStationManagementCommandSide microservice. interfaces/CommandSide.java : Class implementing the modeled CommandSide interface and a method stub for the createParkingArea operation. domain/ChargingStationManagement/* : All classes obtained from the domain concepts comprised in the domain model for the ChargingStationManagement . Note how the Java code for the microservice, interface, and operation is consistent to the intuitive mapping described in Step 5 . MSA: The M icro s ervice A rchitecture style. \u21a9 Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9 This mechanism in fact follows the rules for package declarations in Java. \u21a9 API: Application Programming Interface (cf. https://en.wikipedia.org/wiki/API for a definition of the term). \u21a9 In fact, technology heterogeneity may be considered one of the benefits of MSA as it enables to employ the most sufficient technologies for microservice implementation and deployment. On the other hand, it can make microservices prone to technical debt and increase the learning curve for new team members. Careful consideration of the existing degree of technology heterogeneity is thus required before deciding for the adoption of new technologies such as programming languages, frameworks, databases, API gateways, or monitoring tools. \u21a9","title":"Tour"},{"location":"getting-started/tour/#tour","text":"In the following, we demonstrate some of the basic features of LEMMA regarding the construction and processing of microservice architecture models.","title":"Tour"},{"location":"getting-started/tour/#prerequisites","text":"To reproduce the presented modeling steps , you should first install LEMMA on your computer. To reproduce the presented model processing steps , the easiest way is to employ the Docker images of LEMMA's Java and deployment code generators. An installation of LEMMA already comes with an Eclipse plugin to simplify the usage of these images. However, the plugin uses Docker to instrument and execute the images so that you are required to install Docker on your computer as an additional technology. After having installed Docker, you can retrieve the images of LEMMA's Java and deployment code generators using the following commands in a commandline terminal that can access your Docker installation: 1 2 3 4 5 docker pull lemmahub/java_generator docker tag lemmahub/java_generator:latest lemma/java_generator:latest docker pull lemmahub/deployment_base_generator docker tag lemmahub/deployment_base_generator:latest lemma/deployment_base_generator:latest","title":"Prerequisites"},{"location":"getting-started/tour/#the-charging-station-management-example","text":"For the tour of LEMMA, we leverage a single microservice from an MSA 1 -based application as example. Basically, the application supports the management of parking spaces that are equipped with charging stations for electric vehicles. In the following, we will refer to this application as the \"Park and Charge Software Platform\", or short PCSP. The PCSP consists of several microservices, e.g., for user management, charging station search, and charging station management. For the tour of LEMMA, we will model the domain data, API, and deployment of the latter microservice, i.e., the ChargingStationManagement microservice. This microservice shall provide its clients with means to create parking spaces with charging stations at a specific location. Learn More About the PCSP You can learn more about the PCSP, and the rationale and decisions concerning its design in Sections 8.3 to 8.5 of the dissertation that conceived LEMMA 2 .","title":"The Charging Station Management Example"},{"location":"getting-started/tour/#what-you-will-learn-during-the-tour","text":"In the following you will learn how to construct the following types of LEMMA models for the ChargingStationManagement microservice: Domain model: Defines the domain data of the microservice. Service model: Defines the API of the microservice. Operation model: Defines the deployment of the microservice. In addition, you will receive an impression on how model processing works with LEMMA. More specifically, you will learn how to derive executable Java code from the constructed models. The next sections will teach you how to construct the aforementioned LEMMA models for the ChargingStationManagement microservice by means of a LEMMA-enabled Eclipse installation . If you do not want to construct the models on your own, you can also find them in LEMMA's GitHub repository in the /examples/charging-station-management/models folder.","title":"What You Will Learn During the Tour"},{"location":"getting-started/tour/#step-1-create-an-eclipse-project","text":"Run your LEMMA-enabled Eclipse installation and create a new Java project called charging-station-management . We will use this project to gather all models for the ChargingStationManagement microservice. In addition, create a folder called models within the project. The Project Explorer of your Eclipse workspace should now look similar to this:","title":"Step 1: Create an Eclipse Project"},{"location":"getting-started/tour/#step-2-create-a-domain-model","text":"LEMMA provides several modeling languages to express different viewpoints on a microservice architecture. A crucial viewpoint in almost every software project including MSA-based applications is the domain viewpoint . Therefore, LEMMA comprises the Domain Data Modeling Language to enable domain experts and microservice developers to collaboratively construct domain models . You will now create a LEMMA domain model for the ChargingStationManagement microservice by means of the Eclipse IDE. To this end, you first create a folder called domain in the models folder of the previously created charging-station-management Eclipse project. Next, you create a file called ChargingStationManagement.data within the domain folder. In case a dialog pops up, asking you to convert the charging-station-management project to an Xtext project, just confirm it with Yes . The .data extension of the domain model file is crucial as it signals Eclipse that the file constitutes a LEMMA domain model for which a dedicated Eclipse editor with syntax highlighting and interactive model validation exists. After having created the domain folder and the ChargingStationManagement.data in it, the Project Explorer of your Eclipse workspace should now look similar to this: Eclipse shows an error marker for the new model file because LEMMA's Domain Data Modeling Language does not allow empty domain models. To fix this issue, add the following model code to the ChargingStationManagement.data file by double-clicking the file in Eclipse's Project Explorer and entering the code in the text editor that just opened: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 context ChargingStationManagement { structure Location < valueObject > { immutable double latitude, immutable double longitude } structure ParkingArea < aggregate , entity > { long id < identifier > , string name, string description, Location location < part > , ChargerSpeed chargerSpeed, TimePeriods availability < part > , boolean activated } enum ChargerSpeed { FAST, NORMAL } collection TimePeriods { TimePeriod p } structure TimePeriod < valueObject > { immutable date start, immutable date end } }","title":"Step 2: Create a Domain Model"},{"location":"getting-started/tour/#bounded-contexts","text":"The Domain Data Modeling Language enables to organize the concepts of a microservice's domain excerpt within contexts . LEMMA's notion of context is inspired by the Bounded Context pattern from Domain-driven Design (DDD) and its importance for the tailoring of microservices' domain responsibilities . For the definition of contexts, the Domain Data Modeling Language provides the context keyword, which must be followed by the name of the context, and a pair of curly brackets to comprise the context's domain concepts (see below). Based on the context keyword, the domain model of the ChargingStationManagement microservice defines the ChargingStationManagement context as a cluster for its domain concepts. LEMMA supports three different kinds of domain concepts.","title":"Bounded Contexts"},{"location":"getting-started/tour/#structured-domain-concepts-and-domain-driven-design","text":"A structured domain concept (or data structure ) is introduced by the structure keyword, followed by the name of the structure, and an arbitrary number of features . In LEMMA domain models, a feature assigns additional semantics, e.g., from patterns for tactical DDD , to a domain concept. Consider the Location structure from the domain model of the ChargingStationManagement microservice. It receives the valueObject feature to identify it as a DDD Value Object . A data structure can define an arbitrary number of typed and named data fields within curly brackets. In total, the Location structure consists of the two data fields latitude and longitude , both being typed as double s. LEMMA supports all of Java's primitive types , and also has built-in types for date s and String s. Next to their types and names, both data fields of the Location structure also exhibit the immutable modifier. It signals that fields can only receive values during the instantiation of of their defining structure. Afterwards, the values remain stable for the instance's lifetime and are not modifiable by callers. Since the primary use of DDD Value Objects is information sharing, e.g., in the form of [Data Transfer Objects]https://www.martinfowler.com/eaaCatalog/dataTransferObject.html, it is a best practice to flag their fields as immutable . The ParkingArea concept is another example of a data structure in the domain model of the ChargingStationManagement microservice. By contrast to the Location structure, ParkingArea receives the features aggregate and entity . It is thus a DDD Aggregate and DDD Entity . In DDD terms, this combination of patterns identifies ParkingArea as a root entity whose instances must support persistence, e.g., by storing them in a database. This latter characteristic is one of the fundamental differences between DDD Value Objects and Entities. The ParkingArea concept clusters seven data fields: id : This field is the identifier of the root entity and its value allows for distinguishing between ParkingArea instances. name and description : These String -typed data fields store the name and description of a ParkingArea . location : By contrast to the previous fields, location is not of a built-in primitive type but a custom complex type. More specifically, the field's type is the Location structure from the same context. Hence, a runtime value of the field will be a structure with the two nested fields latitude and longitude . Additionally, the field receives the part feature to express the intention that its values are always stored to and fetched from databases as part of the defining ParkingArea instance. This notion of aggregate-part-relationships follows DDD, in which aggregates determine a transactional boundary in the sense that the complex parts of an aggregate (i) are only accessible for callers using the aggregate; (ii) can only sensibly exist when their aggregate exists; and (iii) that they are in a valid state as prescribed by domain-specific rules when their aggregate is stored to or fetched from a database. chargerSpeed : This field informs about the speed by which the charging capabilities of a ParkingArea may provide electric vehicles with energy. Again, the field's type is a custom complex type, i.e., the ChargerSpeed enumeration. You will learn more about enumerations below. availability : This field stores information about the availability of a ParkingArea in the form of the two date fields start and end . Since a ParkingArea may be opened and closed at different times on different dates or time spans, the field's type is the custom collection TimePeriods . You will learn more about collections below. activated : This field enables to flexible activate and deactivate the charging capabilities of a ParkingArea , e.g., for maintenance purposes. Since the field must only maintain a true/false condition, it is of the built-in primitive type boolean .","title":"Structured Domain Concepts and Domain-Driven Design"},{"location":"getting-started/tour/#enumeration-domain-concepts","text":"LEMMA's Domain Data Modeling Language supports the definition of enumerations in domain models. An enumeration domain concept is introduced by the enum keyword, followed by the enumeration name, and its literals in curly brackets. For example, the ChargerSpeed enumeration in the domain model for the ChargingStationManagement microservice defines the literals FAST and NORMAL for coarse-grained identification of the capacity of charging capabilities on a certain ParkingArea .","title":"Enumeration Domain Concepts"},{"location":"getting-started/tour/#collection-domain-concepts","text":"Next to data structures and enumerations, LEMMA's Domain Data Modeling Language allows for defining collection domain concepts by means of the collection keyword, followed by the collection name, and the collection body in curly brackets. The domain model for the ChargingStationManagement microservice defines the TimePeriods collection. It clusters sequences of instances of the TimePeriod structure and is thus a structured collection type . In LEMMA, the structure of entries of a structured collection type is determined by the data fields in its body, e.g., TimePeriod p . Primitive collection types , on the other hand, exhibit bodies with exactly one built-in primitive type, e.g., int , and without an additional field name. Such collection types store sequences of primitive values. For instance, a hypothetical collection collection Numbers { int } stores an arbitrary amount of integer values.","title":"Collection Domain Concepts"},{"location":"getting-started/tour/#additional-domain-concepts-for-microservice-interaction","text":"Before you are going to create a service model for the ChargingStationManagement microservice in the upcoming Step 3 , you will first extend the above domain model with domain concepts dedicated to microservice interaction. After the TimePeriod structure, add the three structures CreateParkingAreaCommand , ParkingAreaInformation , and CreateParkingAreaCommandResponse to the domain model file ChargingStationManagement.data : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 context ChargingStationManagement { ... structure TimePeriod < valueObject > { immutable date start, immutable date end } // Domain concepts for microservice interaction structure CreateParkingAreaCommand < valueObject > { immutable ParkingAreaInformation info } structure ParkingAreaInformation < valueObject > { immutable string name, immutable string description, immutable Location location, immutable ChargerSpeed chargerSpeed, immutable TimePeriods availability, immutable boolean activated } structure CreateParkingAreaCommandResponse < valueObject > { immutable long id, immutable string errorMessage } } All three domain concepts are DDD Value Objects because the ChargingStationManagement microservice will use them to communicate information about parking areas to consumers. Note that the ParkingAreaInformation value object is a reduced version of the ParkingArea aggregate in the sense that it only comprises those data fields relevant to consumers. To foresee the required conversion of ParkingArea instances into ParkingAreaInformation instances, you could further extend the domain model with corresponding a LEMMA function signature in the ParkingArea aggregate: 1 2 3 4 5 6 7 8 9 10 11 12 context ChargingStationManagement { ... structure ParkingArea < aggregate , entity > { ... // Function signature to convert the current ParkingArea instance // into a ParkingAreaInformation instance function ParkingAreaInformation toParkingAreaInformation } ... } A LEMMA function signature starts with the function keyword, followed by the return type, and the name of the function. Potential input parameters follow in round brackets, and consist of a type and name. In case of an empty parameter list, the round brackets can be omitted as is the case for the toParkingAreaInformation function. LEMMA's Domain Data Modeling Language also supports procedure signatures for domain concept operations that do not return a value. A procedure signature starts with the procedure keyword, followed by the name of the procedure, and an optional parameter list. For instance, a hypothetical procedure signature procedure updateChargerSpeed(ChargerSpeed newSpeed) constitutes a procedure signature updateChargerSpeed with a single parameter newSpeed typed by the enumeration domain concept ChargerSpeed . The following listing shows the complete domain model file including the three domain concepts for microservice interaction and the toParkingAreaInformation function signature: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 context ChargingStationManagement { structure Location < valueObject > { immutable double latitude, immutable double longitude } structure ParkingArea < aggregate , entity > { long id < identifier > , string name, string description, Location location < part > , ChargerSpeed chargerSpeed, TimePeriods availability < part > , boolean activated, // Function signature to convert the current ParkingArea instance // into a ParkingAreaInformation instance function ParkingAreaInformation toParkingAreaInformation } enum ChargerSpeed { FAST, NORMAL } structure TimePeriod < valueObject > { immutable date start, immutable date end } collection TimePeriods { TimePeriod p } // Domain concepts for microservice interaction structure CreateParkingAreaCommand < valueObject > { immutable ParkingAreaInformation info } structure ParkingAreaInformation < valueObject > { immutable string name, immutable string description, immutable Location location, immutable ChargerSpeed chargerSpeed, immutable TimePeriods availability, immutable boolean activated } structure CreateParkingAreaCommandResponse < valueObject > { immutable long id, immutable string errorMessage } }","title":"Additional Domain Concepts for Microservice Interaction"},{"location":"getting-started/tour/#step-3-create-a-service-model","text":"In this step, we use LEMMA's Service Modeling Language to construct a service model for the ChargingStationManagement microservice. The modeling language covers the concerns of microservice developers, thereby providing a means to capture the service viewpoint on a microservice architecture. In the models folder of the charging-station-management Eclipse project, create a new folder called microservices and within that folder create another folder called command-side . Within the command-side folder, create a file called ChargingStationManagementCommandSide.services . The .services extension signals Eclipse that the file constitutes a LEMMA service model. The Project Explorer of your Eclipse workspace should now look similar to this: Rationale for the Folder Structure You may wonder why the service model file is nested within its own folder command-side and why it does not reside immediately within the folder microservices . The rationale for this folder structure is the fact that the PCSP applies the Command Query Responsibility Segregation (CQRS) pattern to organize its microservices. That is, each logical microservice consists of at most one physical command side microservice and one or more physical query side microservices . While the command side of a logical PCSP microservice is responsible for write actions like updating database entries, the query sides provide operations for read actions, e.g., querying database entries with certain characteristics. The query sides maintain their own databases and receive information about entry updates from command sides in an asynchronous fashion. As a result, CQRS permits independent scalability of write and read actions, of which the latter are usually much more frequent than the former, as well as the adoption of database technologies specialized for certain kinds of read actions, e.g., time series processing. For the tour of LEMMA, you will model the physical command side microservice of the logical ChargingStationManagement microservice. Consequently, we cluster related models in their own folder, i.e., command-side , and even attach the suffix `C Step 2 s, you can find them in LEMMA's GitHub repository in the /examples/charging-station-management/models/microservices/query-side folder. As for the initial domain model constructed in Step 2 , LEMMA does not allow empty service models and thus displays an error marker for the ChargingStationManagementCommandSide.services file. To fix this issue, add the following code in LEMMA's Service Modeling Language to the file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import datatypes from \"../../domain/ChargingStationManagement.data\" as Domain public functional microservice de.puls.ChargingStationManagementCommandSide { interface CommandSide { --- API endpoint for creating a parking area @requires command Command object to specify the values of the new parking area @returns response CreateParkingAreaCommandResponse with the identifier of the created parking area or an error message --- createParkingArea( sync in command : Domain::ChargingStationManagement.CreateParkingAreaCommand, sync out response : Domain::ChargingStationManagement.CreateParkingAreaCommandResponse ); } }","title":"Step 3: Create a Service Model"},{"location":"getting-started/tour/#domain-concept-imports","text":"LEMMA's modeling languages provides the import keyword to enable integratation of models for the same or different viewpoints on a microservice architecture. import statements always have the following syntactic form: import [ELEMENT_TYPE] from \"[MODEL_PATH]\" as [ALIAS] In the above service model for the command side of the ChargingStationManagement microservice, the imported [ELEMENT_TYPE] is datatypes which accounts for the import of domain concepts in order to type service operation parameters (see below). The [MODEL_PATH] points to the ChargingStationManagement.data that you constructed in Step 2 . Instead of the relative path from the folder that holds the service model file, i.e., models/microservices/command-side , to the folder that holds the domain model file, i.e., models/domain , you could also specify the absolute path to the imported domain model, e.g., /home/user/lemma-tour/models/domain/ChargingStationManagement.data . Finally, the [ALIAS] of an import statement determines a shorthand name for referencing imported model elements. In the above service model, all concepts imported from the domain model ChargingStationManagement.data are to be referenced under the alias Domain .","title":"Domain Concept Imports"},{"location":"getting-started/tour/#microservice-definition","text":"In LEMMA's Service Modeling Language , a microservice definition is introduced by an optional visibility modifier , followed by a mandatory service type identifier , the keyword microservice , and the fully-qualified name of the microservice. In the above command side service model, the visibility modifier for the ChargingStationManagementCommandSide microservice is public to express the intent that the microservice shall be available to consumers that are not part of the same microservice architecture. Microservices without an explicit visibility modifier receive have architecture visibility, i.e., they are visible only to consumers that belong to the same architecture and are not to be exposed to external consumers. The service type identifier is functional which marks the microservice to fulfill a functional, usually business-oriented, capability within the PCSP. Other service type identifiers are infrastructure (the microservice provides an infrastructure capability, e.g., monitoring) and utility (the microservice provides a reusable utility capability that is not motivated by only a single business case, e.g., currency conversion). The microservice keyword is followed by the name of the microservice. A microservice name must have at least one qualifying level to determine the microservice's namespace . Qualifying levels are separated by dots ( . ) and all qualifying levels except the last one constitute the microservice's namespace 3 . Consequently, the fully-qualified name of the ChargingStationManagementCommandSide microservice is de.puls.ChargingStationManagementCommandSide . It consists of the namespace de.puls and the microservice's simple name ChargingStationManagementCommandSide .","title":"Microservice Definition"},{"location":"getting-started/tour/#interface-definition","text":"The definition of a microservice ends with a pair of curly brackets that cluster the service's interfaces. In LEMMA, each microservice must comprise at least one interface, and each interface specifies a single portion of the service's API 4 as a collection of one or more service operations (see below). LEMMA's Service Modeling Language , provides the interface keyword to introduce an interface. The keyword is followed by the name of the interface. That is, the above service model for the ChargingStationManagementCommandSide microservice defines a single interface called CommandSide . Like microservices, interfaces can receive visibility modifiers. Without an explicit visibility modifier, interfaces inherit the visibility of their defining microservices. As a result, the visibility of the CommandSide interface is public as this is the visibility of the ChargingStationManagementCommandSide microservice.","title":"Interface Definition"},{"location":"getting-started/tour/#operation-definition","text":"The definition of an interface ends with a pair of curly brackets that cluster the interface's operation. In LEMMA, each interface must comprise at least one operation. An operation definition does not require an introductory keyword. Instead, you state the name of the operation, followed by a pair of round brackets for possible parameters, and a semicolon to end the operation definition. Thus, in the above service model for the ChargingStationManagementCommandSide microservice, the CommandSide interface consists of a single operation createParkingArea which has two parameters (see below). LEMMA's Service Modeling Language also integrates a special syntax for API operation comments . It allows the documentation of an operation's purpose and can later be translated, e.g., into OpenAPI specifications . An API operation comment has to occur before the operation's definition and within a pair of three consecutive dashes ( --- ). Hence, the createParkingArea operation exhibits the API operation comment API endpoint for creating a parking area . Operation parameters may also receive a documentation as part of an API operation comment. For this purpose, LEMMA provides the built-in annotations @param , @requires , and @returns . @param and @requires document incoming operation parameters that are either optional ( @param ) or mandatory ( @requires ). @returns , on the other hand, documents outgoing operation parameters. After a built-in documentation annotation, the name of the parameter and the documentation comment follow. In the above service model for the ChargingStationManagementCommandSide microservice, you documented the purpose of the createParkingArea operation's incoming parameter command and the outgoing parameter response , respectively.","title":"Operation Definition"},{"location":"getting-started/tour/#parameter-definition","text":"A modeled service operation may receive and return an arbitrary number of parameters. A parameter definition starts with a keyword that identifies the parameter's communication type . The sync keyword introduces parameters that an operation expects to receive or promises to return synchronously. The async keyword, on the other hand, introduces parameters that an operation expects to receive or promises to return asynchronously. Next to a communication type, a parameter definition in LEMMA's Service Modeling Language can explicitly state the direction of a parameter which can be incoming ( in modifier), outgoing ( out modifier), or bidirectional ( inout modifier). In case a parameter definition omits a direction modifier, the parameter is assumed to be incoming. A parameter definition is concluded by the parameter's name, a colon, and the parameter's type. The type of a parameter may either be a built-in primitive type like int or String , or a domain concept imported from a LEMMA domain model (see above). To reference an imported domain concept for typing purposes, you first have to state the alias of the import, e.g., Domain , followed by two consecutive colons ( :: ), and the fully-qualified name of the concept within the imported domain model. The fully-qualified name of a domain concept consists of the name of the concept's context and the name of the concept itself separated by a dot. The following table identifies the communication type, direction, and type of each parameter of the createParkingArea operation from the above service model for the ChargingStationManagementCommandSide microservice Parameter Communication Type Direction Type command synchronous ( sync ) incoming ( in ) CreateParkingAreaCommand domain concept (from context ChargingStationManagement of imported model with alias Domain ) response synchronous ( sync ) outgoing ( out ) CreateParkingAreaCommandResponse domain concept (from context ChargingStationManagement of imported model with alias Domain ) From the definitions of its parameters, we can phrase the purpose of the createParkingArea operation in natural language as follows: Purpose of the createParkingArea operation in natural language Take a command object comprising all relevant information to create a new parking area as input, execute, and return a response to the caller consisting of the identifier of the new parking area and/or an error message. Since both parameters are marked as synchronous, the invocation of createParkingArea is blocking for callers, i.e., they should wait for a response before they can proceed sensibly.","title":"Parameter Definition"},{"location":"getting-started/tour/#step-4-enrich-the-service-model-with-technology-information","text":"So far, we have used LEMMA's Domain Data Modeling Language and Service Modeling Language to construct the domain model of the logical ChargingStationManagement microservice and the service model for its phyiscal command side microservice ( de.puls.ChargingStationManagementCommandSide ), respectively. Recall that LEMMA organizes its modeling languages into different architecture viewpoints on microservice architectures. That is, the domain model reifies the concepts of the domain view on the ChargingStationManagement microservice and the command side service model represents a portion of the service view on the microservice. Next to domain and service characteristics, another crucial aspect of MSA-based applications is technology or, more precisely, the possibility to employ an arbitrary number of heterogeneous technologies for microservice implementation and deployment 5 . LEMMA treats technology heterogeneity as a dedicated concern in microservice implementation and thus provides the Technology Modeling Language to cluster technology information in technology models that are flexibly applicable to modeled microservices. In the following, you will enrich the above technology-agnostic service model for the ChargingStationManagementCommandSide microservice with technology information for Java and the Spring framework . While this step binds the microservice to a certain technology stack, it also allows for generating executable code from the model, as we will see below. Before you can extend the service model with technology information, you are first required to construct or download LEMMA technology models for the desired technologies. As a first step, create a folder called technology in the models folder of the charging-station-management Eclipse project. Next, create the two files Java.technology and Spring.technology within the folder. The extension .technology informs Eclipse that the files are to comprise models expressed in LEMMA's Technology Modeling Language . The Project Explorer of your Eclipse workspace should now look similar to this: Next, copy the contents of the following two listings to the corresponding technology model file. Note Here, we will not go into further details concerning the construction of technology models. Please refer to the user guide of the Technology Modeling Language to learn about technology model construction. Additionally, the following two listings only comprise technology information relevant to the tour of LEMMA. You can follow these links to LEMMA's GitHub repository in order to examine the complete model contents: Java.technology , Spring.technology . Java.technology 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 technology Java { types { primitive type Boolean based on boolean default ; primitive type Byte based on byte default ; primitive type Character based on char default ; primitive type Date based on date default ; primitive type Double based on double default ; primitive type Float based on float default ; primitive type Integer based on int default ; primitive type Long based on long default ; primitive type Short based on short default ; primitive type String based on string default ; primitive type Object based on unspecified default ; } } Spring.technology 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 technology Spring { protocols { sync rest data formats \"application/json\" default with format \"application/json\" ; } service aspects { aspect Application < singleval > for microservices { string name; int port; } aspect DatasourceConfiguration for microservices { string driverClassName = \"org.h2.Driver\" ; string url < mandatory > ; string username < mandatory > ; string password < mandatory > ; } aspect Post < singleval > for operations { selector (protocol = rest); } aspect RequestBody < singleval > for parameters { selector (exchange_pattern = in); } aspect ResponseEntity < singleval > for parameters { selector (protocol = rest, exchange_pattern = out); } aspect Valid < singleval > for parameters ; } } With the technology models at hand, you can now turn the technology-agnostic service model for the ChargingStationManagementCommandSide microservice into a technology-specific service model. The following listing shows the result of this step and therefore identifies the technology extensions with // EXTENSION comments: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import datatypes from \"../../domain/ChargingStationManagement.data\" as Domain // EXTENSION (1) import technology from \"../../technology/Java.technology\" as Java // EXTENSION (2) import technology from \"../../technology/Spring.technology\" as Spring // EXTENSION (3) @technology (Java) // EXTENSION (4) @technology (Spring) // EXTENSION (5) @Spring::_aspects.Application (name= \"ChargingStationManagementCommandSide\" ) // EXTENSION (6) @Spring::_aspects.DatasourceConfiguration ( url = \"jdbc:h2:mem:command-side-db\" , username = \"${COMMAND_SIDE_SERVICE_DB_USER}\" , password = \"${COMMAND_SIDE_SERVICE_DB_PASSWORD}\" ) public functional microservice de.puls.ChargingStationManagementCommandSide { // EXTENSION (7) @endpoints (Spring::_protocols.rest: \"/resources\" ;) interface CommandSide { --- API endpoint for creating a parking area @requires command Command object to specify the values of the new parking area @returns response CreateParkingAreaCommandResponse with the identifier of the created parking area or an error message --- // EXTENSION (8) @endpoints (Spring::_protocols.rest: \"/parkingarea\" ;) // EXTENSION (9) @Spring::_aspects.Post createParkingArea( // EXTENSION (10) @Spring::_aspects.RequestBody // EXTENSION (11) @Spring::_aspects.Valid sync in command : Domain::ChargingStationManagement.CreateParkingAreaCommand, // EXTENSION (12) @Spring::_aspects.ResponseEntity sync out response : Domain::ChargingStationManagement.CreateParkingAreaCommandResponse ); } }","title":"Step 4: Enrich the Service Model with Technology Information"},{"location":"getting-started/tour/#technology-model-imports-and-applications","text":"Extensions (1) and (2) import the constructed Java and Spring technology models into the service model. The syntax for technology model imports is almost identical to that for domain model imports (see above). Specifically, technology model imports differ only for the import statement's [ELEMENT_TYPE] which receives the value technology instead of datatypes . Extensions (3) and (4) apply the imported technology models to the ChargingStationManagementCommandSide microservice using the Service Modeling Language's built-in @technology annotation. The annotation specifies in round brackets the aliases of the imported technology models to apply to a microservice. The application of technology models to microservices is necessary to express that a microservice depends on a certain technology and also makes technology aspects available for that microservice.","title":"Technology Model Imports and Applications"},{"location":"getting-started/tour/#technology-aspect-applications","text":"In LEMMA, the syntax for technology aspect application follows this pattern: @[IMPORTED_TECHNOLOGY_MODEL_ALIAS]::_aspects.[ASPECT_NAME]([POTENTIAL_ASPECT_PROPERTIES]) Extensions (5) , (6) , and (9) to (12) rely on this syntactical pattern to apply technology aspects from the imported Spring technology model to the ChargingStationManagementCommandSide microservice, its createParkingArea operation, and the operation's parameters. The following table describes the semantics of the applied Spring aspects: Extension Applied Aspect Targeted Model Element Semantics (5) Application ChargingStationManagementCommandSide microservice The aspect allows configuring of certain Core Properties of Spring Applications . Using the aspect's name property as illustrated by the above service model, it is for example possible to determine a value for Spring's spring.application.name Core Property. (6) DatasourceConfiguration ChargingStationManagementCommandSide microservice The aspect allows configuring of certain Data Properties of Spring Applications . For instance, the aspect's url , username , and password properties support the specification of values for Spring's spring.datasource.url , spring.datasource.username , and spring.datasource.password Data Properties, as shown in the above service model. (9) Post createParkingArea operation The aspect maps to Spring's @PostMapping annotation . (10) RequestBody command parameter The aspect maps to Spring's @RequestBody annotation . (11) Valid command parameter The aspect maps to the @Valid annotation from the Bean Validation API for Java. (12) ResponseEntity response parameter The aspect maps to Spring's @ResponseEntity annotation . In general, it is in the responsibility of LEMMA model processors (see below) to process technology aspects in a sensible manner. For example, in the above model for the ChargingStationManagementCommandSide microservice, the name property in the application of the Application aspect on the microservice receives the value \"ChargingStationManagementCommandSide\". LEMMA's code generator for Java and Spring (see below) will leverage this information from the aspect application to produce the entry spring.application.name=\"ChargingStationManagementCommandSide\" in the application.properties file for the microservice. Similarly, the generator will produce the @PostMapping annotation on the Java method it derives from the createParkingArea microservice operation because the service model applies the corresponding Post aspect on the modeled operation. Increase of LEMMA's Expressiveness by the Aspect Mechanism LEMMA's technology aspect mechanism is not constrained to the configuration of technology-related characteristics alone. More precisely, the Technology Modeling Language does not constrain the semantic scope of aspect-based metadata, thereby making technology aspects a powerful feature that allows semantic enrichment of LEMMA models as required. For instance, technology aspects can be used to integrate patterns such as CQRS with LEMMA. A corresponding technology model can be found in LEMMA's GitHub repository in the /examples/charging-station-management/models/technology/Cqrs.technology file.","title":"Technology Aspect Applications"},{"location":"getting-started/tour/#communication-protocol-endpoints","text":"Extensions (7) and (8) of the service model for the ChargingStationManagementCommandSide microservice configure communication protocol endpoints for the CommandSide interface and createParkingArea operation. Endpoint configurations follow this syntactical pattern: @endpoints([COMMUNICATION_PROTOCOL_REFERENCE]): \"[ENDPOINT_ADDRESSES]\" For the configuration of communication protocol endpoints, LEMMA's Service Modeling Language integrates the built-in annotation @endpoints . Applications of the annotation first reference in round brackets the communication protocol for which one or more endpoints shall be configured. The existence of communication protocols is specified within technology models. For example, the Spring.technology model that you constructed in the previous step, includes a definition of the rest protocol that maps to the eponymous architectural style . Within an endpoint configuration, we can refer to the communication protocol following a syntactical pattern very similar to technology aspect references within aspect applications: [IMPORTED_TECHNOLOGY_MODEL_ALIAS]::_protocols.[COMMUNICATION_PROTOCOL_NAME] Hence, to refer to the rest protocol from the Spring.technology model imported by the above service model under the Spring alias, you use the Spring::_protocols.rest statement in the applications of the @endpoints annotation on the CommandSide interface and createParkingArea operation. References to communication protocols within @endpoints annotations are followed by a colon and a list of endpoint addresses separated by commas. For the CommandSide interface and createParkingArea operation, the above service model specifies the endpoint addresses \"/resources\" and \"/parkingarea\", respectively.","title":"Communication Protocol Endpoints"},{"location":"getting-started/tour/#step-5-generate-java-code-from-the-service-model","text":"In the previous step, we enriched the service model with technology information that is can be used to map the model to executable Java code. In general, the process of mapping abstract model code to executable code in a programming language is called code generation . When focusing on Java and the Spring framework as the target environment for executable microservices, an intuitive mapping of the service model could consider, among others, the following relationships between model elements and Java code fragments: Map the modeled ChargingStationManagementCommandSide microservice to an eponymous Java class. Map the modeled CommandSide interface to an eponymous Java class. Since the interface exhibits a rest endpoint, add Spring's @RestController annotation to the class. Furthermore, configure the endpoint's \"/resources\" address for the interface by applying Spring's @RequestMapping annotation in the form @RequestMapping(value = {\"/resources\"}) . Map the modeled createParkingArea operation to a method within the Java class for the CommandSide interface. Among others, the method exhibits an application of Spring's @RequestMapping annotation for the \"/parkingarea\" rest endpoint, an application of Spring's PostMapping annotation (from the application of the @Post aspect on the modeled operation), and Java counterparts for the command and response parameters of the modeled operation. To obtain an executable, Java- and Spring-based microservice implementation from the above service model, you can leverage an Eclipse plugin that came as part of your LEMMA installation . You can activate the plugin by clicking on the \"Run As\"-button ( ) in Eclipse's menu bar or choose the \"Run\" entry from Eclipse's \"Run\" menu. Independent of whether you clicked the button or the menu entry, it is important that the service model is the current editor in the open Eclipse instance. If that is the case, the following dialog window will appear after clicking the button or the menu entry: In the window, hit the \"OK\" button which will result in the following dialog window to appear: Since you are going to generate executable microservice code from the service model via the Docker image of LEMMA's Java code generator , you can click on \"Continue\" thereby activating the following dialog window: This last dialog window allows for configuring the Java code generator. In fact, you can leave all configuration text boxes in their default state and only have to specify a target folder for the generated Java code. To this end, hit the \"Browse...\"-button next to the \"Generation target folder\" text box and select the \"src\" folder from the charging-station-management Eclipse project. The configuration dialog window should then look similar to this: Missing Java Base Generator Docker Image In case the dialog window displays an error marker for the \"Java Base Generator Docker image\" text box stating that the proposed lemma/java_generator:latest Docker image does not exist, it is likely the case that you did not rename the pulled image using the docker tag command as described in the \"Prerequisites\" section above. If that is the case, hit the \"Browse...\" button next to the \"Java Base Generator Docker image\" text box and select the Docker image with name lemmahub/java_generator:latest from the appearing dialog window. Finally, hit the \"Run\" button to start LEMMA's Java code generator on the service model for the ChargingStationManagementCommandS\u00edde microservice. Reusable Eclipse Run Configuration With hitting the \"Run\" button, LEMMA's Eclipse plugin for model processor execution will silently create an Eclipse Run Configuration called \"Run_JBG_Docker_ChargingStationManagementCommandSide_services\". You can review the Run Configuration within Eclipse using the menu entry \"Run > Run Configurations...\" and selecting the configuration from the launch group \"LEMMA Model Processor\" on the left side of the appearing dialog window. In the dialog window, you can hit the \"Show Command Line\" to review the command that the Run Configuration will execute on your system to run the Java code generator in a Docker container. The output of the button looks similar to this: The Run Configuration is reusable so that you do not have to complete the previous dialog window each time you want to re-generate code from the model. Instead, each time you click the \"Run As\"-button ( ) in the future while having the service model for the ChargingStationManagementCommandS\u00edde microservice opened in the active Eclipse editor, the Run Configuration will directly be executed. LEMMA's Eclipse plugin for model processor execution opens an Eclipse Console informing you about the various steps of the code generation process. The console message Model processor execution finished informs you about the success of the code generation process, which usually takes five to ten seconds.","title":"Step 5: Generate Java Code from the Service Model"},{"location":"getting-started/tour/#step-7-compile-and-review-the-generated-code","text":"After the code generation process finished, you can find the generated code in the \"src\" folder of the charging-station-management Eclipse project. Since LEMMA's Java code generator aims to produce all necessary artifacts for compiling and executing a microservice, you can find a pom.xml for the Maven build management system in the src/de/puls/ChargingStationManagementCommandSide folder. In case you have Maven and Java 11 or greater installed on your system, you can compile the generated code using the following command in the src/de/puls/ChargingStationManagementCommandSide folder: 1 mvn package After the command finished, the resulting Java archive can be found in the src/de/puls/ChargingStationManagementCommandSide/target folder within the charging-station-management-command-side-0.0.1-SNAPSHOT.jar file. From the src/de/puls/ChargingStationManagementCommandSidemain/java/de/puls/ChargingStationManagementCommandSide folder, you can also review the generated Java code. For example, you may want to have a look at the following files: ChargingStationManagementCommandSide.java : Class implementing the Spring entry point of the ChargingStationManagementCommandSide microservice. interfaces/CommandSide.java : Class implementing the modeled CommandSide interface and a method stub for the createParkingArea operation. domain/ChargingStationManagement/* : All classes obtained from the domain concepts comprised in the domain model for the ChargingStationManagement . Note how the Java code for the microservice, interface, and operation is consistent to the intuitive mapping described in Step 5 . MSA: The M icro s ervice A rchitecture style. \u21a9 Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9 This mechanism in fact follows the rules for package declarations in Java. \u21a9 API: Application Programming Interface (cf. https://en.wikipedia.org/wiki/API for a definition of the term). \u21a9 In fact, technology heterogeneity may be considered one of the benefits of MSA as it enables to employ the most sufficient technologies for microservice implementation and deployment. On the other hand, it can make microservices prone to technical debt and increase the learning curve for new team members. Careful consideration of the existing degree of technology heterogeneity is thus required before deciding for the adoption of new technologies such as programming languages, frameworks, databases, API gateways, or monitoring tools. \u21a9","title":"Step 7: Compile and Review the Generated Code"},{"location":"research/","text":"Research LEMMA originates from research on the application of Model-driven Engineering to mitigate the complexity of designing, implementing, and operating microservice architectures . The main source to learn everything about the motivation for LEMMA, its design, and implementation is the dissertation that conceived the ecosystem 1 . A list of further publications, mostly papers that are way shorter than the dissertation, can be found in the Science section of LEMMA's README on GitHub . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Research"},{"location":"research/#research","text":"LEMMA originates from research on the application of Model-driven Engineering to mitigate the complexity of designing, implementing, and operating microservice architectures . The main source to learn everything about the motivation for LEMMA, its design, and implementation is the dissertation that conceived the ecosystem 1 . A list of further publications, mostly papers that are way shorter than the dissertation, can be found in the Science section of LEMMA's README on GitHub . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Research"},{"location":"user-guide/","text":"User Guide The user guide provides information for stakeholders interested in expressing their concerns towards a microservice architecture from their specific viewpoint. More precisely, LEMMA provides a set of different, viewpoint-specific modeling languages to express such concerns in dedicated architecture models that can later be integrated and used, e.g., to generate executable microservice code. The following table provides an overview of the viewpoints on microservice architectures supported by LEMMA, and the addressed stakeholders and corresponding LEMMA modeling languages: Viewpoint Stakeholders Modeling Languages Domain Domain Experts, Microservice Developers, Software Architects Domain Data Modeling Language Operation Microservice Developers, Operators, Software Architects Operation Modeling Language Service Microservice Developers, Software Architects Service Modeling Language Technology Technology-Savvy Stakeholders, e.g., Microservice Developers, Operators, or Software Architects Technology Modeling Language Please note that LEMMA's documentation is currently work in progress. Therefore, the user guide is not complete yet and we will refer to sections in the dissertation that conceived LEMMA 1 whenever there exists no dedicated writing for a certain article in the user guide yet. Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Introduction"},{"location":"user-guide/#user-guide","text":"The user guide provides information for stakeholders interested in expressing their concerns towards a microservice architecture from their specific viewpoint. More precisely, LEMMA provides a set of different, viewpoint-specific modeling languages to express such concerns in dedicated architecture models that can later be integrated and used, e.g., to generate executable microservice code. The following table provides an overview of the viewpoints on microservice architectures supported by LEMMA, and the addressed stakeholders and corresponding LEMMA modeling languages: Viewpoint Stakeholders Modeling Languages Domain Domain Experts, Microservice Developers, Software Architects Domain Data Modeling Language Operation Microservice Developers, Operators, Software Architects Operation Modeling Language Service Microservice Developers, Software Architects Service Modeling Language Technology Technology-Savvy Stakeholders, e.g., Microservice Developers, Operators, or Software Architects Technology Modeling Language Please note that LEMMA's documentation is currently work in progress. Therefore, the user guide is not complete yet and we will refer to sections in the dissertation that conceived LEMMA 1 whenever there exists no dedicated writing for a certain article in the user guide yet. Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"User Guide"},{"location":"user-guide/domain-data-modeling-language/","text":"Domain Data Modeling Language LEMMA's documentation is currently work in progress. Therefore, to get an impression on how to use LEMMA's Domain Data Modeling Language to construct domain models that can be mapped to executable code, please refer to the corresponding section of the LEMMA Tour . To dive into the design and implementation of LEMMA's Domain Data Modeling Language, for now refer to Sections 4.4.1 and 5.3.1 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Domain Data Modeling Language"},{"location":"user-guide/domain-data-modeling-language/#domain-data-modeling-language","text":"LEMMA's documentation is currently work in progress. Therefore, to get an impression on how to use LEMMA's Domain Data Modeling Language to construct domain models that can be mapped to executable code, please refer to the corresponding section of the LEMMA Tour . To dive into the design and implementation of LEMMA's Domain Data Modeling Language, for now refer to Sections 4.4.1 and 5.3.1 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Domain Data Modeling Language"},{"location":"user-guide/model-processing/","text":"Model Processing Here be dragons.","title":"Model Processing"},{"location":"user-guide/model-processing/#model-processing","text":"Here be dragons.","title":"Model Processing"},{"location":"user-guide/model-processing/static-analysis/","text":"Static Analysis Here be dragons.","title":"Static Analysis"},{"location":"user-guide/model-processing/static-analysis/#static-analysis","text":"Here be dragons.","title":"Static Analysis"},{"location":"user-guide/operation-modeling-language/","text":"Operation Modeling Language LEMMA's documentation is currently work in progress. Therefore, to learn more about the design and implementation of LEMMA's Operation Modeling Language and how to use it to construct operation models for microservices and their infrastructure, please refer to Sections 4.4.5 and 5.3.5 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Operation Modeling Language"},{"location":"user-guide/operation-modeling-language/#operation-modeling-language","text":"LEMMA's documentation is currently work in progress. Therefore, to learn more about the design and implementation of LEMMA's Operation Modeling Language and how to use it to construct operation models for microservices and their infrastructure, please refer to Sections 4.4.5 and 5.3.5 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Operation Modeling Language"},{"location":"user-guide/service-modeling-language/","text":"Service Modeling Language LEMMA's documentation is currently work in progress. Therefore, to get an impression on how to use LEMMA's Service Modeling Language to construct microservice models that can be mapped to executable code, please refer to the corresponding section of the LEMMA Tour . To dive into the design and implementation of LEMMA's Service Modeling Language, for now refer to Sections 4.4.3 and 5.3.3 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Service Modeling Language"},{"location":"user-guide/service-modeling-language/#service-modeling-language","text":"LEMMA's documentation is currently work in progress. Therefore, to get an impression on how to use LEMMA's Service Modeling Language to construct microservice models that can be mapped to executable code, please refer to the corresponding section of the LEMMA Tour . To dive into the design and implementation of LEMMA's Service Modeling Language, for now refer to Sections 4.4.3 and 5.3.3 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Service Modeling Language"},{"location":"user-guide/service-technology-mapping-modeling-language/","text":"Service Technology Mapping Modeling Language LEMMA's documentation is currently work in progress. Therefore, to learn more about the design and implementation of LEMMA's Service Technology Mapping Modeling Language and how to use it to construct mapping models that enable to separate technology-related configurations from domain and service information, please refer to Sections 4.4.4 and 5.3.4 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Service Technology Mapping Modeling Language"},{"location":"user-guide/service-technology-mapping-modeling-language/#service-technology-mapping-modeling-language","text":"LEMMA's documentation is currently work in progress. Therefore, to learn more about the design and implementation of LEMMA's Service Technology Mapping Modeling Language and how to use it to construct mapping models that enable to separate technology-related configurations from domain and service information, please refer to Sections 4.4.4 and 5.3.4 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Service Technology Mapping Modeling Language"},{"location":"user-guide/technology-modeling-language/","text":"Technology Modeling Language LEMMA's documentation is currently work in progress. Therefore, to get an impression of technology modeling in LEMMA, please refer to the corresponding section of the LEMMA Tour . To dive into the design and implementation of LEMMA's Technology Modeling Language, for now refer to Sections 4.4.2 and 5.3.2 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Technology Modeling Language"},{"location":"user-guide/technology-modeling-language/#technology-modeling-language","text":"LEMMA's documentation is currently work in progress. Therefore, to get an impression of technology modeling in LEMMA, please refer to the corresponding section of the LEMMA Tour . To dive into the design and implementation of LEMMA's Technology Modeling Language, for now refer to Sections 4.4.2 and 5.3.2 of the dissertation that conceived LEMMA 1 . Rademacher, Florian: A Language Ecosystem for Modeling Microservice Architecture . University of Kassel, Department of Electrical Engineering and Computer Science, PhD Thesis, October 2022. https://kobra.uni-kassel.de/handle/123456789/14176 . \u2013 867 p.. \u21a9","title":"Technology Modeling Language"}]}